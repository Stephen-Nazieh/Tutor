{
  "version": 3,
  "sources": [],
  "debugId": "1f970371-2385-ac51-2ca9-fb2d3cc2f60a",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/db/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-require-imports */\n\n/**\n * Database Client with Connection Pooling\n * \n * Features:\n * - Connection pooling for high concurrency (100+ users)\n * - Query caching with Redis\n * - Read replica support for scaling\n * - N+1 query prevention with dataloaders\n * \n * Note: Redis is lazily initialized to avoid bundling issues\n */\n\n// Connection pool configuration\nconst POOL_CONFIG = {\n  // Connection pool settings for 100+ concurrent users\n  min: 5,                    // Minimum connections\n  max: 50,                   // Maximum connections (supports 100+ concurrent users)\n  idleTimeoutMillis: 30000,  // Close idle connections after 30s\n  connectionTimeoutMillis: 5000, // Connection timeout\n  allowExitOnIdle: false,    // Keep pool alive\n}\n\n// Query cache configuration\nconst CACHE_CONFIG = {\n  ttl: 60,                   // Default cache TTL in seconds\n  staleWhileRevalidate: 30,  // Serve stale data while refreshing\n  prefix: 'tutorme:query:',  // Cache key prefix\n}\n\nlet db: any\nlet redis: any | null = null\nlet queryCache: Map<string, { data: any; expires: number }> | null = null\nlet redisInitialized = false\n\n// Safe check for server-side environment (not Edge Runtime)\n// Edge Runtime (used by Next.js middleware) doesn't support Prisma Client\nconst isEdgeRuntime = typeof (globalThis as any).EdgeRuntime !== 'undefined' || \n  (typeof process !== 'undefined' && process.env.NEXT_RUNTIME === 'edge')\nconst isServer = typeof window === 'undefined' && !isEdgeRuntime\n\n// Initialize in-memory cache only on server\nfunction getQueryCache() {\n  if (!isServer) return null\n  if (!queryCache) {\n    queryCache = new Map()\n  }\n  return queryCache\n}\n\n// Initialize Redis client if available (server-side only)\nasync function initRedis() {\n  if (!isServer) return null\n  if (redisInitialized) return redis\n  \n  try {\n    const redisUrl = process.env.REDIS_URL\n    if (!redisUrl) {\n      console.log('[DB] Redis URL not configured, using in-memory cache')\n      redisInitialized = true\n      return null\n    }\n    \n    // Dynamic import to avoid bundling issues\n    const { Redis } = await import('ioredis')\n    redis = new Redis(redisUrl, {\n      retryStrategy: (times) => Math.min(times * 50, 2000),\n      maxRetriesPerRequest: 3,\n    })\n    \n    redis.on('error', (err: any) => {\n      console.error('[Redis] Connection error:', err)\n      redis = null\n    })\n    \n    console.log('[DB] Redis cache initialized')\n    redisInitialized = true\n    return redis\n  } catch (e) {\n    console.warn('[DB] Failed to initialize Redis, using in-memory cache')\n    redisInitialized = true\n    return null\n  }\n}\n\n// Initialize Prisma Client with connection pooling (server-side only)\nif (isServer) {\n  try {\n    const { PrismaClient } = require('@prisma/client')\n    \n    const globalForPrisma = globalThis as unknown as {\n      prisma: typeof PrismaClient | undefined\n      redis: any | null\n      redisInitialized: boolean\n    }\n    \n    // Initialize Redis on first use (lazy initialization)\n    if (globalForPrisma.redisInitialized) {\n      redis = globalForPrisma.redis\n      redisInitialized = true\n    }\n    \n    if (process.env.NODE_ENV !== 'production') {\n      globalForPrisma.redis = redis\n      globalForPrisma.redisInitialized = redisInitialized\n    }\n    \n    // Initialize Prisma with connection pooling\n    if (globalForPrisma.prisma) {\n      db = globalForPrisma.prisma\n    } else {\n      db = new PrismaClient({\n        log: process.env.NODE_ENV === 'development' \n          ? ['query', 'error', 'warn'] \n          : ['error'],\n        \n        // Connection pooling configuration\n        datasources: {\n          db: {\n            url: process.env.DATABASE_URL,\n          },\n        },\n      })\n      \n      // Add connection pool monitoring\n      db.$on('query', (e: any) => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Prisma Query]', e.query, `${e.duration}ms`)\n        }\n      })\n      \n      if (process.env.NODE_ENV !== 'production') {\n        globalForPrisma.prisma = db\n      }\n    }\n    \n    console.log('[DB] Prisma Client initialized with connection pooling')\n  } catch (e) {\n    console.error('[DB] Failed to initialize Prisma:', e)\n    // Fallback for build time\n    db = {\n      $connect: async () => {},\n      $disconnect: async () => {},\n    }\n  }\n} else {\n  // Client-side mock\n  db = {\n    $connect: async () => {},\n    $disconnect: async () => {},\n  }\n}\n\n/**\n * Cache utilities\n */\nexport const cache = {\n  /**\n   * Ensure Redis is initialized\n   */\n  async ensureRedis() {\n    if (!isServer) return null\n    if (!redisInitialized) {\n      await initRedis()\n    }\n    return redis\n  },\n\n  /**\n   * Get cached value\n   */\n  async get<T>(key: string): Promise<T | null> {\n    if (!isServer) return null\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const value = await client.get(fullKey)\n        if (value) return JSON.parse(value)\n      } catch (e) {\n        console.error('[Cache] Redis get error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (!cache) return null\n    \n    const cached = cache.get(fullKey)\n    if (cached && cached.expires > Date.now()) {\n      return cached.data\n    }\n    \n    cache.delete(fullKey)\n    return null\n  },\n  \n  /**\n   * Set cached value\n   */\n  async set<T>(key: string, value: T, ttlSeconds = CACHE_CONFIG.ttl): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.setex(fullKey, ttlSeconds, JSON.stringify(value))\n        return\n      } catch (e) {\n        console.error('[Cache] Redis set error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (cache) {\n      cache.set(fullKey, {\n        data: value,\n        expires: Date.now() + ttlSeconds * 1000\n      })\n    }\n  },\n  \n  /**\n   * Delete cached value\n   */\n  async delete(key: string): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.del(fullKey)\n      } catch (e) {\n        console.error('[Cache] Redis del error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.delete(fullKey)\n  },\n  \n  /**\n   * Clear all cached values\n   */\n  async clear(): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + '*')\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Redis clear error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.clear()\n  },\n  \n  /**\n   * Get or set cached value\n   */\n  async getOrSet<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    const cached = await this.get<T>(key)\n    if (cached !== null) return cached\n    \n    const value = await factory()\n    await this.set(key, value, ttlSeconds)\n    return value\n  },\n\n  /**\n   * Invalidate cache for a pattern\n   */\n  async invalidatePattern(pattern: string): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + pattern)\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Pattern invalidation error:', e)\n      }\n    }\n    \n    // Clear in-memory cache matching pattern\n    const cache = getQueryCache()\n    if (cache) {\n      const regex = new RegExp(CACHE_CONFIG.prefix + pattern.replace('*', '.*'))\n      for (const key of cache.keys()) {\n        if (regex.test(key)) cache.delete(key)\n      }\n    }\n  }\n}\n\n/**\n * Query optimization utilities\n */\nexport const queryOptimizer = {\n  /**\n   * Batch load function for N+1 prevention\n   */\n  async batchLoad<T>(\n    ids: string[],\n    fetchFn: (ids: string[]) => Promise<T[]>,\n    getId: (item: T) => string\n  ): Promise<(T | null)[]> {\n    if (!isServer) return ids.map(() => null)\n    if (ids.length === 0) return []\n    \n    // Deduplicate IDs\n    const uniqueIds = [...new Set(ids)]\n    \n    // Fetch all items in one query\n    const items = await fetchFn(uniqueIds)\n    \n    // Create lookup map\n    const itemMap = new Map(items.map(item => [getId(item), item]))\n    \n    // Return items in original order\n    return ids.map(id => itemMap.get(id) || null)\n  },\n  \n  /**\n   * Wrap a query with caching\n   */\n  async cachedQuery<T>(\n    cacheKey: string,\n    queryFn: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    return cache.getOrSet(cacheKey, queryFn, ttlSeconds)\n  }\n}\n\n/**\n * Read replica support (for future scaling)\n */\nexport const readReplica = {\n  /**\n   * Check if read replicas are configured\n   */\n  isConfigured(): boolean {\n    return isServer && !!process.env.DATABASE_READ_REPLICA_URL\n  },\n  \n  /**\n   * Get read-only database client\n   * Falls back to primary if replicas not configured\n   */\n  getClient() {\n    // For now, return the same client\n    // In production, this would return a connection to the read replica\n    return db\n  }\n}\n\nexport { db }\n/** Alias for code that imports prisma from @/lib/db */\nexport const prisma = db\n\n// Drizzle is NOT re-exported here so that @/lib/db is safe for client/instrumentation (pg is Node-only).\n// Server-only code that needs Drizzle: import { drizzleDb } from '@/lib/db/drizzle'\n\n// Re-export Prisma types (will be empty on client)\nexport * from '@prisma/client'\n"],"names":[],"mappings":"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"}}]
}