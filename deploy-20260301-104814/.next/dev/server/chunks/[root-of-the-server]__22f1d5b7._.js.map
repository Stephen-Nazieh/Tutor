{
  "version": 3,
  "sources": [],
  "debugId": "36ccf36e-bda8-9351-9f26-891c41270657",
  "sections": [
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/db/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-require-imports */\n\n/**\n * Database Client with Connection Pooling\n * \n * Features:\n * - Connection pooling for high concurrency (100+ users)\n * - Query caching with Redis\n * - Read replica support for scaling\n * - N+1 query prevention with dataloaders\n * \n * Note: Redis is lazily initialized to avoid bundling issues\n */\n\n// Connection pool configuration\nconst POOL_CONFIG = {\n  // Connection pool settings for 100+ concurrent users\n  min: 5,                    // Minimum connections\n  max: 50,                   // Maximum connections (supports 100+ concurrent users)\n  idleTimeoutMillis: 30000,  // Close idle connections after 30s\n  connectionTimeoutMillis: 5000, // Connection timeout\n  allowExitOnIdle: false,    // Keep pool alive\n}\n\n// Query cache configuration\nconst CACHE_CONFIG = {\n  ttl: 60,                   // Default cache TTL in seconds\n  staleWhileRevalidate: 30,  // Serve stale data while refreshing\n  prefix: 'tutorme:query:',  // Cache key prefix\n}\n\nlet db: any\nlet redis: any | null = null\nlet queryCache: Map<string, { data: any; expires: number }> | null = null\nlet redisInitialized = false\n\n// Safe check for server-side environment (not Edge Runtime)\n// Edge Runtime (used by Next.js middleware) doesn't support Prisma Client\nconst isEdgeRuntime = typeof (globalThis as any).EdgeRuntime !== 'undefined' || \n  (typeof process !== 'undefined' && process.env.NEXT_RUNTIME === 'edge')\nconst isServer = typeof window === 'undefined' && !isEdgeRuntime\n\n// Initialize in-memory cache only on server\nfunction getQueryCache() {\n  if (!isServer) return null\n  if (!queryCache) {\n    queryCache = new Map()\n  }\n  return queryCache\n}\n\n// Initialize Redis client if available (server-side only)\nasync function initRedis() {\n  if (!isServer) return null\n  if (redisInitialized) return redis\n  \n  try {\n    const redisUrl = process.env.REDIS_URL\n    if (!redisUrl) {\n      console.log('[DB] Redis URL not configured, using in-memory cache')\n      redisInitialized = true\n      return null\n    }\n    \n    // Dynamic import to avoid bundling issues\n    const { Redis } = await import('ioredis')\n    redis = new Redis(redisUrl, {\n      retryStrategy: (times) => Math.min(times * 50, 2000),\n      maxRetriesPerRequest: 3,\n    })\n    \n    redis.on('error', (err: any) => {\n      console.error('[Redis] Connection error:', err)\n      redis = null\n    })\n    \n    console.log('[DB] Redis cache initialized')\n    redisInitialized = true\n    return redis\n  } catch (e) {\n    console.warn('[DB] Failed to initialize Redis, using in-memory cache')\n    redisInitialized = true\n    return null\n  }\n}\n\n// Initialize Prisma Client with connection pooling (server-side only)\nif (isServer) {\n  try {\n    const { PrismaClient } = require('@prisma/client')\n    \n    const globalForPrisma = globalThis as unknown as {\n      prisma: typeof PrismaClient | undefined\n      redis: any | null\n      redisInitialized: boolean\n    }\n    \n    // Initialize Redis on first use (lazy initialization)\n    if (globalForPrisma.redisInitialized) {\n      redis = globalForPrisma.redis\n      redisInitialized = true\n    }\n    \n    if (process.env.NODE_ENV !== 'production') {\n      globalForPrisma.redis = redis\n      globalForPrisma.redisInitialized = redisInitialized\n    }\n    \n    // Initialize Prisma with connection pooling\n    if (globalForPrisma.prisma) {\n      db = globalForPrisma.prisma\n    } else {\n      db = new PrismaClient({\n        log: process.env.NODE_ENV === 'development' \n          ? ['query', 'error', 'warn'] \n          : ['error'],\n        \n        // Connection pooling configuration\n        datasources: {\n          db: {\n            url: process.env.DATABASE_URL,\n          },\n        },\n      })\n      \n      // Add connection pool monitoring\n      db.$on('query', (e: any) => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Prisma Query]', e.query, `${e.duration}ms`)\n        }\n      })\n      \n      if (process.env.NODE_ENV !== 'production') {\n        globalForPrisma.prisma = db\n      }\n    }\n    \n    console.log('[DB] Prisma Client initialized with connection pooling')\n  } catch (e) {\n    console.error('[DB] Failed to initialize Prisma:', e)\n    // Fallback for build time\n    db = {\n      $connect: async () => {},\n      $disconnect: async () => {},\n    }\n  }\n} else {\n  // Client-side mock\n  db = {\n    $connect: async () => {},\n    $disconnect: async () => {},\n  }\n}\n\n/**\n * Cache utilities\n */\nexport const cache = {\n  /**\n   * Ensure Redis is initialized\n   */\n  async ensureRedis() {\n    if (!isServer) return null\n    if (!redisInitialized) {\n      await initRedis()\n    }\n    return redis\n  },\n\n  /**\n   * Get cached value\n   */\n  async get<T>(key: string): Promise<T | null> {\n    if (!isServer) return null\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const value = await client.get(fullKey)\n        if (value) return JSON.parse(value)\n      } catch (e) {\n        console.error('[Cache] Redis get error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (!cache) return null\n    \n    const cached = cache.get(fullKey)\n    if (cached && cached.expires > Date.now()) {\n      return cached.data\n    }\n    \n    cache.delete(fullKey)\n    return null\n  },\n  \n  /**\n   * Set cached value\n   */\n  async set<T>(key: string, value: T, ttlSeconds = CACHE_CONFIG.ttl): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.setex(fullKey, ttlSeconds, JSON.stringify(value))\n        return\n      } catch (e) {\n        console.error('[Cache] Redis set error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (cache) {\n      cache.set(fullKey, {\n        data: value,\n        expires: Date.now() + ttlSeconds * 1000\n      })\n    }\n  },\n  \n  /**\n   * Delete cached value\n   */\n  async delete(key: string): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.del(fullKey)\n      } catch (e) {\n        console.error('[Cache] Redis del error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.delete(fullKey)\n  },\n  \n  /**\n   * Clear all cached values\n   */\n  async clear(): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + '*')\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Redis clear error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.clear()\n  },\n  \n  /**\n   * Get or set cached value\n   */\n  async getOrSet<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    const cached = await this.get<T>(key)\n    if (cached !== null) return cached\n    \n    const value = await factory()\n    await this.set(key, value, ttlSeconds)\n    return value\n  },\n\n  /**\n   * Invalidate cache for a pattern\n   */\n  async invalidatePattern(pattern: string): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + pattern)\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Pattern invalidation error:', e)\n      }\n    }\n    \n    // Clear in-memory cache matching pattern\n    const cache = getQueryCache()\n    if (cache) {\n      const regex = new RegExp(CACHE_CONFIG.prefix + pattern.replace('*', '.*'))\n      for (const key of cache.keys()) {\n        if (regex.test(key)) cache.delete(key)\n      }\n    }\n  }\n}\n\n/**\n * Query optimization utilities\n */\nexport const queryOptimizer = {\n  /**\n   * Batch load function for N+1 prevention\n   */\n  async batchLoad<T>(\n    ids: string[],\n    fetchFn: (ids: string[]) => Promise<T[]>,\n    getId: (item: T) => string\n  ): Promise<(T | null)[]> {\n    if (!isServer) return ids.map(() => null)\n    if (ids.length === 0) return []\n    \n    // Deduplicate IDs\n    const uniqueIds = [...new Set(ids)]\n    \n    // Fetch all items in one query\n    const items = await fetchFn(uniqueIds)\n    \n    // Create lookup map\n    const itemMap = new Map(items.map(item => [getId(item), item]))\n    \n    // Return items in original order\n    return ids.map(id => itemMap.get(id) || null)\n  },\n  \n  /**\n   * Wrap a query with caching\n   */\n  async cachedQuery<T>(\n    cacheKey: string,\n    queryFn: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    return cache.getOrSet(cacheKey, queryFn, ttlSeconds)\n  }\n}\n\n/**\n * Read replica support (for future scaling)\n */\nexport const readReplica = {\n  /**\n   * Check if read replicas are configured\n   */\n  isConfigured(): boolean {\n    return isServer && !!process.env.DATABASE_READ_REPLICA_URL\n  },\n  \n  /**\n   * Get read-only database client\n   * Falls back to primary if replicas not configured\n   */\n  getClient() {\n    // For now, return the same client\n    // In production, this would return a connection to the read replica\n    return db\n  }\n}\n\nexport { db }\n/** Alias for code that imports prisma from @/lib/db */\nexport const prisma = db\n\n// Re-export Prisma types (will be empty on client)\nexport * from '@prisma/client'\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/auth.ts"],"sourcesContent":["/**\n * NextAuth Configuration\n * Handles authentication for students, tutors, and admins\n */\n\nimport { NextAuthOptions } from 'next-auth'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { PrismaAdapter } from '@next-auth/prisma-adapter'\nimport { db } from '@/lib/db'\nimport bcrypt from 'bcryptjs'\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(db),\n\n  providers: [\n    // Email/Password Login\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null\n        }\n\n        const normalizedEmail = credentials.email.trim().toLowerCase()\n\n        // Find user by email\n        const user = await db.user.findFirst({\n          where: { email: { equals: normalizedEmail, mode: 'insensitive' } },\n          include: { profile: true }\n        })\n\n        if (!user || !user.password) {\n          return null\n        }\n\n        // Verify password\n        const isValid = await bcrypt.compare(credentials.password, user.password)\n\n        if (!isValid) {\n          const { logFailedLogin } = await import('@/lib/security/suspicious-activity')\n          await logFailedLogin(null, normalizedEmail)\n          return null\n        }\n\n\n        // Check if onboarding is complete\n        const onboardingComplete = checkOnboardingComplete(user)\n        const tosAccepted = user.profile?.tosAccepted || false\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.profile?.name || user.email,\n          role: user.role,\n          image: user.profile?.avatarUrl,\n          onboardingComplete,\n          tosAccepted\n        }\n      }\n    })\n  ],\n\n  // WeChat OAuth - To be added later\n  // WeChatProvider({\n  //   clientId: process.env.WECHAT_APP_ID!,\n  //   clientSecret: process.env.WECHAT_APP_SECRET!,\n  // })\n  // ], // This was an extra closing bracket for providers array, removed it.\n\n  callbacks: {\n    async jwt({ token, user, trigger, session }) {\n      if (user) {\n        token.role = user.role\n        token.id = user.id\n        token.onboardingComplete = user.onboardingComplete\n        token.tosAccepted = user.tosAccepted\n      }\n\n      // Handle session update (e.g., after onboarding completes)\n      if (trigger === 'update' && session) {\n        token.onboardingComplete = true\n      }\n\n      return token\n    },\n\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.role = token.role as string\n        session.user.id = token.id as string\n        session.user.onboardingComplete = token.onboardingComplete as boolean\n        session.user.tosAccepted = token.tosAccepted as boolean\n      }\n      return session\n    }\n  },\n\n  pages: {\n    signIn: '/login',\n    error: '/login'\n  },\n\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60 // 30 days\n  },\n\n  secret: process.env.NEXTAUTH_SECRET\n}\n\n// Helper function to check if onboarding is complete\nfunction checkOnboardingComplete(user: { profile?: { isOnboarded?: boolean | null } | null }): boolean {\n  // Check if user profile exists and has completed onboarding\n  if (!user?.profile) {\n    return false\n  }\n  \n  // Profile exists but isOnboarded field is not set (null/undefined) - consider not onboarded\n  if (user.profile.isOnboarded === null || user.profile.isOnboarded === undefined) {\n    return false\n  }\n  \n  // Return the actual onboarding status\n  return user.profile.isOnboarded\n}\n\n// Helper function to hash passwords\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\n// Helper function to check if user is authorized\nexport function isAuthorized(userRole: string, allowedRoles: string[]): boolean {\n  return allowedRoles.includes(userRole)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/notifications/notify.ts"],"sourcesContent":["/**\n * Central Notification Service\n *\n * Handles all three channels in one call:\n *  - In-app (DB record)\n *  - Email (via Resend API)\n *  - Real-time push (via SSE broadcast)\n *\n * Usage:\n *   import { notify, notifyMany } from '@/lib/notifications/notify'\n *   await notify({ userId, type: 'assignment', title, message, actionUrl })\n *   await notifyMany({ userIds: [...], type, title, message })\n */\n\nimport { db } from '@/lib/db'\n\n// ---- Types ----\n\nexport type NotificationType =\n    | 'assignment'\n    | 'class'\n    | 'message'\n    | 'enrollment'\n    | 'payment'\n    | 'system'\n    | 'reminder'\n    | 'achievement'\n    | 'grade'\n\ninterface NotifyParams {\n    userId: string\n    type: NotificationType\n    title: string\n    message: string\n    data?: Record<string, unknown>\n    actionUrl?: string\n    /** Skip checking preferences (for critical system notifications) */\n    force?: boolean\n}\n\ninterface NotifyManyParams {\n    userIds: string[]\n    type: NotificationType\n    title: string\n    message: string\n    data?: Record<string, unknown>\n    actionUrl?: string\n    force?: boolean\n}\n\n// ---- SSE Event Bus (in-memory) ----\n\ntype SSECallback = (notification: any) => void\nconst sseListeners = new Map<string, Set<SSECallback>>()\n\nexport function addSSEListener(userId: string, cb: SSECallback) {\n    if (!sseListeners.has(userId)) sseListeners.set(userId, new Set())\n    sseListeners.get(userId)!.add(cb)\n    return () => {\n        sseListeners.get(userId)?.delete(cb)\n        if (sseListeners.get(userId)?.size === 0) sseListeners.delete(userId)\n    }\n}\n\nfunction broadcastToUser(userId: string, notification: any) {\n    const listeners = sseListeners.get(userId)\n    if (listeners) {\n        for (const cb of listeners) {\n            try { cb(notification) } catch { /* ignore */ }\n        }\n    }\n}\n\n// ---- Preference Check ----\n\ninterface ChannelDecision {\n    inApp: boolean\n    email: boolean\n    push: boolean\n}\n\nasync function getChannelDecision(\n    userId: string,\n    type: NotificationType,\n    force: boolean\n): Promise<ChannelDecision> {\n    if (force) return { inApp: true, email: true, push: true }\n\n    const prefs = await db.notificationPreference.findUnique({\n        where: { userId },\n    })\n\n    if (!prefs) return { inApp: true, email: true, push: true } // defaults\n\n    // Start with global toggles\n    let decision: ChannelDecision = {\n        inApp: prefs.inAppEnabled,\n        email: prefs.emailEnabled,\n        push: prefs.pushEnabled,\n    }\n\n    // Apply per-type overrides\n    const overrides = prefs.channelOverrides as Record<string, any> | null\n    if (overrides && overrides[type]) {\n        const typeOverride = overrides[type]\n        if (typeof typeOverride.inApp === 'boolean') decision.inApp = typeOverride.inApp\n        if (typeof typeOverride.email === 'boolean') decision.email = typeOverride.email\n        if (typeof typeOverride.push === 'boolean') decision.push = typeOverride.push\n    }\n\n    // Check quiet hours for push/email\n    if (prefs.quietHoursStart && prefs.quietHoursEnd) {\n        const isQuiet = isInQuietHours(prefs.quietHoursStart, prefs.quietHoursEnd, prefs.timezone)\n        if (isQuiet) {\n            decision.push = false\n            // Email follows digest preference during quiet hours\n        }\n    }\n\n    // Email digest: if not \"instant\", skip immediate email\n    if (prefs.emailDigest !== 'instant') {\n        decision.email = false\n    }\n\n    return decision\n}\n\nfunction isInQuietHours(start: string, end: string, timezone: string): boolean {\n    try {\n        const now = new Date()\n        const formatter = new Intl.DateTimeFormat('en-US', {\n            timeZone: timezone,\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: false,\n        })\n        const currentTime = formatter.format(now) // \"HH:MM\"\n\n        // Simple string comparison works for HH:mm format\n        if (start <= end) {\n            return currentTime >= start && currentTime <= end\n        }\n        // Wraps midnight (e.g. 22:00 - 07:00)\n        return currentTime >= start || currentTime <= end\n    } catch {\n        return false\n    }\n}\n\n// ---- Email Sending ----\n\nasync function sendNotificationEmail(\n    userId: string,\n    type: NotificationType,\n    title: string,\n    message: string,\n    actionUrl?: string\n) {\n    const apiKey = process.env.RESEND_API_KEY\n    if (!apiKey) {\n        console.log(`[notify-email] (no RESEND_API_KEY) Would email user ${userId}: ${title}`)\n        return\n    }\n\n    // Fetch user email\n    const user = await db.user.findUnique({\n        where: { id: userId },\n        select: { email: true, name: true },\n    })\n    if (!user?.email) return\n\n    const from = process.env.NOTIFICATION_EMAIL_FROM || 'TutorMe <notifications@tutorme.com>'\n    const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n\n    const actionButton = actionUrl\n        ? `<p style=\"margin-top:16px\"><a href=\"${appUrl}${actionUrl}\" style=\"background:#3b82f6;color:white;padding:10px 20px;border-radius:6px;text-decoration:none;display:inline-block\">View Details</a></p>`\n        : ''\n\n    const html = `\n    <div style=\"max-width:480px;margin:0 auto;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif\">\n      <div style=\"padding:24px;background:#f8fafc;border-radius:12px\">\n        <h2 style=\"margin:0 0 8px;color:#1e293b;font-size:18px\">${title}</h2>\n        <p style=\"margin:0;color:#475569;font-size:14px;line-height:1.6\">${message}</p>\n        ${actionButton}\n      </div>\n      <p style=\"text-align:center;color:#94a3b8;font-size:12px;margin-top:16px\">\n        You can <a href=\"${appUrl}/student/settings\" style=\"color:#3b82f6\">manage your notification preferences</a>.\n      </p>\n    </div>\n  `\n\n    try {\n        const res = await fetch('https://api.resend.com/emails', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${apiKey}`,\n            },\n            body: JSON.stringify({\n                from,\n                to: user.email,\n                subject: `${title} â€“ TutorMe`,\n                html,\n            }),\n        })\n        if (!res.ok) {\n            const err = await res.text()\n            console.error(`[notify-email] Resend failed:`, res.status, err)\n        }\n    } catch (e) {\n        console.error(`[notify-email] Send failed:`, e)\n    }\n}\n\n// ---- Main Functions ----\n\n/**\n * Send a notification to a single user across all enabled channels.\n */\nexport async function notify(params: NotifyParams) {\n    const { userId, type, title, message, data, actionUrl, force = false } = params\n\n    const channels = await getChannelDecision(userId, type, force)\n\n    let notification = null\n\n    // 1. In-app notification (DB)\n    if (channels.inApp) {\n        notification = await db.notification.create({\n            data: {\n                userId,\n                type,\n                title,\n                message,\n                data: data ?? undefined,\n                actionUrl,\n            },\n        })\n    }\n\n    // 2. Real-time push via SSE\n    if (channels.push) {\n        broadcastToUser(userId, notification ?? { type, title, message, actionUrl, createdAt: new Date() })\n    }\n\n    // 3. Email\n    if (channels.email) {\n        // Fire-and-forget (don't block the response)\n        sendNotificationEmail(userId, type, title, message, actionUrl).catch((e) =>\n            console.error('[notify] Email send error:', e)\n        )\n    }\n\n    return notification\n}\n\n/**\n * Send a notification to multiple users at once.\n */\nexport async function notifyMany(params: NotifyManyParams) {\n    const { userIds, type, title, message, data, actionUrl, force = false } = params\n\n    const results = await Promise.allSettled(\n        userIds.map((userId) =>\n            notify({ userId, type, title, message, data, actionUrl, force })\n        )\n    )\n\n    const succeeded = results.filter((r) => r.status === 'fulfilled').length\n    const failed = results.filter((r) => r.status === 'rejected').length\n\n    return { sent: succeeded, failed, total: userIds.length }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/api/notifications/stream/route.ts"],"sourcesContent":["/**\n * SSE (Server-Sent Events) endpoint for real-time notifications.\n *\n * GET /api/notifications/stream\n *\n * The client opens a persistent connection and receives events as:\n *   event: notification\n *   data: { ...notification }\n *\n * Also sends a heartbeat ping every 30s to keep the connection alive.\n */\n\nimport { NextRequest } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport { addSSEListener } from '@/lib/notifications/notify'\n\nexport const dynamic = 'force-dynamic'\n\nexport async function GET(req: NextRequest) {\n    const session = await getServerSession(authOptions)\n    if (!session?.user) {\n        return new Response('Unauthorized', { status: 401 })\n    }\n\n    const userId = session.user.id\n\n    const encoder = new TextEncoder()\n    let cleanup: (() => void) | null = null\n    let heartbeatInterval: ReturnType<typeof setInterval> | null = null\n\n    const stream = new ReadableStream({\n        start(controller) {\n            // Send initial connection event\n            controller.enqueue(\n                encoder.encode(`event: connected\\ndata: ${JSON.stringify({ userId })}\\n\\n`)\n            )\n\n            // Register SSE listener for this user\n            cleanup = addSSEListener(userId, (notification) => {\n                try {\n                    const data = JSON.stringify(notification)\n                    controller.enqueue(\n                        encoder.encode(`event: notification\\ndata: ${data}\\n\\n`)\n                    )\n                } catch {\n                    // Stream may be closed\n                }\n            })\n\n            // Heartbeat every 30 seconds\n            heartbeatInterval = setInterval(() => {\n                try {\n                    controller.enqueue(encoder.encode(`:ping\\n\\n`))\n                } catch {\n                    // Stream closed\n                    if (heartbeatInterval) clearInterval(heartbeatInterval)\n                    if (cleanup) cleanup()\n                }\n            }, 30_000)\n        },\n        cancel() {\n            if (heartbeatInterval) clearInterval(heartbeatInterval)\n            if (cleanup) cleanup()\n        },\n    })\n\n    return new Response(stream, {\n        headers: {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            Connection: 'keep-alive',\n            'X-Accel-Buffering': 'no', // Disable Nginx buffering\n        },\n    })\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC;;;;;;AAGD;AACA;AACA;;;;AAEO,MAAM,UAAU;AAEhB,eAAe,IAAI,GAAgB;IACtC,MAAM,UAAU,MAAM,IAAA,6MAAgB,EAAC,qLAAW;IAClD,IAAI,CAAC,SAAS,MAAM;QAChB,OAAO,IAAI,SAAS,gBAAgB;YAAE,QAAQ;QAAI;IACtD;IAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;IAE9B,MAAM,UAAU,IAAI;IACpB,IAAI,UAA+B;IACnC,IAAI,oBAA2D;IAE/D,MAAM,SAAS,IAAI,eAAe;QAC9B,OAAM,UAAU;YACZ,gCAAgC;YAChC,WAAW,OAAO,CACd,QAAQ,MAAM,CAAC,CAAC,wBAAwB,EAAE,KAAK,SAAS,CAAC;gBAAE;YAAO,GAAG,IAAI,CAAC;YAG9E,sCAAsC;YACtC,UAAU,IAAA,2MAAc,EAAC,QAAQ,CAAC;gBAC9B,IAAI;oBACA,MAAM,OAAO,KAAK,SAAS,CAAC;oBAC5B,WAAW,OAAO,CACd,QAAQ,MAAM,CAAC,CAAC,2BAA2B,EAAE,KAAK,IAAI,CAAC;gBAE/D,EAAE,OAAM;gBACJ,uBAAuB;gBAC3B;YACJ;YAEA,6BAA6B;YAC7B,oBAAoB,YAAY;gBAC5B,IAAI;oBACA,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC,SAAS,CAAC;gBACjD,EAAE,OAAM;oBACJ,gBAAgB;oBAChB,IAAI,mBAAmB,cAAc;oBACrC,IAAI,SAAS;gBACjB;YACJ,GAAG;QACP;QACA;YACI,IAAI,mBAAmB,cAAc;YACrC,IAAI,SAAS;QACjB;IACJ;IAEA,OAAO,IAAI,SAAS,QAAQ;QACxB,SAAS;YACL,gBAAgB;YAChB,iBAAiB;YACjB,YAAY;YACZ,qBAAqB;QACzB;IACJ;AACJ"}}]
}