{
  "version": 3,
  "sources": [],
  "debugId": "b34d02cb-1b04-db84-108a-ad78eab250af",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/actions/library.ts"],"sourcesContent":["/**\n * Library Actions\n * Server actions for managing tutor's task library\n */\n\n'use server';\n\nimport { drizzleDb } from '@/lib/db/drizzle';\nimport { libraryTask } from '@/lib/db/schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { revalidatePath } from 'next/cache';\n\nexport interface LibraryTask {\n  id: string;\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n  isFavorite: boolean;\n  usageCount: number;\n  lastUsedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateLibraryTaskInput {\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n}\n\n/**\n * Get all library tasks for a user\n */\nexport async function getLibraryTasks(userId: string): Promise<LibraryTask[]> {\n  try {\n    const tasks = await drizzleDb\n      .select()\n      .from(libraryTask)\n      .where(eq(libraryTask.userId, userId))\n      .orderBy(desc(libraryTask.createdAt));\n    return tasks.map((task) => ({\n      ...task,\n      correctAnswer: task.correctAnswer ?? undefined,\n      explanation: task.explanation ?? undefined,\n      lastUsedAt: task.lastUsedAt ?? undefined,\n      type: task.type as 'multiple_choice' | 'short_answer',\n      topics: (task.topics as string[]) ?? [],\n      options: task.options as string[] | undefined\n    }));\n  } catch (error) {\n    console.error('Failed to get library tasks:', error);\n    return [];\n  }\n}\n\n/**\n * Save a new task to the library\n */\nexport async function saveLibraryTask(\n  userId: string,\n  input: CreateLibraryTaskInput\n): Promise<LibraryTask | null> {\n  try {\n    const id = crypto.randomUUID();\n    await drizzleDb.insert(libraryTask).values({\n      id,\n      userId,\n      question: input.question,\n      type: input.type,\n      options: input.options ?? [],\n      correctAnswer: input.correctAnswer ?? null,\n      explanation: input.explanation ?? null,\n      difficulty: input.difficulty,\n      subject: input.subject,\n      topics: input.topics,\n      isFavorite: false,\n      usageCount: 0\n    });\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, id));\n    revalidatePath('/tutor/library');\n    return task\n      ? {\n          ...task,\n          correctAnswer: task.correctAnswer ?? undefined,\n          explanation: task.explanation ?? undefined,\n          lastUsedAt: task.lastUsedAt ?? undefined,\n          type: task.type as 'multiple_choice' | 'short_answer',\n          topics: (task.topics as string[]) ?? [],\n          options: task.options as string[] | undefined\n        }\n      : null;\n  } catch (error) {\n    console.error('Failed to save library task:', error);\n    return null;\n  }\n}\n\n/**\n * Toggle favorite status of a task\n */\nexport async function toggleFavoriteTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ isFavorite: !task.isFavorite })\n      .where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to toggle favorite:', error);\n    return false;\n  }\n}\n\n/**\n * Delete a task from the library\n */\nexport async function deleteLibraryTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb.delete(libraryTask).where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to delete library task:', error);\n    return false;\n  }\n}\n\n/**\n * Increment usage count when a task is used\n */\nexport async function incrementTaskUsage(taskId: string): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ usageCount: task.usageCount + 1, lastUsedAt: new Date() })\n      .where(eq(libraryTask.id, taskId));\n    return true;\n  } catch (error) {\n    console.error('Failed to increment task usage:', error);\n    return false;\n  }\n}\n\n/**\n * Migrate legacy tasks (placeholder for future migration logic)\n */\nexport async function migrateLegacyTasks(userId: string): Promise<number> {\n  try {\n    // Placeholder for future migration logic\n    // This would migrate tasks from an old format or storage\n    console.log('Migrating legacy tasks for user:', userId);\n    return 0;\n  } catch (error) {\n    console.error('Failed to migrate legacy tasks:', error);\n    return 0;\n  }\n}\n"],"names":[],"mappings":";;;;;;;MAoEsB,wBAAA,WAAA,GAAA,IAAA,iSAAA,EAAA,8CAAA,sRAAA,EAAA,KAAA,GAAA,4RAAA,EAAA,mDAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/actions/library.ts"],"sourcesContent":["/**\n * Library Actions\n * Server actions for managing tutor's task library\n */\n\n'use server';\n\nimport { drizzleDb } from '@/lib/db/drizzle';\nimport { libraryTask } from '@/lib/db/schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { revalidatePath } from 'next/cache';\n\nexport interface LibraryTask {\n  id: string;\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n  isFavorite: boolean;\n  usageCount: number;\n  lastUsedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateLibraryTaskInput {\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n}\n\n/**\n * Get all library tasks for a user\n */\nexport async function getLibraryTasks(userId: string): Promise<LibraryTask[]> {\n  try {\n    const tasks = await drizzleDb\n      .select()\n      .from(libraryTask)\n      .where(eq(libraryTask.userId, userId))\n      .orderBy(desc(libraryTask.createdAt));\n    return tasks.map((task) => ({\n      ...task,\n      correctAnswer: task.correctAnswer ?? undefined,\n      explanation: task.explanation ?? undefined,\n      lastUsedAt: task.lastUsedAt ?? undefined,\n      type: task.type as 'multiple_choice' | 'short_answer',\n      topics: (task.topics as string[]) ?? [],\n      options: task.options as string[] | undefined\n    }));\n  } catch (error) {\n    console.error('Failed to get library tasks:', error);\n    return [];\n  }\n}\n\n/**\n * Save a new task to the library\n */\nexport async function saveLibraryTask(\n  userId: string,\n  input: CreateLibraryTaskInput\n): Promise<LibraryTask | null> {\n  try {\n    const id = crypto.randomUUID();\n    await drizzleDb.insert(libraryTask).values({\n      id,\n      userId,\n      question: input.question,\n      type: input.type,\n      options: input.options ?? [],\n      correctAnswer: input.correctAnswer ?? null,\n      explanation: input.explanation ?? null,\n      difficulty: input.difficulty,\n      subject: input.subject,\n      topics: input.topics,\n      isFavorite: false,\n      usageCount: 0\n    });\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, id));\n    revalidatePath('/tutor/library');\n    return task\n      ? {\n          ...task,\n          correctAnswer: task.correctAnswer ?? undefined,\n          explanation: task.explanation ?? undefined,\n          lastUsedAt: task.lastUsedAt ?? undefined,\n          type: task.type as 'multiple_choice' | 'short_answer',\n          topics: (task.topics as string[]) ?? [],\n          options: task.options as string[] | undefined\n        }\n      : null;\n  } catch (error) {\n    console.error('Failed to save library task:', error);\n    return null;\n  }\n}\n\n/**\n * Toggle favorite status of a task\n */\nexport async function toggleFavoriteTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ isFavorite: !task.isFavorite })\n      .where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to toggle favorite:', error);\n    return false;\n  }\n}\n\n/**\n * Delete a task from the library\n */\nexport async function deleteLibraryTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb.delete(libraryTask).where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to delete library task:', error);\n    return false;\n  }\n}\n\n/**\n * Increment usage count when a task is used\n */\nexport async function incrementTaskUsage(taskId: string): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ usageCount: task.usageCount + 1, lastUsedAt: new Date() })\n      .where(eq(libraryTask.id, taskId));\n    return true;\n  } catch (error) {\n    console.error('Failed to increment task usage:', error);\n    return false;\n  }\n}\n\n/**\n * Migrate legacy tasks (placeholder for future migration logic)\n */\nexport async function migrateLegacyTasks(userId: string): Promise<number> {\n  try {\n    // Placeholder for future migration logic\n    // This would migrate tasks from an old format or storage\n    console.log('Migrating legacy tasks for user:', userId);\n    return 0;\n  } catch (error) {\n    console.error('Failed to migrate legacy tasks:', error);\n    return 0;\n  }\n}\n"],"names":[],"mappings":";;;;;;;MA8GsB,wBAAA,WAAA,GAAA,IAAA,iSAAA,EAAA,8CAAA,sRAAA,EAAA,KAAA,GAAA,4RAAA,EAAA,sDAAA"}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/actions/library.ts"],"sourcesContent":["/**\n * Library Actions\n * Server actions for managing tutor's task library\n */\n\n'use server';\n\nimport { drizzleDb } from '@/lib/db/drizzle';\nimport { libraryTask } from '@/lib/db/schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { revalidatePath } from 'next/cache';\n\nexport interface LibraryTask {\n  id: string;\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n  isFavorite: boolean;\n  usageCount: number;\n  lastUsedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateLibraryTaskInput {\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n}\n\n/**\n * Get all library tasks for a user\n */\nexport async function getLibraryTasks(userId: string): Promise<LibraryTask[]> {\n  try {\n    const tasks = await drizzleDb\n      .select()\n      .from(libraryTask)\n      .where(eq(libraryTask.userId, userId))\n      .orderBy(desc(libraryTask.createdAt));\n    return tasks.map((task) => ({\n      ...task,\n      correctAnswer: task.correctAnswer ?? undefined,\n      explanation: task.explanation ?? undefined,\n      lastUsedAt: task.lastUsedAt ?? undefined,\n      type: task.type as 'multiple_choice' | 'short_answer',\n      topics: (task.topics as string[]) ?? [],\n      options: task.options as string[] | undefined\n    }));\n  } catch (error) {\n    console.error('Failed to get library tasks:', error);\n    return [];\n  }\n}\n\n/**\n * Save a new task to the library\n */\nexport async function saveLibraryTask(\n  userId: string,\n  input: CreateLibraryTaskInput\n): Promise<LibraryTask | null> {\n  try {\n    const id = crypto.randomUUID();\n    await drizzleDb.insert(libraryTask).values({\n      id,\n      userId,\n      question: input.question,\n      type: input.type,\n      options: input.options ?? [],\n      correctAnswer: input.correctAnswer ?? null,\n      explanation: input.explanation ?? null,\n      difficulty: input.difficulty,\n      subject: input.subject,\n      topics: input.topics,\n      isFavorite: false,\n      usageCount: 0\n    });\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, id));\n    revalidatePath('/tutor/library');\n    return task\n      ? {\n          ...task,\n          correctAnswer: task.correctAnswer ?? undefined,\n          explanation: task.explanation ?? undefined,\n          lastUsedAt: task.lastUsedAt ?? undefined,\n          type: task.type as 'multiple_choice' | 'short_answer',\n          topics: (task.topics as string[]) ?? [],\n          options: task.options as string[] | undefined\n        }\n      : null;\n  } catch (error) {\n    console.error('Failed to save library task:', error);\n    return null;\n  }\n}\n\n/**\n * Toggle favorite status of a task\n */\nexport async function toggleFavoriteTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ isFavorite: !task.isFavorite })\n      .where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to toggle favorite:', error);\n    return false;\n  }\n}\n\n/**\n * Delete a task from the library\n */\nexport async function deleteLibraryTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb.delete(libraryTask).where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to delete library task:', error);\n    return false;\n  }\n}\n\n/**\n * Increment usage count when a task is used\n */\nexport async function incrementTaskUsage(taskId: string): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ usageCount: task.usageCount + 1, lastUsedAt: new Date() })\n      .where(eq(libraryTask.id, taskId));\n    return true;\n  } catch (error) {\n    console.error('Failed to increment task usage:', error);\n    return false;\n  }\n}\n\n/**\n * Migrate legacy tasks (placeholder for future migration logic)\n */\nexport async function migrateLegacyTasks(userId: string): Promise<number> {\n  try {\n    // Placeholder for future migration logic\n    // This would migrate tasks from an old format or storage\n    console.log('Migrating legacy tasks for user:', userId);\n    return 0;\n  } catch (error) {\n    console.error('Failed to migrate legacy tasks:', error);\n    return 0;\n  }\n}\n"],"names":[],"mappings":";;;;;;;MAoIsB,wBAAA,WAAA,GAAA,IAAA,iSAAA,EAAA,8CAAA,sRAAA,EAAA,KAAA,GAAA,4RAAA,EAAA,qDAAA"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/actions/library.ts"],"sourcesContent":["/**\n * Library Actions\n * Server actions for managing tutor's task library\n */\n\n'use server';\n\nimport { drizzleDb } from '@/lib/db/drizzle';\nimport { libraryTask } from '@/lib/db/schema';\nimport { eq, desc } from 'drizzle-orm';\nimport { revalidatePath } from 'next/cache';\n\nexport interface LibraryTask {\n  id: string;\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n  isFavorite: boolean;\n  usageCount: number;\n  lastUsedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateLibraryTaskInput {\n  question: string;\n  type: 'multiple_choice' | 'short_answer';\n  options?: string[];\n  correctAnswer?: string;\n  explanation?: string;\n  difficulty: string;\n  subject: string;\n  topics: string[];\n}\n\n/**\n * Get all library tasks for a user\n */\nexport async function getLibraryTasks(userId: string): Promise<LibraryTask[]> {\n  try {\n    const tasks = await drizzleDb\n      .select()\n      .from(libraryTask)\n      .where(eq(libraryTask.userId, userId))\n      .orderBy(desc(libraryTask.createdAt));\n    return tasks.map((task) => ({\n      ...task,\n      correctAnswer: task.correctAnswer ?? undefined,\n      explanation: task.explanation ?? undefined,\n      lastUsedAt: task.lastUsedAt ?? undefined,\n      type: task.type as 'multiple_choice' | 'short_answer',\n      topics: (task.topics as string[]) ?? [],\n      options: task.options as string[] | undefined\n    }));\n  } catch (error) {\n    console.error('Failed to get library tasks:', error);\n    return [];\n  }\n}\n\n/**\n * Save a new task to the library\n */\nexport async function saveLibraryTask(\n  userId: string,\n  input: CreateLibraryTaskInput\n): Promise<LibraryTask | null> {\n  try {\n    const id = crypto.randomUUID();\n    await drizzleDb.insert(libraryTask).values({\n      id,\n      userId,\n      question: input.question,\n      type: input.type,\n      options: input.options ?? [],\n      correctAnswer: input.correctAnswer ?? null,\n      explanation: input.explanation ?? null,\n      difficulty: input.difficulty,\n      subject: input.subject,\n      topics: input.topics,\n      isFavorite: false,\n      usageCount: 0\n    });\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, id));\n    revalidatePath('/tutor/library');\n    return task\n      ? {\n          ...task,\n          correctAnswer: task.correctAnswer ?? undefined,\n          explanation: task.explanation ?? undefined,\n          lastUsedAt: task.lastUsedAt ?? undefined,\n          type: task.type as 'multiple_choice' | 'short_answer',\n          topics: (task.topics as string[]) ?? [],\n          options: task.options as string[] | undefined\n        }\n      : null;\n  } catch (error) {\n    console.error('Failed to save library task:', error);\n    return null;\n  }\n}\n\n/**\n * Toggle favorite status of a task\n */\nexport async function toggleFavoriteTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ isFavorite: !task.isFavorite })\n      .where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to toggle favorite:', error);\n    return false;\n  }\n}\n\n/**\n * Delete a task from the library\n */\nexport async function deleteLibraryTask(\n  taskId: string,\n  userId: string\n): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task || task.userId !== userId) return false;\n    await drizzleDb.delete(libraryTask).where(eq(libraryTask.id, taskId));\n    revalidatePath('/tutor/library');\n    return true;\n  } catch (error) {\n    console.error('Failed to delete library task:', error);\n    return false;\n  }\n}\n\n/**\n * Increment usage count when a task is used\n */\nexport async function incrementTaskUsage(taskId: string): Promise<boolean> {\n  try {\n    const [task] = await drizzleDb.select().from(libraryTask).where(eq(libraryTask.id, taskId)).limit(1);\n    if (!task) return false;\n    await drizzleDb\n      .update(libraryTask)\n      .set({ usageCount: task.usageCount + 1, lastUsedAt: new Date() })\n      .where(eq(libraryTask.id, taskId));\n    return true;\n  } catch (error) {\n    console.error('Failed to increment task usage:', error);\n    return false;\n  }\n}\n\n/**\n * Migrate legacy tasks (placeholder for future migration logic)\n */\nexport async function migrateLegacyTasks(userId: string): Promise<number> {\n  try {\n    // Placeholder for future migration logic\n    // This would migrate tasks from an old format or storage\n    console.log('Migrating legacy tasks for user:', userId);\n    return 0;\n  } catch (error) {\n    console.error('Failed to migrate legacy tasks:', error);\n    return 0;\n  }\n}\n"],"names":[],"mappings":";;;;;;;MAuJsB,wBAAA,WAAA,GAAA,IAAA,iSAAA,EAAA,8CAAA,sRAAA,EAAA,KAAA,GAAA,4RAAA,EAAA,sDAAA"}}]
}