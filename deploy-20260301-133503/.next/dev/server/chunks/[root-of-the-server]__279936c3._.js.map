{
  "version": 3,
  "sources": [],
  "debugId": "0b02627f-018c-5fa6-83fb-b3c9f1c8adcd",
  "sections": [
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/db/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-require-imports */\n\n/**\n * Database Client with Connection Pooling\n * \n * Features:\n * - Connection pooling for high concurrency (100+ users)\n * - Query caching with Redis\n * - Read replica support for scaling\n * - N+1 query prevention with dataloaders\n * \n * Note: Redis is lazily initialized to avoid bundling issues\n */\n\n// Connection pool configuration\nconst POOL_CONFIG = {\n  // Connection pool settings for 100+ concurrent users\n  min: 5,                    // Minimum connections\n  max: 50,                   // Maximum connections (supports 100+ concurrent users)\n  idleTimeoutMillis: 30000,  // Close idle connections after 30s\n  connectionTimeoutMillis: 5000, // Connection timeout\n  allowExitOnIdle: false,    // Keep pool alive\n}\n\n// Query cache configuration\nconst CACHE_CONFIG = {\n  ttl: 60,                   // Default cache TTL in seconds\n  staleWhileRevalidate: 30,  // Serve stale data while refreshing\n  prefix: 'tutorme:query:',  // Cache key prefix\n}\n\nlet db: any\nlet redis: any | null = null\nlet queryCache: Map<string, { data: any; expires: number }> | null = null\nlet redisInitialized = false\n\n// Safe check for server-side environment (not Edge Runtime)\n// Edge Runtime (used by Next.js middleware) doesn't support Prisma Client\nconst isEdgeRuntime = typeof (globalThis as any).EdgeRuntime !== 'undefined' || \n  (typeof process !== 'undefined' && process.env.NEXT_RUNTIME === 'edge')\nconst isServer = typeof window === 'undefined' && !isEdgeRuntime\n\n// Initialize in-memory cache only on server\nfunction getQueryCache() {\n  if (!isServer) return null\n  if (!queryCache) {\n    queryCache = new Map()\n  }\n  return queryCache\n}\n\n// Initialize Redis client if available (server-side only)\nasync function initRedis() {\n  if (!isServer) return null\n  if (redisInitialized) return redis\n  \n  try {\n    const redisUrl = process.env.REDIS_URL\n    if (!redisUrl) {\n      console.log('[DB] Redis URL not configured, using in-memory cache')\n      redisInitialized = true\n      return null\n    }\n    \n    // Dynamic import to avoid bundling issues\n    const { Redis } = await import('ioredis')\n    redis = new Redis(redisUrl, {\n      retryStrategy: (times) => Math.min(times * 50, 2000),\n      maxRetriesPerRequest: 3,\n    })\n    \n    redis.on('error', (err: any) => {\n      console.error('[Redis] Connection error:', err)\n      redis = null\n    })\n    \n    console.log('[DB] Redis cache initialized')\n    redisInitialized = true\n    return redis\n  } catch (e) {\n    console.warn('[DB] Failed to initialize Redis, using in-memory cache')\n    redisInitialized = true\n    return null\n  }\n}\n\n// Initialize Prisma Client with connection pooling (server-side only)\nif (isServer) {\n  try {\n    const { PrismaClient } = require('@prisma/client')\n    \n    const globalForPrisma = globalThis as unknown as {\n      prisma: typeof PrismaClient | undefined\n      redis: any | null\n      redisInitialized: boolean\n    }\n    \n    // Initialize Redis on first use (lazy initialization)\n    if (globalForPrisma.redisInitialized) {\n      redis = globalForPrisma.redis\n      redisInitialized = true\n    }\n    \n    if (process.env.NODE_ENV !== 'production') {\n      globalForPrisma.redis = redis\n      globalForPrisma.redisInitialized = redisInitialized\n    }\n    \n    // Initialize Prisma with connection pooling\n    if (globalForPrisma.prisma) {\n      db = globalForPrisma.prisma\n    } else {\n      db = new PrismaClient({\n        log: process.env.NODE_ENV === 'development' \n          ? ['query', 'error', 'warn'] \n          : ['error'],\n        \n        // Connection pooling configuration\n        datasources: {\n          db: {\n            url: process.env.DATABASE_URL,\n          },\n        },\n      })\n      \n      // Add connection pool monitoring\n      db.$on('query', (e: any) => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Prisma Query]', e.query, `${e.duration}ms`)\n        }\n      })\n      \n      if (process.env.NODE_ENV !== 'production') {\n        globalForPrisma.prisma = db\n      }\n    }\n    \n    console.log('[DB] Prisma Client initialized with connection pooling')\n  } catch (e) {\n    console.error('[DB] Failed to initialize Prisma:', e)\n    // Fallback for build time\n    db = {\n      $connect: async () => {},\n      $disconnect: async () => {},\n    }\n  }\n} else {\n  // Client-side mock\n  db = {\n    $connect: async () => {},\n    $disconnect: async () => {},\n  }\n}\n\n/**\n * Cache utilities\n */\nexport const cache = {\n  /**\n   * Ensure Redis is initialized\n   */\n  async ensureRedis() {\n    if (!isServer) return null\n    if (!redisInitialized) {\n      await initRedis()\n    }\n    return redis\n  },\n\n  /**\n   * Get cached value\n   */\n  async get<T>(key: string): Promise<T | null> {\n    if (!isServer) return null\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const value = await client.get(fullKey)\n        if (value) return JSON.parse(value)\n      } catch (e) {\n        console.error('[Cache] Redis get error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (!cache) return null\n    \n    const cached = cache.get(fullKey)\n    if (cached && cached.expires > Date.now()) {\n      return cached.data\n    }\n    \n    cache.delete(fullKey)\n    return null\n  },\n  \n  /**\n   * Set cached value\n   */\n  async set<T>(key: string, value: T, ttlSeconds = CACHE_CONFIG.ttl): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    // Try Redis first\n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.setex(fullKey, ttlSeconds, JSON.stringify(value))\n        return\n      } catch (e) {\n        console.error('[Cache] Redis set error:', e)\n      }\n    }\n    \n    // Fallback to in-memory cache\n    const cache = getQueryCache()\n    if (cache) {\n      cache.set(fullKey, {\n        data: value,\n        expires: Date.now() + ttlSeconds * 1000\n      })\n    }\n  },\n  \n  /**\n   * Delete cached value\n   */\n  async delete(key: string): Promise<void> {\n    if (!isServer) return\n    \n    const fullKey = CACHE_CONFIG.prefix + key\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        await client.del(fullKey)\n      } catch (e) {\n        console.error('[Cache] Redis del error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.delete(fullKey)\n  },\n  \n  /**\n   * Clear all cached values\n   */\n  async clear(): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + '*')\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Redis clear error:', e)\n      }\n    }\n    \n    const cache = getQueryCache()\n    if (cache) cache.clear()\n  },\n  \n  /**\n   * Get or set cached value\n   */\n  async getOrSet<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    const cached = await this.get<T>(key)\n    if (cached !== null) return cached\n    \n    const value = await factory()\n    await this.set(key, value, ttlSeconds)\n    return value\n  },\n\n  /**\n   * Invalidate cache for a pattern\n   */\n  async invalidatePattern(pattern: string): Promise<void> {\n    if (!isServer) return\n    \n    const client = await this.ensureRedis()\n    if (client) {\n      try {\n        const keys = await client.keys(CACHE_CONFIG.prefix + pattern)\n        if (keys.length > 0) {\n          await client.del(...keys)\n        }\n      } catch (e) {\n        console.error('[Cache] Pattern invalidation error:', e)\n      }\n    }\n    \n    // Clear in-memory cache matching pattern\n    const cache = getQueryCache()\n    if (cache) {\n      const regex = new RegExp(CACHE_CONFIG.prefix + pattern.replace('*', '.*'))\n      for (const key of cache.keys()) {\n        if (regex.test(key)) cache.delete(key)\n      }\n    }\n  }\n}\n\n/**\n * Query optimization utilities\n */\nexport const queryOptimizer = {\n  /**\n   * Batch load function for N+1 prevention\n   */\n  async batchLoad<T>(\n    ids: string[],\n    fetchFn: (ids: string[]) => Promise<T[]>,\n    getId: (item: T) => string\n  ): Promise<(T | null)[]> {\n    if (!isServer) return ids.map(() => null)\n    if (ids.length === 0) return []\n    \n    // Deduplicate IDs\n    const uniqueIds = [...new Set(ids)]\n    \n    // Fetch all items in one query\n    const items = await fetchFn(uniqueIds)\n    \n    // Create lookup map\n    const itemMap = new Map(items.map(item => [getId(item), item]))\n    \n    // Return items in original order\n    return ids.map(id => itemMap.get(id) || null)\n  },\n  \n  /**\n   * Wrap a query with caching\n   */\n  async cachedQuery<T>(\n    cacheKey: string,\n    queryFn: () => Promise<T>,\n    ttlSeconds = CACHE_CONFIG.ttl\n  ): Promise<T> {\n    return cache.getOrSet(cacheKey, queryFn, ttlSeconds)\n  }\n}\n\n/**\n * Read replica support (for future scaling)\n */\nexport const readReplica = {\n  /**\n   * Check if read replicas are configured\n   */\n  isConfigured(): boolean {\n    return isServer && !!process.env.DATABASE_READ_REPLICA_URL\n  },\n  \n  /**\n   * Get read-only database client\n   * Falls back to primary if replicas not configured\n   */\n  getClient() {\n    // For now, return the same client\n    // In production, this would return a connection to the read replica\n    return db\n  }\n}\n\nexport { db }\n/** Alias for code that imports prisma from @/lib/db */\nexport const prisma = db\n\n// Re-export Prisma types (will be empty on client)\nexport * from '@prisma/client'\n"],"names":[],"mappings":";;;;;;;;;;;;AAiYA,mDAAmD;AACnD;AAlYA,qDAAqD,GACrD,wDAAwD,GAExD;;;;;;;;;;CAUC,GAED,gCAAgC;AAChC,MAAM,cAAc;IAClB,qDAAqD;IACrD,KAAK;IACL,KAAK;IACL,mBAAmB;IACnB,yBAAyB;IACzB,iBAAiB;AACnB;AAEA,4BAA4B;AAC5B,MAAM,eAAe;IACnB,KAAK;IACL,sBAAsB;IACtB,QAAQ;AACV;AAEA,IAAI;AACJ,IAAI,QAAoB;AACxB,IAAI,aAAiE;AACrE,IAAI,mBAAmB;AAEvB,4DAA4D;AAC5D,0EAA0E;AAC1E,MAAM,gBAAgB,OAAO,AAAC,WAAmB,WAAW,KAAK,eAC9D,OAAO,YAAY,eAAe,+CAA6B;AAClE,MAAM,WAAW,kDAAkB,eAAe,CAAC;AAEnD,4CAA4C;AAC5C,SAAS;IACP,IAAI,CAAC,UAAU,OAAO;IACtB,IAAI,CAAC,YAAY;QACf,aAAa,IAAI;IACnB;IACA,OAAO;AACT;AAEA,0DAA0D;AAC1D,eAAe;IACb,IAAI,CAAC,UAAU,OAAO;IACtB,IAAI,kBAAkB,OAAO;IAE7B,IAAI;QACF,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS;QACtC,IAAI,CAAC,UAAU;YACb,QAAQ,GAAG,CAAC;YACZ,mBAAmB;YACnB,OAAO;QACT;QAEA,0CAA0C;QAC1C,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,QAAQ,IAAI,MAAM,UAAU;YAC1B,eAAe,CAAC,QAAU,KAAK,GAAG,CAAC,QAAQ,IAAI;YAC/C,sBAAsB;QACxB;QAEA,MAAM,EAAE,CAAC,SAAS,CAAC;YACjB,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,QAAQ;QACV;QAEA,QAAQ,GAAG,CAAC;QACZ,mBAAmB;QACnB,OAAO;IACT,EAAE,OAAO,GAAG;QACV,QAAQ,IAAI,CAAC;QACb,mBAAmB;QACnB,OAAO;IACT;AACF;AAEA,sEAAsE;AACtE,IAAI,UAAU;IACZ,IAAI;QACF,MAAM,EAAE,YAAY,EAAE;QAEtB,MAAM,kBAAkB;QAMxB,sDAAsD;QACtD,IAAI,gBAAgB,gBAAgB,EAAE;YACpC,QAAQ,gBAAgB,KAAK;YAC7B,mBAAmB;QACrB;QAEA,wCAA2C;YACzC,gBAAgB,KAAK,GAAG;YACxB,gBAAgB,gBAAgB,GAAG;QACrC;QAEA,4CAA4C;QAC5C,IAAI,gBAAgB,MAAM,EAAE;YAC1B,KAAK,gBAAgB,MAAM;QAC7B,OAAO;YACL,KAAK,IAAI,aAAa;gBACpB,KAAK,uCACD;oBAAC;oBAAS;oBAAS;iBAAO,GAC1B;gBAEJ,mCAAmC;gBACnC,aAAa;oBACX,IAAI;wBACF,KAAK,QAAQ,GAAG,CAAC,YAAY;oBAC/B;gBACF;YACF;YAEA,iCAAiC;YACjC,GAAG,GAAG,CAAC,SAAS,CAAC;gBACf,wCAA4C;oBAC1C,QAAQ,GAAG,CAAC,kBAAkB,EAAE,KAAK,EAAE,GAAG,EAAE,QAAQ,CAAC,EAAE,CAAC;gBAC1D;YACF;YAEA,wCAA2C;gBACzC,gBAAgB,MAAM,GAAG;YAC3B;QACF;QAEA,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,qCAAqC;QACnD,0BAA0B;QAC1B,KAAK;YACH,UAAU,WAAa;YACvB,aAAa,WAAa;QAC5B;IACF;AACF,OAAO;IACL,mBAAmB;IACnB,KAAK;QACH,UAAU,WAAa;QACvB,aAAa,WAAa;IAC5B;AACF;AAKO,MAAM,QAAQ;IACnB;;GAEC,GACD,MAAM;QACJ,IAAI,CAAC,UAAU,OAAO;QACtB,IAAI,CAAC,kBAAkB;YACrB,MAAM;QACR;QACA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,KAAO,GAAW;QACtB,IAAI,CAAC,UAAU,OAAO;QAEtB,MAAM,UAAU,aAAa,MAAM,GAAG;QAEtC,kBAAkB;QAClB,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW;QACrC,IAAI,QAAQ;YACV,IAAI;gBACF,MAAM,QAAQ,MAAM,OAAO,GAAG,CAAC;gBAC/B,IAAI,OAAO,OAAO,KAAK,KAAK,CAAC;YAC/B,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,4BAA4B;YAC5C;QACF;QAEA,8BAA8B;QAC9B,MAAM,QAAQ;QACd,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,SAAS,MAAM,GAAG,CAAC;QACzB,IAAI,UAAU,OAAO,OAAO,GAAG,KAAK,GAAG,IAAI;YACzC,OAAO,OAAO,IAAI;QACpB;QAEA,MAAM,MAAM,CAAC;QACb,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,KAAO,GAAW,EAAE,KAAQ,EAAE,aAAa,aAAa,GAAG;QAC/D,IAAI,CAAC,UAAU;QAEf,MAAM,UAAU,aAAa,MAAM,GAAG;QAEtC,kBAAkB;QAClB,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW;QACrC,IAAI,QAAQ;YACV,IAAI;gBACF,MAAM,OAAO,KAAK,CAAC,SAAS,YAAY,KAAK,SAAS,CAAC;gBACvD;YACF,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,4BAA4B;YAC5C;QACF;QAEA,8BAA8B;QAC9B,MAAM,QAAQ;QACd,IAAI,OAAO;YACT,MAAM,GAAG,CAAC,SAAS;gBACjB,MAAM;gBACN,SAAS,KAAK,GAAG,KAAK,aAAa;YACrC;QACF;IACF;IAEA;;GAEC,GACD,MAAM,QAAO,GAAW;QACtB,IAAI,CAAC,UAAU;QAEf,MAAM,UAAU,aAAa,MAAM,GAAG;QAEtC,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW;QACrC,IAAI,QAAQ;YACV,IAAI;gBACF,MAAM,OAAO,GAAG,CAAC;YACnB,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,4BAA4B;YAC5C;QACF;QAEA,MAAM,QAAQ;QACd,IAAI,OAAO,MAAM,MAAM,CAAC;IAC1B;IAEA;;GAEC,GACD,MAAM;QACJ,IAAI,CAAC,UAAU;QAEf,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW;QACrC,IAAI,QAAQ;YACV,IAAI;gBACF,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,aAAa,MAAM,GAAG;gBACrD,IAAI,KAAK,MAAM,GAAG,GAAG;oBACnB,MAAM,OAAO,GAAG,IAAI;gBACtB;YACF,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,8BAA8B;YAC9C;QACF;QAEA,MAAM,QAAQ;QACd,IAAI,OAAO,MAAM,KAAK;IACxB;IAEA;;GAEC,GACD,MAAM,UACJ,GAAW,EACX,OAAyB,EACzB,aAAa,aAAa,GAAG;QAE7B,MAAM,SAAS,MAAM,IAAI,CAAC,GAAG,CAAI;QACjC,IAAI,WAAW,MAAM,OAAO;QAE5B,MAAM,QAAQ,MAAM;QACpB,MAAM,IAAI,CAAC,GAAG,CAAC,KAAK,OAAO;QAC3B,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,mBAAkB,OAAe;QACrC,IAAI,CAAC,UAAU;QAEf,MAAM,SAAS,MAAM,IAAI,CAAC,WAAW;QACrC,IAAI,QAAQ;YACV,IAAI;gBACF,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,aAAa,MAAM,GAAG;gBACrD,IAAI,KAAK,MAAM,GAAG,GAAG;oBACnB,MAAM,OAAO,GAAG,IAAI;gBACtB;YACF,EAAE,OAAO,GAAG;gBACV,QAAQ,KAAK,CAAC,uCAAuC;YACvD;QACF;QAEA,yCAAyC;QACzC,MAAM,QAAQ;QACd,IAAI,OAAO;YACT,MAAM,QAAQ,IAAI,OAAO,aAAa,MAAM,GAAG,QAAQ,OAAO,CAAC,KAAK;YACpE,KAAK,MAAM,OAAO,MAAM,IAAI,GAAI;gBAC9B,IAAI,MAAM,IAAI,CAAC,MAAM,MAAM,MAAM,CAAC;YACpC;QACF;IACF;AACF;AAKO,MAAM,iBAAiB;IAC5B;;GAEC,GACD,MAAM,WACJ,GAAa,EACb,OAAwC,EACxC,KAA0B;QAE1B,IAAI,CAAC,UAAU,OAAO,IAAI,GAAG,CAAC,IAAM;QACpC,IAAI,IAAI,MAAM,KAAK,GAAG,OAAO,EAAE;QAE/B,kBAAkB;QAClB,MAAM,YAAY;eAAI,IAAI,IAAI;SAAK;QAEnC,+BAA+B;QAC/B,MAAM,QAAQ,MAAM,QAAQ;QAE5B,oBAAoB;QACpB,MAAM,UAAU,IAAI,IAAI,MAAM,GAAG,CAAC,CAAA,OAAQ;gBAAC,MAAM;gBAAO;aAAK;QAE7D,iCAAiC;QACjC,OAAO,IAAI,GAAG,CAAC,CAAA,KAAM,QAAQ,GAAG,CAAC,OAAO;IAC1C;IAEA;;GAEC,GACD,MAAM,aACJ,QAAgB,EAChB,OAAyB,EACzB,aAAa,aAAa,GAAG;QAE7B,OAAO,MAAM,QAAQ,CAAC,UAAU,SAAS;IAC3C;AACF;AAKO,MAAM,cAAc;IACzB;;GAEC,GACD;QACE,OAAO,YAAY,CAAC,CAAC,QAAQ,GAAG,CAAC,yBAAyB;IAC5D;IAEA;;;GAGC,GACD;QACE,kCAAkC;QAClC,oEAAoE;QACpE,OAAO;IACT;AACF;;AAIO,MAAM,SAAS"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/auth.ts"],"sourcesContent":["/**\n * NextAuth Configuration\n * Handles authentication for students, tutors, and admins\n */\n\nimport { NextAuthOptions } from 'next-auth'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { PrismaAdapter } from '@next-auth/prisma-adapter'\nimport { db } from '@/lib/db'\nimport bcrypt from 'bcryptjs'\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(db),\n\n  providers: [\n    // Email/Password Login\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null\n        }\n\n        const normalizedEmail = credentials.email.trim().toLowerCase()\n\n        // Find user by email\n        const user = await db.user.findFirst({\n          where: { email: { equals: normalizedEmail, mode: 'insensitive' } },\n          include: { profile: true }\n        })\n\n        if (!user || !user.password) {\n          return null\n        }\n\n        // Verify password\n        const isValid = await bcrypt.compare(credentials.password, user.password)\n\n        if (!isValid) {\n          const { logFailedLogin } = await import('@/lib/security/suspicious-activity')\n          await logFailedLogin(null, normalizedEmail)\n          return null\n        }\n\n\n        // Check if onboarding is complete\n        const onboardingComplete = checkOnboardingComplete(user)\n        const tosAccepted = user.profile?.tosAccepted || false\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.profile?.name || user.email,\n          role: user.role,\n          image: user.profile?.avatarUrl,\n          onboardingComplete,\n          tosAccepted\n        }\n      }\n    })\n  ],\n\n  // WeChat OAuth - To be added later\n  // WeChatProvider({\n  //   clientId: process.env.WECHAT_APP_ID!,\n  //   clientSecret: process.env.WECHAT_APP_SECRET!,\n  // })\n  // ], // This was an extra closing bracket for providers array, removed it.\n\n  callbacks: {\n    async jwt({ token, user, trigger, session }) {\n      if (user) {\n        token.role = user.role\n        token.id = user.id\n        token.onboardingComplete = user.onboardingComplete\n        token.tosAccepted = user.tosAccepted\n      }\n\n      // Handle session update (e.g., after onboarding completes)\n      if (trigger === 'update' && session) {\n        token.onboardingComplete = true\n      }\n\n      return token\n    },\n\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.role = token.role as string\n        session.user.id = token.id as string\n        session.user.onboardingComplete = token.onboardingComplete as boolean\n        session.user.tosAccepted = token.tosAccepted as boolean\n      }\n      return session\n    }\n  },\n\n  pages: {\n    signIn: '/login',\n    error: '/login'\n  },\n\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60 // 30 days\n  },\n\n  secret: process.env.NEXTAUTH_SECRET\n}\n\n// Helper function to check if onboarding is complete\nfunction checkOnboardingComplete(user: { profile?: { isOnboarded?: boolean | null } | null }): boolean {\n  // Check if user profile exists and has completed onboarding\n  if (!user?.profile) {\n    return false\n  }\n  \n  // Profile exists but isOnboarded field is not set (null/undefined) - consider not onboarded\n  if (user.profile.isOnboarded === null || user.profile.isOnboarded === undefined) {\n    return false\n  }\n  \n  // Return the actual onboarding status\n  return user.profile.isOnboarded\n}\n\n// Helper function to hash passwords\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\n// Helper function to check if user is authorized\nexport function isAuthorized(userRole: string, allowedRoles: string[]): boolean {\n  return allowedRoles.includes(userRole)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/csrf.ts"],"sourcesContent":["/**\n * CSRF protection for state-changing API requests.\n * Uses a double-submit cookie pattern: cookie set on session, validated on POST/PUT/DELETE/PATCH.\n */\n\nimport { cookies } from 'next/headers'\nimport crypto from 'crypto'\n\nconst CSRF_COOKIE_NAME = 'tutorme_csrf'\nconst CSRF_HEADER_NAME = 'x-csrf-token'\nconst SECRET = process.env.NEXTAUTH_SECRET || process.env.CSRF_SECRET || 'csrf-secret-change-in-production'\n\nfunction hash(value: string): string {\n  return crypto.createHmac('sha256', SECRET).update(value).digest('hex')\n}\n\n/**\n * Generate a CSRF token for the current request. Call from a route or pass to client.\n */\nexport async function getCsrfToken(): Promise<string> {\n  const value = crypto.randomBytes(24).toString('hex')\n  const token = `${value}.${hash(value)}`\n  const cookieStore = await cookies()\n  cookieStore.set(CSRF_COOKIE_NAME, token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24, // 24h\n    path: '/'\n  })\n  return token\n}\n\n/**\n * Verify CSRF token from request header against cookie. Returns true if valid.\n */\nexport async function verifyCsrfToken(req: Request): Promise<boolean> {\n  try {\n    const headerToken = req.headers.get(CSRF_HEADER_NAME)\n    const cookieStore = await cookies()\n    const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value\n    if (!headerToken || !cookieToken) return false\n    if (headerToken !== cookieToken) return false\n\n    const [value] = headerToken.split('.')\n    if (!value) return false\n\n    const expected = `${value}.${hash(value)}`\n    const headerBuffer = Buffer.from(headerToken)\n    const expectedBuffer = Buffer.from(expected)\n    if (headerBuffer.length !== expectedBuffer.length) return false\n\n    return crypto.timingSafeEqual(headerBuffer, expectedBuffer)\n  } catch {\n    return false\n  }\n}\n\nexport { CSRF_HEADER_NAME }\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGC,GAED;AACA;;;AAEA,MAAM,mBAAmB;AACzB,MAAM,mBAAmB;AACzB,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe,IAAI,QAAQ,GAAG,CAAC,WAAW,IAAI;AAEzE,SAAS,KAAK,KAAa;IACzB,OAAO,gHAAM,CAAC,UAAU,CAAC,UAAU,QAAQ,MAAM,CAAC,OAAO,MAAM,CAAC;AAClE;AAKO,eAAe;IACpB,MAAM,QAAQ,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;IAC9C,MAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,KAAK,QAAQ;IACvC,MAAM,cAAc,MAAM,IAAA,8LAAO;IACjC,YAAY,GAAG,CAAC,kBAAkB,OAAO;QACvC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK;QAClB,MAAM;IACR;IACA,OAAO;AACT;AAKO,eAAe,gBAAgB,GAAY;IAChD,IAAI;QACF,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC;QACpC,MAAM,cAAc,MAAM,IAAA,8LAAO;QACjC,MAAM,cAAc,YAAY,GAAG,CAAC,mBAAmB;QACvD,IAAI,CAAC,eAAe,CAAC,aAAa,OAAO;QACzC,IAAI,gBAAgB,aAAa,OAAO;QAExC,MAAM,CAAC,MAAM,GAAG,YAAY,KAAK,CAAC;QAClC,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,WAAW,GAAG,MAAM,CAAC,EAAE,KAAK,QAAQ;QAC1C,MAAM,eAAe,OAAO,IAAI,CAAC;QACjC,MAAM,iBAAiB,OAAO,IAAI,CAAC;QACnC,IAAI,aAAa,MAAM,KAAK,eAAe,MAAM,EAAE,OAAO;QAE1D,OAAO,gHAAM,CAAC,eAAe,CAAC,cAAc;IAC9C,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 615, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/rate-limit.ts"],"sourcesContent":["/**\n * Rate limiting for API routes.\n * Uses Redis when REDIS_URL is set (shared across instances); otherwise in-memory store.\n */\nconst DEFAULT_WINDOW_MS = 60 * 1000 // 1 minute\nconst DEFAULT_MAX = 100 // requests per window per key\nconst REDIS_PREFIX = 'ratelimit:'\n\ninterface Entry {\n  count: number\n  resetAt: number\n}\n\ninterface RateLimitOptions {\n  max: number\n  windowMs?: number\n}\n\ninterface RateLimitResult {\n  allowed: boolean\n  remaining: number\n  resetAt: number\n}\n\nconst memoryStore = new Map<string, Entry>()\n\nfunction prune(): void {\n  const now = Date.now()\n  for (const [key, entry] of memoryStore.entries()) {\n    if (entry.resetAt < now) memoryStore.delete(key)\n  }\n}\n\nfunction checkRateLimitMemory(\n  key: string,\n  options: RateLimitOptions\n): RateLimitResult {\n  const { windowMs, max } = options\n  const now = Date.now()\n  if (memoryStore.size > 10000) prune()\n  let entry = memoryStore.get(key)\n  if (!entry || entry.resetAt < now) {\n    entry = { count: 0, resetAt: now + windowMs }\n    memoryStore.set(key, entry)\n  }\n  entry.count += 1\n  const allowed = entry.count <= max\n  const remaining = Math.max(0, max - entry.count)\n  return { allowed, remaining, resetAt: entry.resetAt }\n}\n\nlet redisClient: import('ioredis').Redis | null = null\nlet redisInitPromise: Promise<import('ioredis').Redis | null> | null = null\n\nasync function getRedisClient(): Promise<import('ioredis').Redis | null> {\n  if (redisClient) return redisClient\n  if (typeof window !== 'undefined') return null // browser\n  const url = process.env.REDIS_URL\n  if (!url) return null\n  if (!redisInitPromise) {\n    redisInitPromise = (async () => {\n      try {\n        const { Redis } = await import('ioredis')\n        const client = new Redis(url, {\n          retryStrategy: (times) => Math.min(times * 50, 2000),\n          maxRetriesPerRequest: 3,\n        })\n        client.on('error', () => {})\n        redisClient = client\n        return client\n      } catch {\n        return null\n      }\n    })()\n  }\n  return redisInitPromise\n}\n\nasync function checkRateLimitRedis(\n  key: string,\n  options: RateLimitOptions\n): Promise<RateLimitResult> {\n  const redis = await getRedisClient()\n  if (!redis) return checkRateLimitMemory(key, options)\n\n  const { windowMs, max } = options\n  const now = Date.now()\n  const fullKey = REDIS_PREFIX + key\n  const ttlSeconds = Math.ceil(windowMs / 1000)\n\n  try {\n    // Atomic Lua: INCR + EXPIRE (when count=1) in single round-trip - no race conditions\n    const result = (await redis.eval(\n      `local c=redis.call('INCR',KEYS[1]) if c==1 then redis.call('EXPIRE',KEYS[1],ARGV[1]) end return {c,redis.call('PTTL',KEYS[1])}`,\n      1,\n      fullKey,\n      ttlSeconds\n    )) as [number, number]\n    const [newCount, pttl] = result\n    const resetAt = pttl > 0 ? now + pttl : now + windowMs\n\n    const allowed = newCount <= max\n    const remaining = Math.max(0, max - newCount)\n    return { allowed, remaining, resetAt }\n  } catch {\n    return checkRateLimitMemory(key, options)\n  }\n}\n\n/**\n * Check rate limit. Returns { allowed, remaining, resetAt }.\n * Uses Redis when REDIS_URL is set; otherwise in-memory (per instance).\n * key: typically prefix + IP (e.g. \"login:\" + getClientIdentifier(req))\n */\nexport async function checkRateLimit(\n  key: string,\n  maxOrOptions: number | RateLimitOptions = DEFAULT_MAX\n): Promise<RateLimitResult> {\n  const options: RateLimitOptions =\n    typeof maxOrOptions === 'number'\n      ? { max: maxOrOptions, windowMs: DEFAULT_WINDOW_MS }\n      : { windowMs: DEFAULT_WINDOW_MS, ...maxOrOptions }\n\n  if (process.env.REDIS_URL) {\n    return checkRateLimitRedis(key, options)\n  }\n  return checkRateLimitMemory(key, options)\n}\n\n/** Presets for sensitive routes (stricter limits) */\nexport const RATE_LIMIT_PRESETS = {\n  /** Login: 10 attempts per 15 minutes per IP */\n  login: { max: 10, windowMs: 15 * 60 * 1000 },\n  /** Signup/register: allow multi-step retries and multi-role onboarding in the same browser */\n  register: { max: 12, windowMs: 15 * 60 * 1000 },\n  /** Payment create: 20 per minute per IP */\n  paymentCreate: { max: 20, windowMs: 60 * 1000 },\n  /** Enroll (subject or curriculum): 30 per minute per IP */\n  enroll: { max: 30, windowMs: 60 * 1000 },\n  /** Class booking: 20 per minute per IP */\n  booking: { max: 20, windowMs: 60 * 1000 },\n  /** AI generation/chat: 12 per minute per client identifier */\n  aiGenerate: { max: 12, windowMs: 60 * 1000 },\n} as const\n\n/**\n * Check rate limit using a named preset. Key will be prefixed with the preset name.\n */\nexport async function checkRateLimitPreset(\n  req: Request,\n  preset: keyof typeof RATE_LIMIT_PRESETS\n): Promise<RateLimitResult> {\n  const ip = getClientIdentifier(req)\n  const key = `${preset}:${ip}`\n  const options = RATE_LIMIT_PRESETS[preset]\n  return checkRateLimit(key, options)\n}\n\n/**\n * Get client identifier for rate limiting (IP or x-forwarded-for).\n */\nexport function getClientIdentifier(req: Request): string {\n  const trustProxy = process.env.TRUST_PROXY === 'true'\n  const forwarded = req.headers.get('x-forwarded-for')\n  const realIp = req.headers.get('x-real-ip')\n  const cfIp = req.headers.get('cf-connecting-ip')\n\n  const firstForwarded = forwarded?.split(',')[0]?.trim()\n  const candidate = trustProxy ? (firstForwarded || realIp || cfIp) : (realIp || cfIp)\n  const ip = normalizeIp(candidate)\n  if (ip !== 'unknown') return ip\n\n  // Fallback identifier when no reliable IP is available (prevents all unknown clients sharing one bucket).\n  const ua = req.headers.get('user-agent') || 'unknown'\n  const lang = req.headers.get('accept-language') || 'unknown'\n  const fingerprint = simpleHash(`${ua}|${lang}`)\n  return `unknown:${fingerprint}`\n}\n\nfunction normalizeIp(ip: string | null | undefined): string {\n  if (!ip) return 'unknown'\n  const trimmed = ip.trim()\n  if (!trimmed) return 'unknown'\n  if (trimmed === '::1') return '127.0.0.1'\n  return trimmed\n}\n\nfunction simpleHash(input: string): string {\n  let hash = 2166136261\n  for (let i = 0; i < input.length; i += 1) {\n    hash ^= input.charCodeAt(i)\n    hash = Math.imul(hash, 16777619)\n  }\n  return (hash >>> 0).toString(16).padStart(8, '0')\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 790, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/rbac.ts"],"sourcesContent":["/**\n * Role-based access control: granular permissions per role.\n * Use requirePermission() in admin/sensitive routes.\n */\n\nimport type { Role } from '@prisma/client'\n\nexport const PERMISSIONS = {\n  // Admin\n  ADMIN_VIEW_PAYMENTS: 'admin:payments:read',\n  ADMIN_VIEW_WEBHOOKS: 'admin:webhooks:read',\n  ADMIN_MANAGE_API_KEYS: 'admin:api_keys',\n  ADMIN_VIEW_USERS: 'admin:users:read',\n  // Tutor\n  TUTOR_MANAGE_CLINICS: 'tutor:clinics',\n  TUTOR_VIEW_REPORTS: 'tutor:reports:read',\n  // Student\n  STUDENT_VIEW_OWN: 'student:own:read',\n  STUDENT_BOOK_CLASS: 'student:book'\n} as const\n\nexport type Permission = (typeof PERMISSIONS)[keyof typeof PERMISSIONS]\n\nconst ROLE_PERMISSIONS: Record<Role, Permission[]> = {\n  ADMIN: [\n    PERMISSIONS.ADMIN_VIEW_PAYMENTS,\n    PERMISSIONS.ADMIN_VIEW_WEBHOOKS,\n    PERMISSIONS.ADMIN_MANAGE_API_KEYS,\n    PERMISSIONS.ADMIN_VIEW_USERS,\n    PERMISSIONS.TUTOR_MANAGE_CLINICS,\n    PERMISSIONS.TUTOR_VIEW_REPORTS,\n    PERMISSIONS.STUDENT_VIEW_OWN,\n    PERMISSIONS.STUDENT_BOOK_CLASS\n  ],\n  TUTOR: [\n    PERMISSIONS.TUTOR_MANAGE_CLINICS,\n    PERMISSIONS.TUTOR_VIEW_REPORTS,\n    PERMISSIONS.STUDENT_VIEW_OWN,\n    PERMISSIONS.STUDENT_BOOK_CLASS\n  ],\n  STUDENT: [PERMISSIONS.STUDENT_VIEW_OWN, PERMISSIONS.STUDENT_BOOK_CLASS]\n}\n\nexport function hasPermission(role: Role, permission: Permission): boolean {\n  return ROLE_PERMISSIONS[role]?.includes(permission) ?? false\n}\n\nexport function getPermissionsForRole(role: Role): Permission[] {\n  return ROLE_PERMISSIONS[role] ?? []\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;AAIM,MAAM,cAAc;IACzB,QAAQ;IACR,qBAAqB;IACrB,qBAAqB;IACrB,uBAAuB;IACvB,kBAAkB;IAClB,QAAQ;IACR,sBAAsB;IACtB,oBAAoB;IACpB,UAAU;IACV,kBAAkB;IAClB,oBAAoB;AACtB;AAIA,MAAM,mBAA+C;IACnD,OAAO;QACL,YAAY,mBAAmB;QAC/B,YAAY,mBAAmB;QAC/B,YAAY,qBAAqB;QACjC,YAAY,gBAAgB;QAC5B,YAAY,oBAAoB;QAChC,YAAY,kBAAkB;QAC9B,YAAY,gBAAgB;QAC5B,YAAY,kBAAkB;KAC/B;IACD,OAAO;QACL,YAAY,oBAAoB;QAChC,YAAY,kBAAkB;QAC9B,YAAY,gBAAgB;QAC5B,YAAY,kBAAkB;KAC/B;IACD,SAAS;QAAC,YAAY,gBAAgB;QAAE,YAAY,kBAAkB;KAAC;AACzE;AAEO,SAAS,cAAc,IAAU,EAAE,UAAsB;IAC9D,OAAO,gBAAgB,CAAC,KAAK,EAAE,SAAS,eAAe;AACzD;AAEO,SAAS,sBAAsB,IAAU;IAC9C,OAAO,gBAAgB,CAAC,KAAK,IAAI,EAAE;AACrC"}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/admin-ip.ts"],"sourcesContent":["/**\n * Admin panel IP whitelist. When set, only listed IPs can access /admin and admin API routes.\n * Env: ADMIN_IP_WHITELIST (comma-separated IPs or CIDRs, e.g. \"1.2.3.4,10.0.0.0/8\")\n */\n\nfunction parseWhitelist(): string[] {\n  const raw = process.env.ADMIN_IP_WHITELIST\n  if (!raw?.trim()) return []\n  return raw.split(',').map((s) => s.trim()).filter(Boolean)\n}\n\nfunction ipToNum(ip: string): number {\n  const parts = ip.split('.').map(Number)\n  if (parts.length !== 4) return 0\n  return (parts[0]! << 24) | (parts[1]! << 16) | (parts[2]! << 8) | parts[3]!\n}\n\nfunction matchCidr(ip: string, cidr: string): boolean {\n  if (!cidr.includes('/')) return ip === cidr\n  const [net, bits] = cidr.split('/')\n  if (!net || bits === undefined) return false\n  const mask = ~((1 << (32 - parseInt(bits, 10))) - 1) >>> 0\n  return (ipToNum(ip) & mask) === (ipToNum(net) & mask)\n}\n\n/**\n * Returns true if admin access is allowed from this IP.\n * If whitelist is empty, all IPs are allowed.\n */\nexport function isAdminIpAllowed(clientIp: string): boolean {\n  const whitelist = parseWhitelist()\n  if (whitelist.length === 0) return true\n  return whitelist.some((entry) => matchCidr(clientIp, entry) || clientIp === entry)\n}\n\nexport function getClientIp(req: Request): string {\n  const forwarded = req.headers.get('x-forwarded-for')\n  const ip = forwarded ? forwarded.split(',')[0]?.trim() : null\n  return ip ?? req.headers.get('x-real-ip') ?? 'unknown'\n}\n"],"names":[],"mappings":";;;;;;AAAA;;;CAGC,GAED,SAAS;IACP,MAAM,MAAM,QAAQ,GAAG,CAAC,kBAAkB;IAC1C,IAAI,CAAC,KAAK,QAAQ,OAAO,EAAE;IAC3B,OAAO,IAAI,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,IAAI,MAAM,CAAC;AACpD;AAEA,SAAS,QAAQ,EAAU;IACzB,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC;IAChC,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;IAC/B,OAAO,AAAC,KAAK,CAAC,EAAE,IAAK,KAAO,KAAK,CAAC,EAAE,IAAK,KAAO,KAAK,CAAC,EAAE,IAAK,IAAK,KAAK,CAAC,EAAE;AAC5E;AAEA,SAAS,UAAU,EAAU,EAAE,IAAY;IACzC,IAAI,CAAC,KAAK,QAAQ,CAAC,MAAM,OAAO,OAAO;IACvC,MAAM,CAAC,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC;IAC/B,IAAI,CAAC,OAAO,SAAS,WAAW,OAAO;IACvC,MAAM,OAAO,CAAC,CAAC,CAAC,KAAM,KAAK,SAAS,MAAM,GAAI,IAAI,CAAC,MAAM;IACzD,OAAO,CAAC,QAAQ,MAAM,IAAI,MAAM,CAAC,QAAQ,OAAO,IAAI;AACtD;AAMO,SAAS,iBAAiB,QAAgB;IAC/C,MAAM,YAAY;IAClB,IAAI,UAAU,MAAM,KAAK,GAAG,OAAO;IACnC,OAAO,UAAU,IAAI,CAAC,CAAC,QAAU,UAAU,UAAU,UAAU,aAAa;AAC9E;AAEO,SAAS,YAAY,GAAY;IACtC,MAAM,YAAY,IAAI,OAAO,CAAC,GAAG,CAAC;IAClC,MAAM,KAAK,YAAY,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS;IACzD,OAAO,MAAM,IAAI,OAAO,CAAC,GAAG,CAAC,gBAAgB;AAC/C"}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/api/middleware.ts"],"sourcesContent":["/**\n * API Route Middleware Utilities\n * Provides authentication, authorization, CSRF, rate limiting, and error handling for API routes\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth'\nimport type { Session } from 'next-auth'\nimport { verifyCsrfToken } from '@/lib/security/csrf'\nimport { checkRateLimit, checkRateLimitPreset, getClientIdentifier } from '@/lib/security/rate-limit'\nimport { hasPermission, type Permission } from '@/lib/security/rbac'\nimport { isAdminIpAllowed, getClientIp } from '@/lib/security/admin-ip'\n\n// Custom error classes\nexport class UnauthorizedError extends Error {\n    constructor(message = 'Unauthorized - Please log in') {\n        super(message)\n        this.name = 'UnauthorizedError'\n    }\n}\n\nexport class ForbiddenError extends Error {\n    constructor(message = 'Forbidden - Insufficient permissions') {\n        super(message)\n        this.name = 'ForbiddenError'\n    }\n}\n\nexport class ValidationError extends Error {\n    constructor(message: string) {\n        super(message)\n        this.name = 'ValidationError'\n    }\n}\n\nexport class NotFoundError extends Error {\n    constructor(message = 'Resource not found') {\n        super(message)\n        this.name = 'NotFoundError'\n    }\n}\n\n/**\n * Centralised API error logging and 500 response.\n * Use in route catch blocks for consistent logging and response shape.\n */\nexport function handleApiError(\n    error: unknown,\n    defaultMessage: string = 'Internal server error',\n    logLabel: string = 'API Error'\n): NextResponse {\n    console.error(`[${logLabel}]`, error)\n    const message = error instanceof Error ? error.message : defaultMessage\n    const isDev = process.env.NODE_ENV === 'development'\n    return NextResponse.json(\n        { error: isDev ? message : defaultMessage },\n        { status: 500 }\n    )\n}\n\n// Handler type (context is optional route params, e.g. { params: { id: string } })\ntype Handler = (\n    req: NextRequest,\n    session: Session,\n    context?: { params?: Promise<Record<string, string | string[]>> | Record<string, string | string[]> }\n) => Promise<Response> | Response\n\n// Middleware options\ninterface WithAuthOptions {\n    role?: 'TUTOR' | 'STUDENT' | 'ADMIN' | 'PARENT'\n    optional?: boolean\n}\n\nfunction normalizeRole(role: unknown): string {\n    if (typeof role !== 'string') return ''\n    return role.trim().toUpperCase()\n}\n\n/**\n * Authentication middleware wrapper\n * Automatically handles session validation, role checking, and error responses\n * \n * @example\n * export const GET = withAuth(async (req, session) => {\n *   // session is guaranteed to exist\n *   return NextResponse.json({ userId: session.user.id })\n * })\n * \n * @example with role requirement\n * export const POST = withAuth(async (req, session) => {\n *   // session.user.role === 'TUTOR' is guaranteed\n *   return NextResponse.json({})\n * }, { role: 'TUTOR' })\n */\nexport function withAuth(\n    handler: Handler,\n    options?: WithAuthOptions\n) {\n    return async (req: NextRequest, context?: { params?: Promise<Record<string, string | string[]>> | Record<string, string | string[]> }) => {\n        try {\n            const session = await getServerSession(authOptions)\n\n            // Check if user is authenticated\n            if (!session?.user?.id) {\n                if (options?.optional) {\n                    // Allow unauthenticated access\n                    return handler(req, session as Session, context)\n                }\n                throw new UnauthorizedError()\n            }\n\n            // Check role requirements\n            if (options?.role && normalizeRole(session.user.role) !== normalizeRole(options.role)) {\n                // Fallback: session role can be stale after account updates or seed resets.\n                const { db } = await import('@/lib/db')\n                const freshUser = await db.user.findUnique({\n                    where: { id: session.user.id },\n                    select: { role: true },\n                })\n                if (normalizeRole(freshUser?.role) !== normalizeRole(options.role)) {\n                    throw new ForbiddenError(`This endpoint requires ${options.role} role`)\n                }\n            }\n\n            // Call the actual handler\n            return await handler(req, session, context)\n\n        } catch (error) {\n            // Handle known error types\n            if (error instanceof UnauthorizedError) {\n                return NextResponse.json(\n                    { error: error.message },\n                    { status: 401 }\n                )\n            }\n\n            if (error instanceof ForbiddenError) {\n                return NextResponse.json(\n                    { error: error.message },\n                    { status: 403 }\n                )\n            }\n\n            if (error instanceof ValidationError) {\n                return NextResponse.json(\n                    { error: error.message },\n                    { status: 400 }\n                )\n            }\n\n            if (error instanceof NotFoundError) {\n                return NextResponse.json(\n                    { error: error.message },\n                    { status: 404 }\n                )\n            }\n\n            // Handle unknown errors\n            console.error('API Error:', error)\n\n            // Don't expose internal errors in production\n            const isDev = process.env.NODE_ENV === 'development'\n            return NextResponse.json(\n                {\n                    error: isDev\n                        ? (error instanceof Error ? error.message : 'Unknown error')\n                        : 'Internal server error'\n                },\n                { status: 500 }\n            )\n        }\n    }\n}\n\n/**\n * Get the current user session without throwing errors\n * Useful for optional authentication scenarios\n */\nexport async function getCurrentSession(): Promise<Session | null> {\n    try {\n        return await getServerSession(authOptions)\n    } catch (error) {\n        console.error('Error getting session:', error)\n        return null\n    }\n}\n\n/**\n * Require authentication - throws if not authenticated\n * Useful when you need the session inside a try/catch block\n */\nexport async function requireAuth(): Promise<Session> {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n        throw new UnauthorizedError()\n    }\n    return session\n}\n\n/**\n * Require specific role - throws if wrong role\n */\nexport async function requireRole(role: 'TUTOR' | 'STUDENT' | 'ADMIN'): Promise<Session> {\n    const session = await requireAuth()\n    if (normalizeRole(session.user.role) !== normalizeRole(role)) {\n        throw new ForbiddenError(`This action requires ${role} role`)\n    }\n    return session\n}\n\n/** State-changing methods that require CSRF */\nconst CSRF_METHODS = new Set(['POST', 'PUT', 'PATCH', 'DELETE'])\n\n/** API path prefixes that skip CSRF (webhooks, auth, public) */\nconst CSRF_SKIP_PATHS = ['/api/auth', '/api/payments/webhooks', '/api/csrf', '/api/health']\n\n/**\n * Verify CSRF for state-changing requests. Call at the start of POST/PUT/PATCH/DELETE handlers\n * that are not webhooks or auth. Returns 403 response if invalid; otherwise returns null.\n */\nexport async function requireCsrf(req: NextRequest): Promise<NextResponse | null> {\n    if (!CSRF_METHODS.has(req.method)) return null\n    const path = req.nextUrl?.pathname ?? ''\n    if (CSRF_SKIP_PATHS.some((p) => path.startsWith(p))) return null\n    const valid = await verifyCsrfToken(req)\n    if (!valid) {\n        return NextResponse.json({ error: 'Invalid or missing CSRF token' }, { status: 403 })\n    }\n    return null\n}\n\ntype AnyHandler = (req: NextRequest, ...args: unknown[]) => Promise<Response> | Response\n\n/**\n * Wraps a state-changing handler to require a valid CSRF token (POST/PUT/PATCH/DELETE).\n * Use with withAuth: export const POST = withCsrf(withAuth(async (req, session) => ...))\n */\nexport function withCsrf(handler: AnyHandler): AnyHandler {\n    return async (req: NextRequest, ...args: unknown[]) => {\n        const csrfError = await requireCsrf(req)\n        if (csrfError) return csrfError\n        return handler(req, ...args)\n    }\n}\n\n/**\n * Apply rate limit by client IP (and optionally by userId when session exists).\n * Returns 429 response if over limit; otherwise returns null.\n */\nexport async function withRateLimit(\n    req: NextRequest,\n    max: number = 100\n): Promise<{ response: NextResponse | null; remaining: number }> {\n    const key = getClientIdentifier(req)\n    const { allowed, remaining } = await checkRateLimit(key, max)\n    if (!allowed) {\n        const res = NextResponse.json(\n            { error: 'Too many requests' },\n            { status: 429, headers: { 'Retry-After': '60' } }\n        )\n        return { response: res, remaining: 0 }\n    }\n    return { response: null, remaining }\n}\n\ntype RateLimitPreset = 'login' | 'register' | 'paymentCreate' | 'enroll' | 'booking' | 'aiGenerate'\n\n/**\n * Apply rate limit using a named preset (stricter limits for sensitive routes).\n * Returns 429 response if over limit; otherwise returns null.\n */\nexport async function withRateLimitPreset(\n    req: NextRequest,\n    preset: RateLimitPreset\n): Promise<{ response: NextResponse | null; remaining: number }> {\n    const { allowed, remaining, resetAt } = await checkRateLimitPreset(req as unknown as Request, preset)\n    if (!allowed) {\n        const retryAfter = Math.ceil((resetAt - Date.now()) / 1000)\n        const res = NextResponse.json(\n            { error: 'Too many requests. Please try again later.' },\n            { status: 429, headers: { 'Retry-After': String(Math.max(1, retryAfter)) } }\n        )\n        return { response: res, remaining: 0 }\n    }\n    return { response: null, remaining }\n}\n\n/**\n * Require a specific permission (RBAC). Call after withAuth.\n * Returns 403 if user's role does not have the permission.\n */\nexport function requirePermission(session: Session, permission: Permission): NextResponse | null {\n    const role = session?.user?.role as 'ADMIN' | 'TUTOR' | 'STUDENT' | undefined\n    if (!role || !hasPermission(role, permission)) {\n        return NextResponse.json({ error: 'Forbidden - Insufficient permissions' }, { status: 403 })\n    }\n    return null\n}\n\n/**\n * Require admin IP whitelist. When ADMIN_IP_WHITELIST is set, only listed IPs can access.\n * Returns 403 if client IP is not allowed.\n */\nexport function requireAdminIp(req: NextRequest): NextResponse | null {\n    const ip = getClientIp(req as unknown as Request)\n    if (!isAdminIpAllowed(ip)) {\n        return NextResponse.json({ error: 'Forbidden - Admin access not allowed from this IP' }, { status: 403 })\n    }\n    return null\n}\n\n/**\n * Get auth from session or API key (Bearer). Use for admin routes that support both browser and server-to-server.\n * Returns session if logged in, or { apiKey: keyId } if valid Bearer key, else null.\n */\nexport async function getSessionOrApiKey(req: NextRequest): Promise<\n    | { type: 'session'; session: Session }\n    | { type: 'apiKey'; keyId: string }\n    | null\n> {\n    const authHeader = req.headers.get('authorization')\n    if (authHeader?.startsWith('Bearer ')) {\n        const token = authHeader.slice(7)\n        if (token.startsWith('tm_')) {\n            const { verifyApiKey } = await import('@/lib/security/api-key')\n            const key = await verifyApiKey(token)\n            if (key) return { type: 'apiKey', keyId: key.id }\n        }\n    }\n    const session = await getServerSession(authOptions)\n    if (session?.user?.id) return { type: 'session', session }\n    return null\n}\n\n/**\n * Parse and clamp numeric query/body values to safe bounds.\n */\nexport function parseBoundedInt(\n    raw: string | null | undefined,\n    defaultValue: number,\n    options: { min?: number; max: number }\n): number {\n    const min = options.min ?? 0\n    const parsed = Number.parseInt(raw ?? '', 10)\n    if (!Number.isFinite(parsed)) return defaultValue\n    if (parsed < min) return min\n    if (parsed > options.max) return options.max\n    return parsed\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1202, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/types.ts"],"sourcesContent":["/**\n * Shared payment gateway types\n */\n\nexport interface CreatePaymentRequest {\n  amount: number\n  currency: string\n  /** For clinic bookings; omit for course payments */\n  bookingId?: string\n  /** For course payments; used as gateway reference when bookingId is absent */\n  curriculumId?: string\n  studentEmail: string\n  description: string\n  metadata?: Record<string, unknown>\n  /** Override success redirect (e.g. with ?type=course or ?type=booking). */\n  successUrl?: string\n  /** Override cancel/failure redirect when supported by gateway. */\n  cancelUrl?: string\n}\n\nexport interface PaymentResponse {\n  paymentId: string\n  checkoutUrl: string\n  status: string\n}\n\nexport interface WebhookResult {\n  success: boolean\n  paymentId?: string\n  eventType: string\n  status?: string\n  error?: string\n}\n\nexport interface RefundResponse {\n  refundId: string\n  status: string\n  amountRefunded?: number\n  error?: string\n}\n\nexport interface PaymentGateway {\n  createPayment(request: CreatePaymentRequest): Promise<PaymentResponse>\n  verifyWebhook(payload: unknown, signature: string): boolean\n  processWebhook(payload: unknown): Promise<WebhookResult>\n  refundPayment(paymentId: string, amount?: number): Promise<RefundResponse>\n}\n"],"names":[],"mappings":"AAAA;;CAEC"}},
    {"offset": {"line": 1210, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/airwallex.ts"],"sourcesContent":["/**\n * Airwallex payment gateway implementation\n * - OAuth2-style token authentication (login with API key, use Bearer token)\n * - Create payment intent\n * - Webhook signature verification (HMAC-SHA256 of timestamp + raw body)\n * - Refund via payment_attempt_id (store attempt_id from webhook for refunds)\n */\n\nimport crypto from 'crypto'\nimport type {\n  CreatePaymentRequest,\n  PaymentResponse,\n  PaymentGateway,\n  WebhookResult,\n  RefundResponse\n} from './types'\n\nconst SANDBOX_BASE = 'https://api-demo.airwallex.com'\nconst PRODUCTION_BASE = 'https://api.airwallex.com'\n\ninterface TokenCache {\n  token: string\n  expiresAt: number\n}\n\nlet tokenCache: TokenCache | null = null\n\nfunction getBaseUrl(): string {\n  const env = process.env.AIRWALLEX_ENV || 'sandbox'\n  return env === 'production' ? PRODUCTION_BASE : SANDBOX_BASE\n}\n\nasync function getAccessToken(): Promise<string> {\n  const now = Date.now()\n  if (tokenCache && tokenCache.expiresAt > now + 60_000) {\n    return tokenCache.token\n  }\n\n  const clientId = process.env.AIRWALLEX_CLIENT_ID\n  const apiKey = process.env.AIRWALLEX_API_KEY\n  if (!clientId || !apiKey) {\n    throw new Error('Airwallex: AIRWALLEX_CLIENT_ID and AIRWALLEX_API_KEY are required')\n  }\n\n  const base = getBaseUrl()\n  const res = await fetch(`${base}/api/v1/authentication/login`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      'x-client-id': clientId,\n      'x-api-key': apiKey\n    }\n  })\n\n  if (!res.ok) {\n    const text = await res.text()\n    throw new Error(`Airwallex auth failed: ${res.status} ${text}`)\n  }\n\n  const data = (await res.json()) as { token?: string; expires_at?: string }\n  const token = data.token\n  const expiresAt = data.expires_at\n  if (!token) {\n    throw new Error('Airwallex: no token in auth response')\n  }\n\n  const expiresAtMs = expiresAt ? new Date(expiresAt).getTime() : Date.now() + 25 * 60 * 1000\n  tokenCache = { token, expiresAt: expiresAtMs }\n  return token\n}\n\n/**\n * For Airwallex webhook verification, pass an object with rawBody and timestamp:\n * { rawBody: string, timestamp: string } (timestamp from x-timestamp header).\n * If payload is a string, it is treated as rawBody and timestamp must be in signature header context\n * (caller should pass timestamp separately - we don't have it in the interface, so we require the object form).\n */\nfunction getRawBodyAndTimestamp(payload: unknown): { rawBody: string; timestamp: string } | null {\n  if (payload && typeof payload === 'object' && 'rawBody' in payload && 'timestamp' in payload) {\n    const rawBody = (payload as { rawBody: unknown }).rawBody\n    const timestamp = (payload as { timestamp: unknown }).timestamp\n    if (typeof rawBody === 'string' && typeof timestamp === 'string') {\n      return { rawBody, timestamp }\n    }\n  }\n  return null\n}\n\nexport class AirwallexGateway implements PaymentGateway {\n  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {\n    const token = await getAccessToken()\n    const base = getBaseUrl()\n    const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`\n\n    const defaultReturn = process.env.PAYMENT_SUCCESS_URL || `${process.env.NEXT_PUBLIC_APP_URL || ''}/payment/success`\n    const returnUrl = request.successUrl ?? defaultReturn\n    const body = {\n      request_id: requestId,\n      amount: request.amount,\n      currency: request.currency.toUpperCase(),\n      merchant_order_id: request.bookingId ?? (request.curriculumId ? `course:${request.curriculumId}` : 'payment'),\n      return_url: returnUrl\n    }\n\n    const res = await fetch(`${base}/api/v1/pa/payment_intents/create`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${token}`,\n        'x-client-id': process.env.AIRWALLEX_CLIENT_ID!\n      },\n      body: JSON.stringify(body)\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      throw new Error(`Airwallex create payment intent failed: ${res.status} ${text}`)\n    }\n\n    const data = (await res.json()) as {\n      id?: string\n      status?: string\n      client_secret?: string\n      url?: string\n    }\n\n    const paymentId = data.id\n    if (!paymentId) {\n      throw new Error('Airwallex: no payment intent id in response')\n    }\n\n    const checkoutUrl =\n      data.url ||\n      `${process.env.NEXT_PUBLIC_APP_URL || ''}/payment/checkout?intent_id=${paymentId}&client_secret=${encodeURIComponent(data.client_secret || '')}`\n\n    return {\n      paymentId,\n      checkoutUrl,\n      status: data.status || 'REQUIRES_PAYMENT_METHOD'\n    }\n  }\n\n  verifyWebhook(payload: unknown, signature: string): boolean {\n    const secret = process.env.AIRWALLEX_WEBHOOK_SECRET\n    if (!secret) {\n      return false\n    }\n    const parsed = getRawBodyAndTimestamp(payload)\n    if (!parsed) {\n      return false\n    }\n    const { rawBody, timestamp } = parsed\n    const policy = `${timestamp}${rawBody}`\n    const expected = crypto.createHmac('sha256', secret).update(policy).digest('hex')\n    return crypto.timingSafeEqual(Buffer.from(expected, 'hex'), Buffer.from(signature, 'hex'))\n  }\n\n  async processWebhook(payload: unknown): Promise<WebhookResult> {\n    const body = payload as { name?: string; data?: { id?: string; status?: string; payment_attempt_id?: string } }\n    const eventName = body?.name || ''\n    const data = body?.data\n\n    if (!data) {\n      return { success: false, eventType: eventName, error: 'Missing event data' }\n    }\n\n    const paymentId = data.id\n    const status = data.status\n\n    if (eventName === 'payment_intent.succeeded') {\n      return {\n        success: true,\n        paymentId,\n        eventType: eventName,\n        status: status || 'succeeded'\n      }\n    }\n\n    if (eventName === 'payment_intent.cancelled' || eventName === 'payment_intent.failed') {\n      return {\n        success: true,\n        paymentId,\n        eventType: eventName,\n        status: status || 'cancelled'\n      }\n    }\n\n    return {\n      success: true,\n      paymentId,\n      eventType: eventName,\n      status\n    }\n  }\n\n  async refundPayment(paymentId: string, amount?: number): Promise<RefundResponse> {\n    const token = await getAccessToken()\n    const base = getBaseUrl()\n    const requestId = `refund_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`\n\n    const body: Record<string, unknown> = {\n      payment_attempt_id: paymentId,\n      reason: 'customer_requested',\n      request_id: requestId\n    }\n    if (amount != null && amount > 0) {\n      body.amount = amount\n    }\n\n    const res = await fetch(`${base}/api/v1/pa/refunds/create`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${token}`,\n        'x-client-id': process.env.AIRWALLEX_CLIENT_ID!\n      },\n      body: JSON.stringify(body)\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      return {\n        refundId: '',\n        status: 'failed',\n        error: `Airwallex refund failed: ${res.status} ${text}`\n      }\n    }\n\n    const data = (await res.json()) as { id?: string; status?: string; amount?: number }\n    return {\n      refundId: data.id || requestId,\n      status: data.status || 'RECEIVED',\n      amountRefunded: data.amount\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1414, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/hitpay.ts"],"sourcesContent":["/**\n * Hitpay payment gateway implementation\n * - Create payment request (POST /v1/payment-requests)\n * - HMAC signature verification (Hitpay-Signature: SHA-256 derived from salt)\n * - Webhook processing (charge.created, payment_request.completed, etc.)\n * - Refund (POST /v1/refund)\n */\n\nimport crypto from 'crypto'\nimport type {\n  CreatePaymentRequest,\n  PaymentResponse,\n  PaymentGateway,\n  WebhookResult,\n  RefundResponse\n} from './types'\n\nconst SANDBOX_BASE = 'https://api.sandbox.hit-pay.com'\nconst PRODUCTION_BASE = 'https://api.hit-pay.com'\n\nfunction getBaseUrl(): string {\n  const env = process.env.HITPAY_ENV || 'sandbox'\n  return env === 'production' ? PRODUCTION_BASE : SANDBOX_BASE\n}\n\nexport class HitpayGateway implements PaymentGateway {\n  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {\n    const apiKey = process.env.HITPAY_API_KEY\n    if (!apiKey) {\n      throw new Error('Hitpay: HITPAY_API_KEY is required')\n    }\n\n    const base = getBaseUrl()\n    const defaultRedirect = process.env.PAYMENT_SUCCESS_URL || `${process.env.NEXT_PUBLIC_APP_URL || ''}/payment/success`\n    const redirectUrl = request.successUrl ?? defaultRedirect\n    const webhookUrl = process.env.HITPAY_WEBHOOK_URL || `${process.env.NEXT_PUBLIC_APP_URL || ''}/api/payments/webhooks/hitpay`\n\n    const body = {\n      amount: request.amount,\n      currency: request.currency.toLowerCase(),\n      email: request.studentEmail,\n      purpose: request.description,\n      reference_number: request.bookingId ?? (request.curriculumId ? `course:${request.curriculumId}` : 'payment'),\n      redirect_url: redirectUrl,\n      webhook: webhookUrl\n    }\n\n    const res = await fetch(`${base}/v1/payment-requests`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-BUSINESS-API-KEY': apiKey\n      },\n      body: JSON.stringify(body)\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      throw new Error(`Hitpay create payment failed: ${res.status} ${text}`)\n    }\n\n    const data = (await res.json()) as {\n      id?: string\n      status?: string\n      url?: string\n    }\n\n    const paymentId = data.id\n    if (!paymentId) {\n      throw new Error('Hitpay: no payment request id in response')\n    }\n\n    const checkoutUrl = data.url || ''\n\n    return {\n      paymentId,\n      checkoutUrl,\n      status: data.status || 'pending'\n    }\n  }\n\n  /**\n   * Verify Hitpay webhook signature.\n   * Pass the raw request body string as payload and the Hitpay-Signature header value as signature.\n   * Hitpay uses HMAC-SHA256 with the salt as key and the JSON payload as message.\n   */\n  verifyWebhook(payload: unknown, signature: string): boolean {\n    const salt = process.env.HITPAY_SALT\n    if (!salt) {\n      return false\n    }\n    const rawBody = typeof payload === 'string' ? payload : JSON.stringify(payload)\n    const expected = crypto.createHmac('sha256', salt).update(rawBody).digest('hex')\n    if (expected.length !== signature.length) {\n      return false\n    }\n    return crypto.timingSafeEqual(Buffer.from(expected, 'hex'), Buffer.from(signature, 'hex'))\n  }\n\n  async processWebhook(payload: unknown): Promise<WebhookResult> {\n    const body = payload as {\n      id?: string\n      status?: string\n      payment_request_id?: string\n      amount?: number\n    }\n\n    const paymentId = body?.id || body?.payment_request_id\n    const status = body?.status\n\n    if (!paymentId) {\n      return { success: false, eventType: 'unknown', error: 'Missing payment id in webhook' }\n    }\n\n    const statusMap: Record<string, string> = {\n      succeeded: 'succeeded',\n      completed: 'completed',\n      paid: 'completed',\n      pending: 'pending',\n      failed: 'failed',\n      expired: 'expired',\n      canceled: 'cancelled',\n      cancelled: 'cancelled',\n      partially_refunded: 'partially_refunded',\n      refunded: 'refunded'\n    }\n    const normalizedStatus = status ? statusMap[status.toLowerCase()] || status : 'unknown'\n\n    return {\n      success: true,\n      paymentId,\n      eventType: 'payment_request.completed',\n      status: normalizedStatus\n    }\n  }\n\n  async refundPayment(paymentId: string, amount?: number): Promise<RefundResponse> {\n    const apiKey = process.env.HITPAY_API_KEY\n    if (!apiKey) {\n      return { refundId: '', status: 'failed', error: 'Hitpay: HITPAY_API_KEY is required' }\n    }\n\n    const base = getBaseUrl()\n    const body: { payment_id: string; amount?: number } = { payment_id: paymentId }\n    if (amount != null && amount > 0) {\n      body.amount = amount\n    }\n\n    const res = await fetch(`${base}/v1/refund`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-BUSINESS-API-KEY': apiKey\n      },\n      body: JSON.stringify(body)\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      return {\n        refundId: '',\n        status: 'failed',\n        error: `Hitpay refund failed: ${res.status} ${text}`\n      }\n    }\n\n    const data = (await res.json()) as { id?: string; status?: string; amount_refunded?: number }\n    return {\n      refundId: data.id || '',\n      status: data.status || 'succeeded',\n      amountRefunded: data.amount_refunded\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1566, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/factory.ts"],"sourcesContent":["/**\n * Payment gateway factory\n * Returns the appropriate gateway implementation for the given provider.\n */\n\nimport type { PaymentGateway } from './types'\nimport { AirwallexGateway } from './airwallex'\nimport { HitpayGateway } from './hitpay'\n\nexport type GatewayName = 'AIRWALLEX' | 'HITPAY'\n\nexport function getPaymentGateway(gateway: GatewayName): PaymentGateway {\n  switch (gateway) {\n    case 'AIRWALLEX':\n      return new AirwallexGateway()\n    case 'HITPAY':\n      return new HitpayGateway()\n    default:\n      throw new Error(`Unsupported payment gateway: ${gateway}`)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAGD;AACA;;;AAIO,SAAS,kBAAkB,OAAoB;IACpD,OAAQ;QACN,KAAK;YACH,OAAO,IAAI,2MAAgB;QAC7B,KAAK;YACH,OAAO,IAAI,qMAAa;QAC1B;YACE,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,SAAS;IAC7D;AACF"}},
    {"offset": {"line": 1591, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/chinese-gateways.ts"],"sourcesContent":["/**\n * Enterprise Chinese Payment Gateway Integration\n * Multi-gateway system for Chinese market (CNY, Asia/Shanghai, PBOC compliance)\n *\n * Supported gateways:\n * - WeChat Pay () - QR code Native payments\n * - Alipay () - Page pay, mobile wallet\n * - UnionPay () - Bank card payments\n * - Bank Transfer () - B2B payments\n */\n\n/** Asia/Shanghai timezone for all Chinese payment timing */\nexport const CHINESE_TIMEZONE = 'Asia/Shanghai'\n\n/** Default currency for Chinese market -  */\nexport const CHINESE_CURRENCY = 'CNY'\n\n/** Country code for China */\nexport const CHINA_COUNTRY_CODE = 'CN'\n\n/** Performance targets (milliseconds) */\nexport const PERFORMANCE_TARGETS = {\n  PAYMENT_PROCESSING_MS: 2000,\n  QR_CODE_GENERATION_MS: 1000,\n  WEBHOOK_RESPONSE_MS: 500,\n} as const\n\n/** Chinese gateway types */\nexport type ChineseGatewayType = 'WECHAT_PAY' | 'ALIPAY' | 'UNIONPAY' | 'BANK_TRANSFER'\n\n/** UnionPay integration config (for future implementation) */\nexport const UNIONPAY_CONFIG = {\n  DOMAIN: process.env.UNIONPAY_DOMAIN || 'https://gateway.95516.com',\n  MERCHANT_ID: process.env.UNIONPAY_MERCHANT_ID,\n  CURRENCY: CHINESE_CURRENCY,\n  COUNTRY: CHINA_COUNTRY_CODE,\n} as const\n\n/** Bank transfer config for B2B payments */\nexport const BANK_TRANSFER_CONFIG = {\n  CURRENCY: CHINESE_CURRENCY,\n  SUPPORTED_BANKS: ['ICBC', 'CCB', 'ABC', 'BOC', 'CMB'] as const,\n  SETTLEMENT_DAYS: 1,\n} as const\n\n/**\n * Chinese error messages for payment failures (PBOC compliance, user-friendly)\n */\nexport const CHINESE_ERROR_MESSAGES: Record<string, string> = {\n  // WeChat Pay\n  WECHAT_PAY_INVALID_CONFIG: '',\n  WECHAT_PAY_SIGN_FAILED: '',\n  WECHAT_PAY_ORDER_FAILED: '',\n  WECHAT_PAY_QR_EXPIRED: '',\n  WECHAT_PAY_USER_CANCEL: '',\n\n  // Alipay\n  ALIPAY_INVALID_CONFIG: '',\n  ALIPAY_SIGN_FAILED: '',\n  ALIPAY_ORDER_FAILED: '',\n  ALIPAY_USER_CANCEL: '',\n\n  // UnionPay\n  UNIONPAY_INVALID_CONFIG: '',\n  UNIONPAY_ORDER_FAILED: '',\n\n  // Bank Transfer\n  BANK_TRANSFER_INVALID: '',\n  BANK_TRANSFER_PENDING: '',\n\n  // Generic\n  PAYMENT_TIMEOUT: '',\n  PAYMENT_AMOUNT_INVALID: '',\n  PAYMENT_NETWORK_ERROR: '',\n  PAYMENT_SYSTEM_ERROR: '',\n  FRAUD_DETECTION: '',\n  MFA_REQUIRED: '',\n}\n\n/**\n * Get Chinese error message by key, with fallback\n */\nexport function getChineseErrorMessage(key: string, fallback?: string): string {\n  return CHINESE_ERROR_MESSAGES[key] ?? fallback ?? CHINESE_ERROR_MESSAGES.PAYMENT_SYSTEM_ERROR\n}\n\n/**\n * Mobile wallet compatibility flags\n */\nexport interface MobileWalletSupport {\n  wechat: boolean\n  alipay: boolean\n  unionPay: boolean\n  applePay: boolean\n}\n\n/**\n * Chinese payment metadata for compliance\n */\nexport interface ChinesePaymentMetadata {\n  gateway: ChineseGatewayType\n  currency: typeof CHINESE_CURRENCY\n  timezone: typeof CHINESE_TIMEZONE\n  country: typeof CHINA_COUNTRY_CODE\n  /** PBOC transaction reference if applicable */\n  pbocRef?: string\n  /** Fraud detection score 0-100 */\n  fraudScore?: number\n  /** MFA required flag */\n  mfaRequired?: boolean\n}\n\n/**\n * Check if amount is valid for Chinese market (min 0.01 CNY)\n */\nexport function isValidChineseAmount(amount: number): boolean {\n  return typeof amount === 'number' && amount >= 0.01 && amount < 1_000_000\n}\n\n/**\n * Convert CNY to fen () for WeChat Pay API (integer)\n */\nexport function cnyToFen(cny: number): number {\n  return Math.round(cny * 100)\n}\n\n/**\n * Convert fen to CNY\n */\nexport function fenToCny(fen: number): number {\n  return fen / 100\n}\n\n/**\n * Format amount for Alipay (2 decimal places string)\n */\nexport function formatAlipayAmount(cny: number): string {\n  return cny.toFixed(2)\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC,GAED,0DAA0D;;;;;;;;;;;;;;;;;;;;;;;;;;AACnD,MAAM,mBAAmB;AAGzB,MAAM,mBAAmB;AAGzB,MAAM,qBAAqB;AAG3B,MAAM,sBAAsB;IACjC,uBAAuB;IACvB,uBAAuB;IACvB,qBAAqB;AACvB;AAMO,MAAM,kBAAkB;IAC7B,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI;IACvC,aAAa,QAAQ,GAAG,CAAC,oBAAoB;IAC7C,UAAU;IACV,SAAS;AACX;AAGO,MAAM,uBAAuB;IAClC,UAAU;IACV,iBAAiB;QAAC;QAAQ;QAAO;QAAO;QAAO;KAAM;IACrD,iBAAiB;AACnB;AAKO,MAAM,yBAAiD;IAC5D,aAAa;IACb,2BAA2B;IAC3B,wBAAwB;IACxB,yBAAyB;IACzB,uBAAuB;IACvB,wBAAwB;IAExB,SAAS;IACT,uBAAuB;IACvB,oBAAoB;IACpB,qBAAqB;IACrB,oBAAoB;IAEpB,WAAW;IACX,yBAAyB;IACzB,uBAAuB;IAEvB,gBAAgB;IAChB,uBAAuB;IACvB,uBAAuB;IAEvB,UAAU;IACV,iBAAiB;IACjB,wBAAwB;IACxB,uBAAuB;IACvB,sBAAsB;IACtB,iBAAiB;IACjB,cAAc;AAChB;AAKO,SAAS,uBAAuB,GAAW,EAAE,QAAiB;IACnE,OAAO,sBAAsB,CAAC,IAAI,IAAI,YAAY,uBAAuB,oBAAoB;AAC/F;AA+BO,SAAS,qBAAqB,MAAc;IACjD,OAAO,OAAO,WAAW,YAAY,UAAU,QAAQ,SAAS;AAClE;AAKO,SAAS,SAAS,GAAW;IAClC,OAAO,KAAK,KAAK,CAAC,MAAM;AAC1B;AAKO,SAAS,SAAS,GAAW;IAClC,OAAO,MAAM;AACf;AAKO,SAAS,mBAAmB,GAAW;IAC5C,OAAO,IAAI,OAAO,CAAC;AACrB"}},
    {"offset": {"line": 1696, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/wechat-pay-client.ts"],"sourcesContent":["/**\n * Enterprise WeChat Pay SDK - Native QR Code Payments\n * API v3: https://pay.weixin.qq.com/docs/merchant/apis/native-payment/native-prepay.html\n *\n * Features:\n * - QR code generation for in-app payments (<1s target)\n * - SHA256-RSA signing (PBOC compliant)\n * - CNY () currency, CN country\n * - Chinese error messages\n */\n\nimport crypto from 'crypto'\nimport type {\n  CreatePaymentRequest,\n  PaymentResponse,\n  PaymentGateway,\n  WebhookResult,\n  RefundResponse,\n} from './types'\nimport {\n  CHINESE_CURRENCY,\n  cnyToFen,\n  getChineseErrorMessage,\n  isValidChineseAmount,\n} from './chinese-gateways'\n\n/** WeChat Pay API v3 config */\nexport const WECHAT_PAY_CONFIG = {\n  APP_ID: process.env.WECHAT_APP_ID,\n  MCH_ID: process.env.WECHAT_MCH_ID,\n  DOMAIN: 'https://api.mch.weixin.qq.com',\n  SANDBOX_DOMAIN: 'https://api.mch.weixin.qq.com',\n  CURRENCY: 'CNY',\n  COUNTRY: 'CN',\n} as const\n\nfunction getWeChatPayDomain(): string {\n  const env = process.env.WECHAT_PAY_ENV || 'production'\n  return env === 'sandbox' ? WECHAT_PAY_CONFIG.SANDBOX_DOMAIN : WECHAT_PAY_CONFIG.DOMAIN\n}\n\nfunction getPrivateKey(): string {\n  const key = process.env.WECHAT_PAY_PRIVATE_KEY\n  if (!key) {\n    throw new Error(getChineseErrorMessage('WECHAT_PAY_INVALID_CONFIG'))\n  }\n  return key.replace(/\\\\n/g, '\\n')\n}\n\nfunction getApiV3Key(): string {\n  const key = process.env.WECHAT_PAY_API_V3_KEY\n  if (!key) {\n    throw new Error(getChineseErrorMessage('WECHAT_PAY_INVALID_CONFIG'))\n  }\n  return key\n}\n\n/**\n * Build WeChat Pay v3 Authorization header (WECHATPAY2-SHA256-RSA2048)\n */\nfunction buildAuthorization(\n  method: string,\n  url: string,\n  body: string,\n  privateKey: string\n): string {\n  const timestamp = Math.floor(Date.now() / 1000).toString()\n  const nonce = crypto.randomBytes(16).toString('hex')\n  const message = `${method}\\n${url}\\n${timestamp}\\n${nonce}\\n${body}\\n`\n  const sign = crypto.createSign('RSA-SHA256').update(message).sign(privateKey, 'base64')\n  return `WECHATPAY2-SHA256-RSA2048 mchid=\"${WECHAT_PAY_CONFIG.MCH_ID}\",nonce_str=\"${nonce}\",timestamp=\"${timestamp}\",signature=\"${sign}\"`\n}\n\n/**\n * Verify WeChat Pay webhook signature (RSA-SHA256 with platform certificate)\n * Set WECHAT_PAY_PLATFORM_PUBLIC_KEY for production verification\n */\nfunction verifyWebhookSignature(\n  body: string,\n  signature: string,\n  timestamp: string,\n  nonce: string\n): boolean {\n  const platformCert = process.env.WECHAT_PAY_PLATFORM_PUBLIC_KEY\n  if (!platformCert) {\n    return true\n  }\n  const publicKey = platformCert.replace(/\\\\n/g, '\\n')\n  const message = `${timestamp}\\n${nonce}\\n${body}\\n`\n  try {\n    return crypto.createVerify('RSA-SHA256').update(message).verify(publicKey, signature, 'base64')\n  } catch {\n    return false\n  }\n}\n\n/**\n * Decrypt WeChat Pay webhook resource (AES-256-GCM)\n */\nfunction decryptWebhookResource(ciphertext: string, nonce: string, associatedData: string): string {\n  const apiV3Key = getApiV3Key()\n  const key = Buffer.from(apiV3Key, 'utf8')\n  const iv = Buffer.from(nonce, 'utf8')\n  const authTag = Buffer.from(ciphertext.slice(-24), 'base64')\n  const data = Buffer.from(ciphertext.slice(0, -24), 'base64')\n  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv, { authTagLength: 16 })\n  decipher.setAuthTag(authTag)\n  decipher.setAAD(Buffer.from(associatedData, 'utf8'))\n  return decipher.update(data) + decipher.final('utf8')\n}\n\nexport class WeChatPayClient implements PaymentGateway {\n  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {\n    const appId = WECHAT_PAY_CONFIG.APP_ID\n    const mchId = WECHAT_PAY_CONFIG.MCH_ID\n    if (!appId || !mchId) {\n      throw new Error(getChineseErrorMessage('WECHAT_PAY_INVALID_CONFIG'))\n    }\n\n    const amount = request.amount\n    if (!isValidChineseAmount(amount)) {\n      throw new Error(getChineseErrorMessage('PAYMENT_AMOUNT_INVALID'))\n    }\n\n    const outTradeNo = `T${Date.now()}${Math.random().toString(36).slice(2, 9)}`\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || ''\n    const notifyUrl =\n      process.env.WECHAT_PAY_NOTIFY_URL || `${baseUrl}/api/payments/webhooks/wechat-pay`\n\n    const body = {\n      appid: appId,\n      mchid: mchId,\n      description: request.description.slice(0, 127),\n      out_trade_no: outTradeNo,\n      notify_url: notifyUrl,\n      amount: {\n        total: cnyToFen(amount),\n        currency: request.currency || CHINESE_CURRENCY,\n      },\n    }\n\n    const path = '/v3/pay/transactions/native'\n    const fullUrl = `${getWeChatPayDomain()}${path}`\n    const bodyStr = JSON.stringify(body)\n    const privateKey = getPrivateKey()\n    const auth = buildAuthorization('POST', path, bodyStr, privateKey)\n\n    const startTime = Date.now()\n    const res = await fetch(fullUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        'User-Agent': 'TutorMe-WeChatPay/1.0',\n        Authorization: auth,\n      },\n      body: bodyStr,\n    })\n\n    if (Date.now() - startTime > 2000) {\n      throw new Error(getChineseErrorMessage('PAYMENT_TIMEOUT'))\n    }\n\n    const data = (await res.json()) as {\n      code_url?: string\n      error_code?: string\n      errcode?: string\n      errmsg?: string\n    }\n\n    if (!res.ok || data.errcode || data.error_code) {\n      const errMsg = data.errmsg || data.errcode || `HTTP ${res.status}`\n      throw new Error(getChineseErrorMessage('WECHAT_PAY_ORDER_FAILED', errMsg))\n    }\n\n    const codeUrl = data.code_url\n    if (!codeUrl) {\n      throw new Error(getChineseErrorMessage('WECHAT_PAY_ORDER_FAILED'))\n    }\n\n    return {\n      paymentId: outTradeNo,\n      checkoutUrl: codeUrl,\n      status: 'CREATED',\n    }\n  }\n\n  verifyWebhook(payload: unknown, signature: string): boolean {\n    const headers = typeof payload === 'object' && payload !== null && 'headers' in payload\n      ? (payload as { headers: Record<string, string> }).headers\n      : null\n    const rawBody = typeof payload === 'object' && payload !== null && 'rawBody' in payload\n      ? (payload as { rawBody: string }).rawBody\n      : typeof payload === 'string'\n        ? payload\n        : JSON.stringify(payload)\n\n    const wechatSignature = headers?.['wechatpay-signature'] ?? signature\n    const timestamp = headers?.['wechatpay-timestamp'] ?? ''\n    const nonce = headers?.['wechatpay-nonce'] ?? ''\n\n    const sigMatch = wechatSignature.match(/timestamp=\"([^\"]+)\",nonce=\"([^\"]+)\",signature=\"([^\"]+)\"/)\n    if (!sigMatch) return false\n\n    const [, ts, n, sig] = sigMatch\n    return verifyWebhookSignature(rawBody, sig, ts, n)\n  }\n\n  async processWebhook(payload: unknown): Promise<WebhookResult> {\n    const body = payload as {\n      event_type?: string\n      resource?: {\n        ciphertext?: string\n        nonce?: string\n        associated_data?: string\n      }\n    }\n\n    const eventType = body?.event_type || 'unknown'\n    const resource = body?.resource\n    if (!resource?.ciphertext) {\n      return { success: false, eventType, error: getChineseErrorMessage('WECHAT_PAY_SIGN_FAILED') }\n    }\n\n    try {\n      const decrypted = decryptWebhookResource(\n        resource.ciphertext,\n        resource.nonce || '',\n        resource.associated_data || ''\n      )\n      const data = JSON.parse(decrypted) as {\n        out_trade_no?: string\n        trade_state?: string\n        transaction_id?: string\n      }\n\n      const paymentId = data.out_trade_no\n      const tradeState = data.trade_state\n\n      const statusMap: Record<string, string> = {\n        SUCCESS: 'completed',\n        REFUND: 'refunded',\n        NOTPAY: 'pending',\n        CLOSED: 'cancelled',\n        REVOKED: 'cancelled',\n        USERPAYING: 'processing',\n        PAYERROR: 'failed',\n      }\n      const status = tradeState ? statusMap[tradeState] || tradeState : 'unknown'\n\n      return {\n        success: true,\n        paymentId: paymentId || '',\n        eventType,\n        status,\n      }\n    } catch {\n      return { success: false, eventType, error: getChineseErrorMessage('WECHAT_PAY_SIGN_FAILED') }\n    }\n  }\n\n  async refundPayment(paymentId: string, amount?: number): Promise<RefundResponse> {\n    const mchId = WECHAT_PAY_CONFIG.MCH_ID\n    if (!mchId) {\n      return {\n        refundId: '',\n        status: 'failed',\n        error: getChineseErrorMessage('WECHAT_PAY_INVALID_CONFIG'),\n      }\n    }\n\n    const outRefundNo = `R${Date.now()}${Math.random().toString(36).slice(2, 9)}`\n    const body: Record<string, unknown> = {\n      out_trade_no: paymentId,\n      out_refund_no: outRefundNo,\n      reason: '',\n      amount: {\n        refund: amount != null ? cnyToFen(amount) : undefined,\n        total: amount != null ? cnyToFen(amount) : undefined,\n        currency: CHINESE_CURRENCY,\n      },\n    }\n\n    const path = '/v3/refund/domestic/refunds'\n    const fullUrl = `${getWeChatPayDomain()}${path}`\n    const bodyStr = JSON.stringify(body)\n    const privateKey = getPrivateKey()\n    const auth = buildAuthorization('POST', path, bodyStr, privateKey)\n\n    const res = await fetch(fullUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        Authorization: auth,\n      },\n      body: bodyStr,\n    })\n\n    const data = (await res.json()) as {\n      refund_id?: string\n      status?: string\n      errcode?: string\n      errmsg?: string\n    }\n\n    if (!res.ok || data.errcode) {\n      return {\n        refundId: '',\n        status: 'failed',\n        error: data.errmsg || getChineseErrorMessage('WECHAT_PAY_ORDER_FAILED'),\n      }\n    }\n\n    return {\n      refundId: data.refund_id || outRefundNo,\n      status: data.status || 'PROCESSING',\n      amountRefunded: amount,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1944, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/alipay-client.ts"],"sourcesContent":["/**\n * Enterprise Alipay SDK - Page Pay & Mobile Wallet\n * https://opendocs.alipay.com/open/270/105898\n *\n * Features:\n * - PC web page payment (alipay.trade.page.pay)\n * - CNY (), Asia/Shanghai timezone\n * - RSA2 (SHA256WithRSA) signing\n * - Chinese error messages\n */\n\nimport crypto from 'crypto'\nimport type {\n  CreatePaymentRequest,\n  PaymentResponse,\n  PaymentGateway,\n  WebhookResult,\n  RefundResponse,\n} from './types'\nimport {\n  CHINESE_CURRENCY,\n  CHINESE_TIMEZONE,\n  formatAlipayAmount,\n  getChineseErrorMessage,\n  isValidChineseAmount,\n} from './chinese-gateways'\n\n/** Alipay API config */\nexport const ALIPAY_CONFIG = {\n  APP_ID: process.env.ALIPAY_APP_ID,\n  DOMAIN: 'https://openapi.alipay.com',\n  SANDBOX_DOMAIN: 'https://openapi-sandbox.dl.alipaydev.com',\n  CURRENCY: CHINESE_CURRENCY,\n  TIMEZONE: CHINESE_TIMEZONE,\n} as const\n\nfunction getAlipayDomain(): string {\n  const env = process.env.ALIPAY_ENV || 'production'\n  return env === 'sandbox' ? ALIPAY_CONFIG.SANDBOX_DOMAIN : ALIPAY_CONFIG.DOMAIN\n}\n\nfunction getPrivateKey(): string {\n  const key = process.env.ALIPAY_PRIVATE_KEY\n  if (!key) {\n    throw new Error(getChineseErrorMessage('ALIPAY_INVALID_CONFIG'))\n  }\n  return key.replace(/\\\\n/g, '\\n')\n}\n\n/**\n * Build Alipay RSA2 signature\n */\nfunction sign(params: Record<string, string>, privateKey: string): string {\n  const sortedKeys = Object.keys(params).sort()\n  const signStr = sortedKeys\n    .filter((k) => params[k] !== '' && params[k] != null)\n    .map((k) => `${k}=${params[k]}`)\n    .join('&')\n  return crypto.createSign('RSA-SHA256').update(signStr).sign(privateKey, 'base64')\n}\n\n/**\n * Verify Alipay webhook/return signature\n */\nfunction verifySign(params: Record<string, string>, signature: string, publicKey: string): boolean {\n  const signType = params.sign_type || 'RSA2'\n  if (signType !== 'RSA2') return false\n  const sortedKeys = Object.keys(params)\n    .filter((k) => k !== 'sign' && k !== 'sign_type')\n    .sort()\n  const signStr = sortedKeys\n    .filter((k) => params[k] !== '' && params[k] != null)\n    .map((k) => `${k}=${params[k]}`)\n    .join('&')\n  try {\n    return crypto.createVerify('RSA-SHA256').update(signStr).verify(publicKey, signature, 'base64')\n  } catch {\n    return false\n  }\n}\n\nexport class AlipayClient implements PaymentGateway {\n  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {\n    const appId = ALIPAY_CONFIG.APP_ID\n    if (!appId) {\n      throw new Error(getChineseErrorMessage('ALIPAY_INVALID_CONFIG'))\n    }\n\n    const amount = request.amount\n    if (!isValidChineseAmount(amount)) {\n      throw new Error(getChineseErrorMessage('PAYMENT_AMOUNT_INVALID'))\n    }\n\n    const outTradeNo = `A${Date.now()}${Math.random().toString(36).slice(2, 9)}`\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || ''\n    const returnUrl = request.successUrl ?? `${baseUrl}/payment/success`\n    const notifyUrl =\n      process.env.ALIPAY_NOTIFY_URL || `${baseUrl}/api/payments/webhooks/alipay`\n\n    const bizContent = {\n      out_trade_no: outTradeNo,\n      total_amount: formatAlipayAmount(amount),\n      subject: request.description.slice(0, 256),\n      product_code: 'FAST_INSTANT_TRADE_PAY',\n    }\n\n    const params: Record<string, string> = {\n      app_id: appId,\n      method: 'alipay.trade.page.pay',\n      format: 'JSON',\n      charset: 'utf-8',\n      sign_type: 'RSA2',\n      timestamp: new Date().toISOString().replace(/\\\\.\\d{3}Z$/, 'Z'),\n      version: '1.0',\n      return_url: returnUrl,\n      notify_url: notifyUrl,\n      biz_content: JSON.stringify(bizContent),\n    }\n\n    const signature = sign(params, getPrivateKey())\n    params.sign = signature\n\n    const gateway = `${getAlipayDomain()}/gateway.do`\n    const query = Object.entries(params)\n      .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n      .join('&')\n    const checkoutUrl = `${gateway}?${query}`\n\n    return {\n      paymentId: outTradeNo,\n      checkoutUrl,\n      status: 'WAIT_BUYER_PAY',\n    }\n  }\n\n  verifyWebhook(payload: unknown, signature: string): boolean {\n    const params = (typeof payload === 'object' && payload !== null ? payload : {}) as Record<string, string>\n    const sig = params.sign ?? signature\n    const publicKey = process.env.ALIPAY_PUBLIC_KEY\n    if (!publicKey) return false\n    return verifySign(params, sig, publicKey.replace(/\\\\n/g, '\\n'))\n  }\n\n  async processWebhook(payload: unknown): Promise<WebhookResult> {\n    const body = payload as Record<string, string>\n    const tradeStatus = body.trade_status\n    const outTradeNo = body.out_trade_no\n\n    if (!outTradeNo) {\n      return { success: false, eventType: 'notify', error: getChineseErrorMessage('ALIPAY_SIGN_FAILED') }\n    }\n\n    const statusMap: Record<string, string> = {\n      WAIT_BUYER_PAY: 'pending',\n      TRADE_CLOSED: 'cancelled',\n      TRADE_SUCCESS: 'completed',\n      TRADE_FINISHED: 'completed',\n    }\n    const status = tradeStatus ? statusMap[tradeStatus] || tradeStatus : 'unknown'\n\n    return {\n      success: true,\n      paymentId: outTradeNo,\n      eventType: 'trade.notify',\n      status,\n    }\n  }\n\n  async refundPayment(paymentId: string, amount?: number): Promise<RefundResponse> {\n    const appId = ALIPAY_CONFIG.APP_ID\n    if (!appId) {\n      return {\n        refundId: '',\n        status: 'failed',\n        error: getChineseErrorMessage('ALIPAY_INVALID_CONFIG'),\n      }\n    }\n\n    const refundNo = `R${Date.now()}${Math.random().toString(36).slice(2, 9)}`\n    const bizContent: Record<string, string> = {\n      out_trade_no: paymentId,\n      refund_amount: amount != null ? formatAlipayAmount(amount) : '0',\n      out_request_no: refundNo,\n    }\n\n    const params: Record<string, string> = {\n      app_id: appId,\n      method: 'alipay.trade.refund',\n      format: 'JSON',\n      charset: 'utf-8',\n      sign_type: 'RSA2',\n      timestamp: new Date().toISOString().replace(/\\\\.\\d{3}Z$/, 'Z'),\n      version: '1.0',\n      biz_content: JSON.stringify(bizContent),\n    }\n\n    const signature = sign(params, getPrivateKey())\n    params.sign = signature\n\n    const gateway = `${getAlipayDomain()}/gateway.do`\n    const query = Object.entries(params)\n      .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n      .join('&')\n\n    const startTime = Date.now()\n    const res = await fetch(gateway, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: query,\n    })\n\n    if (Date.now() - startTime > 2000) {\n      return {\n        refundId: '',\n        status: 'failed',\n        error: getChineseErrorMessage('PAYMENT_TIMEOUT'),\n      }\n    }\n\n    const data = (await res.json()) as {\n      alipay_trade_refund_response?: { code?: string; msg?: string; sub_code?: string }\n    }\n    const resp = data.alipay_trade_refund_response\n    if (!resp || resp.code !== '10000') {\n      return {\n        refundId: '',\n        status: 'failed',\n        error: resp?.sub_code || resp?.msg || getChineseErrorMessage('ALIPAY_ORDER_FAILED'),\n      }\n    }\n\n    return {\n      refundId: refundNo,\n      status: 'completed',\n      amountRefunded: amount,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2140, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/payments/index.ts"],"sourcesContent":["export * from './types'\nexport { AirwallexGateway } from './airwallex'\nexport { HitpayGateway } from './hitpay'\nexport { getPaymentGateway, type GatewayName } from './factory'\nexport * from './chinese-gateways'\nexport { WeChatPayClient, WECHAT_PAY_CONFIG } from './wechat-pay-client'\nexport { AlipayClient, ALIPAY_CONFIG } from './alipay-client'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA"}},
    {"offset": {"line": 2159, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/api/classes/route.ts"],"sourcesContent":["/**\n * Classes API\n * GET /api/classes  list upcoming classes / my bookings (withAuth)\n * POST /api/classes  book a class (withAuth + CSRF)\n * DELETE /api/classes  cancel booking (withAuth + CSRF)\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport type { Session } from 'next-auth'\nimport { withAuth, requireCsrf, withRateLimitPreset } from '@/lib/api/middleware'\nimport { db } from '@/lib/db'\nimport { getPaymentGateway, type GatewayName } from '@/lib/payments'\n\nasync function getHandler(req: NextRequest, session: Session) {\n  try {\n    const { searchParams } = new URL(req.url)\n    const myBookings = searchParams.get('myBookings') === 'true'\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const subjectParam = searchParams.get('subject')?.trim() || null\n\n    let classes\n\n    if (myBookings) {\n      // Get classes the user has booked (optionally filtered by subject)\n      const bookingsWhere: { studentId: string; clinic?: { subject: { equals: string; mode: 'insensitive' } } } = {\n        studentId: session.user.id\n      }\n      if (subjectParam) {\n        bookingsWhere.clinic = { subject: { equals: subjectParam, mode: 'insensitive' } }\n      }\n      const bookings = await db.clinicBooking.findMany({\n        where: bookingsWhere,\n        include: {\n          payment: { select: { id: true, status: true, gatewayCheckoutUrl: true } },\n          clinic: {\n            include: {\n              tutor: {\n                select: {\n                  id: true,\n                  profile: {\n                    select: {\n                      name: true,\n                      avatarUrl: true,\n                      hourlyRate: true\n                    }\n                  }\n                }\n              },\n              _count: {\n                select: { bookings: true }\n              }\n            }\n          }\n        },\n        orderBy: {\n          clinic: { startTime: 'asc' }\n        },\n        take: limit\n      })\n\n      classes = bookings.map((booking: any) => {\n        const clinic = booking.clinic\n        const hourlyRate = clinic.tutor?.profile?.hourlyRate ?? 0\n        const price =\n          clinic.requiresPayment && hourlyRate > 0\n            ? Math.round(hourlyRate * (clinic.duration / 60) * 100) / 100\n            : null\n        const paymentStatus = booking.payment?.status ?? null\n        return {\n          ...clinic,\n          isBooked: true,\n          bookingId: booking.id,\n          currentBookings: clinic._count.bookings,\n          price,\n          requiresPayment: clinic.requiresPayment ?? false,\n          paymentStatus,\n          paymentCheckoutUrl: booking.payment?.gatewayCheckoutUrl ?? null\n        }\n      })\n    } else {\n      // Get upcoming classes (optionally filtered by subject)\n      const now = new Date()\n      const where: { startTime: { gte: Date }; status: { in: string[] }; subject?: { equals: string; mode: 'insensitive' } } = {\n        startTime: { gte: now },\n        status: { in: ['scheduled', 'live'] }\n      }\n      if (subjectParam) {\n        where.subject = { equals: subjectParam, mode: 'insensitive' }\n      }\n      classes = await db.clinic.findMany({\n        where,\n        include: {\n          tutor: {\n            select: {\n              id: true,\n              profile: {\n                select: {\n                  name: true,\n                  avatarUrl: true,\n                  hourlyRate: true\n                }\n              }\n            }\n          },\n          _count: {\n            select: { bookings: true }\n          },\n          bookings: {\n            where: { studentId: session.user.id },\n            select: { id: true }\n          }\n        },\n        orderBy: { startTime: 'asc' },\n        take: limit\n      })\n\n      classes = classes.map((cls: any) => {\n        const hourlyRate = cls.tutor?.profile?.hourlyRate ?? 0\n        const price =\n          cls.requiresPayment && hourlyRate > 0\n            ? Math.round(hourlyRate * (cls.duration / 60) * 100) / 100\n            : null\n        return {\n          ...cls,\n          isBooked: cls.bookings.length > 0,\n          currentBookings: cls._count.bookings,\n          price\n        }\n      })\n    }\n\n    return NextResponse.json({ classes })\n  } catch (error) {\n    console.error('Failed to fetch classes:', error)\n    return NextResponse.json({ error: 'Failed to fetch classes' }, { status: 500 })\n  }\n}\n\nasync function postHandler(req: NextRequest, session: Session) {\n  const csrfError = await requireCsrf(req)\n  if (csrfError) return csrfError\n\n  const { response: rateLimitResponse } = await withRateLimitPreset(req, 'booking')\n  if (rateLimitResponse) return rateLimitResponse\n\n  try {\n    const body = await req.json().catch(() => ({}))\n    const classId = typeof body.classId === 'string' ? body.classId.trim() : ''\n\n    if (!classId) {\n      return NextResponse.json({ error: 'Class ID required' }, { status: 400 })\n    }\n\n    // Check if class exists and has space\n    const classItem = await db.clinic.findUnique({\n      where: { id: classId },\n      include: {\n        tutor: {\n          include: {\n            profile: true\n          }\n        },\n        _count: {\n          select: { bookings: true }\n        }\n      }\n    })\n\n    if (!classItem) {\n      return NextResponse.json({ error: 'Class not found' }, { status: 404 })\n    }\n\n    if (classItem.status !== 'scheduled') {\n      return NextResponse.json({ error: 'Class is not open for booking' }, { status: 400 })\n    }\n\n    if (classItem._count.bookings >= classItem.maxStudents) {\n      return NextResponse.json({ error: 'Class is full' }, { status: 400 })\n    }\n\n    // Check if already booked\n    const existingBooking = await db.clinicBooking.findFirst({\n      where: {\n        clinicId: classId,\n        studentId: session.user.id\n      }\n    })\n\n    if (existingBooking) {\n      return NextResponse.json({ error: 'Already booked this class' }, { status: 400 })\n    }\n\n    const requiresPayment = Boolean(classItem.requiresPayment)\n\n    // Create booking\n    const booking = await db.clinicBooking.create({\n      data: {\n        clinicId: classId,\n        studentId: session.user.id,\n        requiresPayment\n      },\n      include: {\n        clinic: {\n          include: {\n            tutor: {\n              select: {\n                profile: {\n                  select: {\n                    name: true\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    })\n\n    if (!requiresPayment) {\n      return NextResponse.json({\n        success: true,\n        booking,\n        message: `Booked ${classItem.title} with ${booking.clinic.tutor.profile?.name || 'Tutor'}`\n      })\n    }\n\n    // Paid class: create payment and return checkout URL\n    const hourlyRate = classItem.tutor.profile?.hourlyRate ?? 0\n    if (hourlyRate <= 0) {\n      await db.clinicBooking.update({\n        where: { id: booking.id },\n        data: { requiresPayment: false }\n      })\n      return NextResponse.json({\n        success: true,\n        booking,\n        message: `Booked ${classItem.title} with ${booking.clinic.tutor.profile?.name || 'Tutor'}`\n      })\n    }\n\n    const durationHours = classItem.duration / 60\n    const amount = Math.round(hourlyRate * durationHours * 100) / 100\n    const tutorProfile = classItem.tutor.profile\n    const currency = (tutorProfile?.currency as string) || 'SGD'\n    const preferredGateway = tutorProfile?.paymentGatewayPreference\n    const gatewayName = (preferredGateway === 'AIRWALLEX' || preferredGateway === 'HITPAY'\n      ? preferredGateway\n      : (process.env.PAYMENT_DEFAULT_GATEWAY || 'HITPAY')) as GatewayName\n    const gateway = getPaymentGateway(gatewayName)\n    const studentEmail = (session.user as { email?: string }).email ?? ''\n\n    const paymentResponse = await gateway.createPayment({\n      amount,\n      currency,\n      bookingId: booking.id,\n      studentEmail: studentEmail || '',\n      description: `${classItem.title} - ${classItem.subject}`,\n      metadata: { clinicId: classItem.id, clinicTitle: classItem.title }\n    })\n\n    await db.payment.create({\n      data: {\n        bookingId: booking.id,\n        amount,\n        currency,\n        status: 'PENDING',\n        gateway: gatewayName,\n        gatewayPaymentId: paymentResponse.paymentId,\n        gatewayCheckoutUrl: paymentResponse.checkoutUrl\n      }\n    })\n\n    return NextResponse.json({\n      success: true,\n      requiresPayment: true,\n      booking,\n      checkoutUrl: paymentResponse.checkoutUrl,\n      message: 'Booking created. Complete payment to confirm your spot.',\n    })\n  } catch (error) {\n    console.error('Failed to book class:', error)\n    return NextResponse.json({ error: 'Failed to book class' }, { status: 500 })\n  }\n}\n\nasync function deleteHandler(req: NextRequest, session: Session) {\n  const csrfError = await requireCsrf(req)\n  if (csrfError) return csrfError\n\n  try {\n    const body = await req.json().catch(() => ({}))\n    const bookingId = typeof body.bookingId === 'string' ? body.bookingId.trim() : ''\n\n    if (!bookingId) {\n      return NextResponse.json({ error: 'Booking ID required' }, { status: 400 })\n    }\n\n    // Verify the booking belongs to this user\n    const booking = await db.clinicBooking.findFirst({\n      where: {\n        id: bookingId,\n        studentId: session.user.id\n      },\n      include: { clinic: true }\n    })\n\n    if (!booking) {\n      return NextResponse.json({ error: 'Booking not found' }, { status: 404 })\n    }\n\n    // Check if class is in the past\n    if (new Date(booking.clinic.startTime) < new Date()) {\n      return NextResponse.json({ error: 'Cannot cancel past class' }, { status: 400 })\n    }\n\n    await db.clinicBooking.delete({\n      where: { id: bookingId }\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: 'Booking cancelled',\n    })\n  } catch (error) {\n    console.error('Failed to cancel booking:', error)\n    return NextResponse.json({ error: 'Failed to cancel booking' }, { status: 500 })\n  }\n}\n\nexport const GET = withAuth(getHandler)\nexport const POST = withAuth(postHandler)\nexport const DELETE = withAuth(deleteHandler)\n"],"names":[],"mappings":"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"}}]
}