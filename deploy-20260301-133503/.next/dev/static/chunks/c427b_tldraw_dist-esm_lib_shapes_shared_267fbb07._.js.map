{
  "version": 3,
  "sources": [],
  "debugId": "a233c737-c152-d59a-3d0d-d836ff72ca89",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/PathBuilder.tsx"],"sourcesContent":["import {\n\tapproximately,\n\tassert,\n\tassertExists,\n\tclamp,\n\tCubicBezier2d,\n\tEdge2d,\n\texhaustiveSwitchError,\n\tGeometry2d,\n\tGeometry2dFilters,\n\tGeometry2dOptions,\n\tgetPerfectDashProps,\n\tgetVerticesCountForArcLength,\n\tGroup2d,\n\tmodulate,\n\tPerfectDashTerminal,\n\trng,\n\ttoDomPrecision,\n\tVec,\n\tVecLike,\n\tVecModel,\n} from '@tldraw/editor'\nimport { ReactNode, SVGProps } from 'react'\n\n/** @public */\nexport interface BasePathBuilderOpts {\n\tstrokeWidth: number\n\tforceSolid?: boolean\n\tonlyFilled?: boolean\n\tprops?: SVGProps<SVGPathElement & SVGGElement>\n}\n\n/** @public */\nexport interface SolidPathBuilderOpts extends BasePathBuilderOpts {\n\tstyle: 'solid'\n}\n\n/** @public */\nexport interface DashedPathBuilderOpts extends BasePathBuilderOpts {\n\tstyle: 'dashed' | 'dotted'\n\tsnap?: number\n\tend?: PerfectDashTerminal\n\tstart?: PerfectDashTerminal\n\tlengthRatio?: number\n}\n\n/** @public */\nexport interface DrawPathBuilderDOpts {\n\tstrokeWidth: number\n\trandomSeed: string\n\toffset?: number\n\troundness?: number\n\tpasses?: number\n\tonlyFilled?: boolean\n}\n\n/** @public */\nexport interface DrawPathBuilderOpts extends BasePathBuilderOpts, DrawPathBuilderDOpts {\n\tstyle: 'draw'\n}\n\n/** @public */\nexport type PathBuilderOpts = SolidPathBuilderOpts | DashedPathBuilderOpts | DrawPathBuilderOpts\n\n/** @public */\nexport interface PathBuilderCommandOpts {\n\t/**\n\t * When converting to a draw-style line, how much offset from the original point should be\n\t * applied?\n\t */\n\toffset?: number\n\t/**\n\t * When converting to a draw-style line, how much roundness should be applied to the end of this\n\t * line?\n\t */\n\troundness?: number\n\t/**\n\t * When converting to a dash- or dot-style line, should the current segment be merged with the\n\t * previous segment when calculating the dash pattern? This is false by default, meaning each\n\t * command will start/end on a dash/dot boundary.\n\t */\n\tmergeWithPrevious?: boolean\n}\n\n/** @internal */\nexport interface PathBuilderCommandInfo {\n\ttangentStart: VecModel\n\ttangentEnd: VecModel\n\tlength: number\n}\n\n/** @internal */\nexport interface PathBuilderCommandBase {\n\topts?: PathBuilderCommandOpts\n\tx: number\n\ty: number\n\tisClose: boolean\n\t_info?: PathBuilderCommandInfo\n}\n\n/** @public */\nexport interface PathBuilderLineOpts extends PathBuilderCommandOpts {\n\tgeometry?: Omit<Geometry2dOptions, 'isClosed'> | false\n\tdashStart?: PerfectDashTerminal\n\tdashEnd?: PerfectDashTerminal\n}\n\n/** @internal */\nexport interface MoveToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'move'\n\tcloseIdx: number | null\n\topts?: PathBuilderLineOpts\n}\n\n/** @internal */\nexport interface LineToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'line'\n}\n\n/** @internal */\nexport interface CubicBezierToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'cubic'\n\tcp1: VecModel\n\tcp2: VecModel\n\tresolution?: number\n}\n\n/** @internal */\nexport type PathBuilderCommand =\n\t| MoveToPathBuilderCommand\n\t| LineToPathBuilderCommand\n\t| CubicBezierToPathBuilderCommand\n\n/** @public */\nexport interface PathBuilderToDOpts {\n\tstartIdx?: number\n\tendIdx?: number\n\tonlyFilled?: boolean\n}\n\n/** @public */\nexport class PathBuilder {\n\tstatic lineThroughPoints(\n\t\tpoints: VecLike[],\n\t\topts?: PathBuilderLineOpts & { endOffsets?: number }\n\t) {\n\t\tconst path = new PathBuilder()\n\t\tpath.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset })\n\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\tconst isLast = i === points.length - 1\n\t\t\tpath.lineTo(points[i].x, points[i].y, isLast ? { offset: opts?.endOffsets } : undefined)\n\t\t}\n\t\treturn path\n\t}\n\n\tstatic cubicSplineThroughPoints(\n\t\tpoints: VecLike[],\n\t\topts?: PathBuilderLineOpts & { endOffsets?: number }\n\t) {\n\t\tconst path = new PathBuilder()\n\t\tconst len = points.length\n\t\tconst last = len - 2\n\t\tconst k = 1.25\n\n\t\tpath.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset })\n\n\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\tconst p0 = i === 0 ? points[0] : points[i - 1]\n\t\t\tconst p1 = points[i]\n\t\t\tconst p2 = points[i + 1]\n\t\t\tconst p3 = i === last ? p2 : points[i + 2]\n\n\t\t\tlet cp1x, cp1y, cp2x, cp2y\n\t\t\tif (i === 0) {\n\t\t\t\tcp1x = p0.x\n\t\t\t\tcp1y = p0.y\n\t\t\t} else {\n\t\t\t\tcp1x = p1.x + ((p2.x - p0.x) / 6) * k\n\t\t\t\tcp1y = p1.y + ((p2.y - p0.y) / 6) * k\n\t\t\t}\n\n\t\t\tlet pointOpts = undefined\n\t\t\tif (i === last) {\n\t\t\t\tcp2x = p2.x\n\t\t\t\tcp2y = p2.y\n\t\t\t\tpointOpts = { offset: opts?.endOffsets }\n\t\t\t} else {\n\t\t\t\tcp2x = p2.x - ((p3.x - p1.x) / 6) * k\n\t\t\t\tcp2y = p2.y - ((p3.y - p1.y) / 6) * k\n\t\t\t}\n\n\t\t\tpath.cubicBezierTo(p2.x, p2.y, cp1x, cp1y, cp2x, cp2y, pointOpts)\n\t\t}\n\n\t\treturn path\n\t}\n\n\tconstructor() {}\n\n\t/** @internal */\n\tcommands: PathBuilderCommand[] = []\n\n\tprivate lastMoveTo: MoveToPathBuilderCommand | null = null\n\tprivate assertHasMoveTo() {\n\t\tassert(this.lastMoveTo, 'Start an SVGPathBuilder with `.moveTo()`')\n\t\treturn this.lastMoveTo\n\t}\n\n\tmoveTo(x: number, y: number, opts?: PathBuilderLineOpts) {\n\t\tthis.lastMoveTo = { type: 'move', x, y, closeIdx: null, isClose: false, opts }\n\t\tthis.commands.push(this.lastMoveTo)\n\t\treturn this\n\t}\n\n\tlineTo(x: number, y: number, opts?: PathBuilderCommandOpts) {\n\t\tthis.assertHasMoveTo()\n\t\tthis.commands.push({ type: 'line', x, y, isClose: false, opts })\n\t\treturn this\n\t}\n\n\tcircularArcTo(\n\t\tradius: number,\n\t\tlargeArcFlag: boolean,\n\t\tsweepFlag: boolean,\n\t\tx2: number,\n\t\ty2: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\treturn this.arcTo(radius, radius, largeArcFlag, sweepFlag, 0, x2, y2, opts)\n\t}\n\n\tarcTo(\n\t\trx: number,\n\t\try: number,\n\t\tlargeArcFlag: boolean,\n\t\tsweepFlag: boolean,\n\t\txAxisRotationRadians: number,\n\t\tx2: number,\n\t\ty2: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\t// As arc flags make them very sensitive to offsets when we render them in draw mode, we\n\t\t// approximate arcs by converting them to up to 4 (1 per 90\u00B0 segment) cubic bezier curves.\n\t\t// This algorithm is a Claude special:\n\t\t// https://claude.ai/public/artifacts/5ea0bf18-4afb-4b3d-948d-31b8a77ef1e2\n\n\t\tthis.assertHasMoveTo()\n\n\t\tconst x1 = this.commands[this.commands.length - 1].x\n\t\tconst y1 = this.commands[this.commands.length - 1].y\n\n\t\t// If the endpoints are identical, don't add a command\n\t\tif (x1 === x2 && y1 === y2) {\n\t\t\treturn this\n\t\t}\n\n\t\t// If rx or ry is 0, return a straight line\n\t\tif (rx === 0 || ry === 0) {\n\t\t\treturn this.lineTo(x2, y2, opts)\n\t\t}\n\n\t\t// Convert angle from degrees to radians\n\t\tconst phi = xAxisRotationRadians\n\t\tconst sinPhi = Math.sin(phi)\n\t\tconst cosPhi = Math.cos(phi)\n\n\t\t// Ensure rx and ry are positive\n\t\tlet rx1 = Math.abs(rx)\n\t\tlet ry1 = Math.abs(ry)\n\n\t\t// Step 1: Compute (x1', y1') - transform from ellipse coordinate system to unit circle\n\t\tconst dx = (x1 - x2) / 2\n\t\tconst dy = (y1 - y2) / 2\n\t\tconst x1p = cosPhi * dx + sinPhi * dy\n\t\tconst y1p = -sinPhi * dx + cosPhi * dy\n\n\t\t// Correction of out-of-range radii\n\t\tconst lambda = (x1p * x1p) / (rx1 * rx1) + (y1p * y1p) / (ry1 * ry1)\n\t\tif (lambda > 1) {\n\t\t\tconst sqrtLambda = Math.sqrt(lambda)\n\t\t\trx1 *= sqrtLambda\n\t\t\try1 *= sqrtLambda\n\t\t}\n\n\t\t// Step 2: Compute (cx', cy') - center of ellipse in transformed system\n\t\tconst sign = largeArcFlag !== sweepFlag ? 1 : -1\n\n\t\tconst term = rx1 * rx1 * ry1 * ry1 - rx1 * rx1 * y1p * y1p - ry1 * ry1 * x1p * x1p\n\t\tconst numerator = rx1 * rx1 * y1p * y1p + ry1 * ry1 * x1p * x1p\n\n\t\tlet radicand = term / numerator\n\t\tradicand = radicand < 0 ? 0 : radicand\n\n\t\tconst coef = sign * Math.sqrt(radicand)\n\n\t\tconst cxp = coef * ((rx1 * y1p) / ry1)\n\t\tconst cyp = coef * (-(ry1 * x1p) / rx1)\n\n\t\t// Step 3: Compute (cx, cy) from (cx', cy') - transform back to original coordinate system\n\t\tconst cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2\n\t\tconst cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2\n\n\t\t// Step 4: Compute the start and end angles\n\t\tconst ux = (x1p - cxp) / rx1\n\t\tconst uy = (y1p - cyp) / ry1\n\t\tconst vx = (-x1p - cxp) / rx1\n\t\tconst vy = (-y1p - cyp) / ry1\n\n\t\tconst startAngle = Math.atan2(uy, ux)\n\t\tlet endAngle = Math.atan2(vy, vx)\n\n\t\t// Ensure correct sweep direction\n\t\tif (!sweepFlag && endAngle > startAngle) {\n\t\t\tendAngle -= 2 * Math.PI\n\t\t} else if (sweepFlag && endAngle < startAngle) {\n\t\t\tendAngle += 2 * Math.PI\n\t\t}\n\n\t\t// Calculate the sweep angle\n\t\tconst sweepAngle = endAngle - startAngle\n\n\t\t// Calculate the approximate arc length. General ellipse arc length is expensive - there's\n\t\t// no closed form solution, so we have to do iterative numerical approximation. As we only\n\t\t// use this to control the resolution of later approximations, let's cheat and just use the\n\t\t// circular arc length with the largest radius:\n\t\tconst approximateArcLength = Math.max(rx1, ry1) * Math.abs(sweepAngle)\n\n\t\t// Approximate the arc using cubic bezier curves\n\t\tconst numSegments = Math.min(4, Math.ceil(Math.abs(sweepAngle) / (Math.PI / 2)))\n\t\tconst resolutionPerSegment = Math.ceil(\n\t\t\tgetVerticesCountForArcLength(approximateArcLength) / numSegments\n\t\t)\n\t\tconst anglePerSegment = sweepAngle / numSegments\n\n\t\t// Helper function to compute point on ellipse\n\t\tconst ellipsePoint = (angle: number) => {\n\t\t\treturn {\n\t\t\t\tx: cx + rx1 * Math.cos(angle) * cosPhi - ry1 * Math.sin(angle) * sinPhi,\n\t\t\t\ty: cy + rx1 * Math.cos(angle) * sinPhi + ry1 * Math.sin(angle) * cosPhi,\n\t\t\t}\n\t\t}\n\n\t\t// Helper function to compute derivative (tangent vector) at a point on the ellipse\n\t\tconst ellipseDerivative = (angle: number) => {\n\t\t\treturn {\n\t\t\t\tx: -rx1 * Math.sin(angle) * cosPhi - ry1 * Math.cos(angle) * sinPhi,\n\t\t\t\ty: -rx1 * Math.sin(angle) * sinPhi + ry1 * Math.cos(angle) * cosPhi,\n\t\t\t}\n\t\t}\n\n\t\t// Generate cubic bezier approximations\n\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\tconst theta1 = startAngle + i * anglePerSegment\n\t\t\tconst theta2 = startAngle + (i + 1) * anglePerSegment\n\t\t\tconst deltaTheta = theta2 - theta1\n\n\t\t\tconst start = ellipsePoint(theta1)\n\t\t\tconst end = ellipsePoint(theta2)\n\n\t\t\t// Get the derivative at the start and end points\n\t\t\tconst d1 = ellipseDerivative(theta1)\n\t\t\tconst d2 = ellipseDerivative(theta2)\n\n\t\t\t// Calculate the length of the tangent handles\n\t\t\t// This is a key factor for the accuracy of the approximation\n\t\t\t// For a 90\u00B0 arc, the handle length should be 4/3 * tan(\u03C0/8) * r\n\t\t\t// For smaller arcs, we scale this value by the angle ratio\n\t\t\tconst handleScale = (4 / 3) * Math.tan(deltaTheta / 4)\n\n\t\t\t// Create control points that are tangent to the ellipse at the endpoints\n\t\t\tconst cp1x = start.x + handleScale * d1.x\n\t\t\tconst cp1y = start.y + handleScale * d1.y\n\n\t\t\tconst cp2x = end.x - handleScale * d2.x\n\t\t\tconst cp2y = end.y - handleScale * d2.y\n\n\t\t\tconst bezierOpts = i === 0 ? opts : { ...opts, mergeWithPrevious: true }\n\t\t\tthis.cubicBezierToWithResolution(\n\t\t\t\tend.x,\n\t\t\t\tend.y,\n\t\t\t\tcp1x,\n\t\t\t\tcp1y,\n\t\t\t\tcp2x,\n\t\t\t\tcp2y,\n\t\t\t\tbezierOpts,\n\t\t\t\tresolutionPerSegment\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\tcubicBezierTo(\n\t\tx: number,\n\t\ty: number,\n\t\tcp1X: number,\n\t\tcp1Y: number,\n\t\tcp2X: number,\n\t\tcp2Y: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\treturn this.cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts)\n\t}\n\tprivate cubicBezierToWithResolution(\n\t\tx: number,\n\t\ty: number,\n\t\tcp1X: number,\n\t\tcp1Y: number,\n\t\tcp2X: number,\n\t\tcp2Y: number,\n\t\topts?: PathBuilderCommandOpts,\n\t\tresolution?: number\n\t) {\n\t\tthis.assertHasMoveTo()\n\t\tthis.commands.push({\n\t\t\ttype: 'cubic',\n\t\t\tx,\n\t\t\ty,\n\t\t\tcp1: { x: cp1X, y: cp1Y },\n\t\t\tcp2: { x: cp2X, y: cp2Y },\n\t\t\tisClose: false,\n\t\t\topts,\n\t\t\tresolution,\n\t\t})\n\t\treturn this\n\t}\n\n\tclose() {\n\t\tconst lastMoveTo = this.assertHasMoveTo()\n\t\tconst lastCommand = this.commands[this.commands.length - 1]\n\n\t\tif (approximately(lastMoveTo.x, lastCommand.x) && approximately(lastMoveTo.y, lastCommand.y)) {\n\t\t\tlastCommand.isClose = true\n\t\t} else {\n\t\t\tthis.commands.push({\n\t\t\t\ttype: 'line',\n\t\t\t\tx: lastMoveTo.x,\n\t\t\t\ty: lastMoveTo.y,\n\t\t\t\tisClose: true,\n\t\t\t})\n\t\t}\n\n\t\tlastMoveTo.closeIdx = this.commands.length - 1\n\t\tthis.lastMoveTo = null\n\t\treturn this\n\t}\n\n\ttoD(opts: PathBuilderToDOpts = {}) {\n\t\tconst { startIdx = 0, endIdx = this.commands.length, onlyFilled = false } = opts\n\t\tconst parts = []\n\n\t\tlet isSkippingCurrentLine = false\n\n\t\tlet didAddMove = false\n\t\tlet didAddNaturalMove = false\n\n\t\tconst addMoveIfNeeded = (i: number) => {\n\t\t\tif (didAddMove || i === 0) return\n\t\t\tdidAddMove = true\n\t\t\tconst command = this.commands[i - 1]\n\t\t\tparts.push('M', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t}\n\n\t\tfor (let i = startIdx; i < endIdx; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tswitch (command.type) {\n\t\t\t\tcase 'move': {\n\t\t\t\t\tconst isFilled =\n\t\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\t\tif (onlyFilled && !isFilled) {\n\t\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\t\tdidAddMove = true\n\t\t\t\t\t\tdidAddNaturalMove = true\n\t\t\t\t\t\tparts.push('M', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'line':\n\t\t\t\t\tif (isSkippingCurrentLine) break\n\t\t\t\t\taddMoveIfNeeded(i)\n\t\t\t\t\tif (command.isClose && didAddNaturalMove) {\n\t\t\t\t\t\tparts.push('Z')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparts.push('L', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic':\n\t\t\t\t\tif (isSkippingCurrentLine) break\n\t\t\t\t\taddMoveIfNeeded(i)\n\t\t\t\t\tparts.push(\n\t\t\t\t\t\t'C',\n\t\t\t\t\t\ttoDomPrecision(command.cp1.x),\n\t\t\t\t\t\ttoDomPrecision(command.cp1.y),\n\t\t\t\t\t\ttoDomPrecision(command.cp2.x),\n\t\t\t\t\t\ttoDomPrecision(command.cp2.y),\n\t\t\t\t\t\ttoDomPrecision(command.x),\n\t\t\t\t\t\ttoDomPrecision(command.y)\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t}\n\t\t}\n\t\treturn parts.join(' ')\n\t}\n\n\ttoSvg(opts: PathBuilderOpts) {\n\t\tif (opts.forceSolid) {\n\t\t\treturn this.toSolidSvg(opts)\n\t\t}\n\t\tswitch (opts.style) {\n\t\t\tcase 'solid':\n\t\t\t\treturn this.toSolidSvg(opts)\n\t\t\tcase 'dashed':\n\t\t\tcase 'dotted':\n\t\t\t\treturn this.toDashedSvg(opts)\n\t\t\tcase 'draw': {\n\t\t\t\tconst d = this.toDrawSvg(opts)\n\t\t\t\treturn d\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(opts, 'style')\n\t\t}\n\t}\n\n\ttoPath2D(opts: PathBuilderOpts): Path2D {\n\t\tif (opts.forceSolid || opts.style === 'solid') {\n\t\t\treturn new Path2D(this.toD({ onlyFilled: opts.onlyFilled }))\n\t\t}\n\t\tif (opts.style === 'draw') {\n\t\t\treturn new Path2D(this.toDrawD(opts))\n\t\t}\n\n\t\treturn new Path2D(this.toD({ onlyFilled: opts.onlyFilled }))\n\t}\n\n\ttoGeometry(): PathBuilderGeometry2d | Group2d {\n\t\tconst geometries = []\n\n\t\tlet current: null | {\n\t\t\tstartIdx: number\n\t\t\tmoveCommand: MoveToPathBuilderCommand\n\t\t\tisClosed: boolean\n\t\t\topts?: PathBuilderLineOpts\n\t\t} = null\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\n\t\t\tif (command.type === 'move') {\n\t\t\t\tif (current && current.opts?.geometry !== false) {\n\t\t\t\t\tgeometries.push(\n\t\t\t\t\t\tnew PathBuilderGeometry2d(this, current.startIdx, i, {\n\t\t\t\t\t\t\t...current.opts?.geometry,\n\t\t\t\t\t\t\tisFilled: current.opts?.geometry?.isFilled ?? false,\n\t\t\t\t\t\t\tisClosed: current.moveCommand.closeIdx !== null,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tcurrent = { startIdx: i, moveCommand: command, opts: command.opts, isClosed: false }\n\t\t\t}\n\n\t\t\tif (command.isClose) {\n\t\t\t\tassert(current, 'No current move command')\n\t\t\t\tcurrent.isClosed = true\n\t\t\t}\n\t\t}\n\n\t\tif (current && current.opts?.geometry !== false) {\n\t\t\tgeometries.push(\n\t\t\t\tnew PathBuilderGeometry2d(this, current.startIdx, this.commands.length, {\n\t\t\t\t\t...current.opts?.geometry,\n\t\t\t\t\tisFilled: current.opts?.geometry?.isFilled ?? false,\n\t\t\t\t\tisClosed: current.moveCommand.closeIdx !== null,\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tassert(geometries.length > 0)\n\t\tif (geometries.length === 1) return geometries[0]\n\t\treturn new Group2d({ children: geometries })\n\t}\n\n\tprivate toSolidSvg(opts: PathBuilderOpts) {\n\t\tconst { strokeWidth, props } = opts\n\n\t\treturn (\n\t\t\t<path strokeWidth={strokeWidth} d={this.toD({ onlyFilled: opts.onlyFilled })} {...props} />\n\t\t)\n\t}\n\n\tprivate toDashedSvg(opts: DashedPathBuilderOpts) {\n\t\tconst {\n\t\t\tstyle,\n\t\t\tstrokeWidth,\n\t\t\tsnap,\n\t\t\tlengthRatio,\n\t\t\tprops: { markerStart, markerEnd, ...props } = {},\n\t\t} = opts\n\n\t\tconst parts: ReactNode[] = []\n\n\t\tlet isCurrentPathClosed = false\n\t\tlet isSkippingCurrentLine = false\n\t\tlet currentLineOpts: PathBuilderLineOpts | undefined = undefined\n\n\t\tlet currentRun: {\n\t\t\tstartIdx: number\n\t\t\tendIdx: number\n\t\t\tisFirst: boolean\n\t\t\tisLast: boolean\n\t\t\tlength: number\n\t\t\tlineOpts: PathBuilderLineOpts | undefined\n\t\t\tpathIsClosed: boolean\n\t\t} | null = null\n\n\t\tconst addCurrentRun = () => {\n\t\t\tif (!currentRun) return\n\t\t\tconst { startIdx, endIdx, isFirst, isLast, length, lineOpts, pathIsClosed } = currentRun\n\t\t\tcurrentRun = null\n\n\t\t\tif (startIdx === endIdx && this.commands[startIdx].type === 'move') return\n\n\t\t\tconst start = lineOpts?.dashStart ?? opts.start\n\t\t\tconst end = lineOpts?.dashEnd ?? opts.end\n\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(length, strokeWidth, {\n\t\t\t\tstyle,\n\t\t\t\tsnap,\n\t\t\t\tlengthRatio,\n\t\t\t\tstart: isFirst ? (start ?? (pathIsClosed ? 'outset' : 'none')) : 'outset',\n\t\t\t\tend: isLast ? (end ?? (pathIsClosed ? 'outset' : 'none')) : 'outset',\n\t\t\t})\n\n\t\t\tconst d = this.toD({ startIdx, endIdx: endIdx + 1 })\n\t\t\tparts.push(\n\t\t\t\t<path\n\t\t\t\t\tkey={parts.length}\n\t\t\t\t\td={d}\n\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\tmarkerStart={isFirst ? markerStart : undefined}\n\t\t\t\t\tmarkerEnd={isLast ? markerEnd : undefined}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tconst lastCommand = this.commands[i - 1]\n\t\t\tif (command.type === 'move') {\n\t\t\t\tisCurrentPathClosed = command.closeIdx !== null\n\t\t\t\tconst isFilled =\n\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\tif (opts.onlyFilled && !isFilled) {\n\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t} else {\n\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\tcurrentLineOpts = command.opts\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isSkippingCurrentLine) continue\n\n\t\t\tconst segmentLength = this.calculateSegmentLength(lastCommand, command)\n\t\t\tconst isFirst = lastCommand.type === 'move'\n\t\t\tconst isLast =\n\t\t\t\tcommand.isClose || i === this.commands.length - 1 || this.commands[i + 1]?.type === 'move'\n\n\t\t\tif (currentRun && command.opts?.mergeWithPrevious) {\n\t\t\t\tcurrentRun.length += segmentLength\n\t\t\t\tcurrentRun.endIdx = i\n\t\t\t\tcurrentRun.isLast = isLast\n\t\t\t} else {\n\t\t\t\taddCurrentRun()\n\t\t\t\tcurrentRun = {\n\t\t\t\t\tstartIdx: i,\n\t\t\t\t\tendIdx: i,\n\t\t\t\t\tisFirst,\n\t\t\t\t\tisLast,\n\t\t\t\t\tlength: segmentLength,\n\t\t\t\t\tlineOpts: currentLineOpts,\n\t\t\t\t\tpathIsClosed: isCurrentPathClosed,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taddCurrentRun()\n\n\t\treturn (\n\t\t\t<g strokeWidth={strokeWidth} {...props}>\n\t\t\t\t{parts}\n\t\t\t</g>\n\t\t)\n\t}\n\n\tprivate toDrawSvg(opts: DrawPathBuilderOpts) {\n\t\treturn <path strokeWidth={opts.strokeWidth} d={this.toDrawD(opts)} {...opts.props} />\n\t}\n\n\ttoDrawD(opts: DrawPathBuilderDOpts) {\n\t\tconst {\n\t\t\tstrokeWidth,\n\t\t\trandomSeed,\n\t\t\toffset: defaultOffset = strokeWidth / 3,\n\t\t\troundness: defaultRoundness = strokeWidth * 2,\n\t\t\tpasses = 2,\n\t\t\tonlyFilled = false,\n\t\t} = opts\n\n\t\tconst parts = []\n\n\t\tconst commandInfo = this.getCommandInfo()\n\n\t\t// for each command, we draw the line for the command, plus the corner to the next command.\n\t\tconst drawCommands = []\n\t\tlet lastMoveCommandIdx = null\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tconst offset = command.opts?.offset ?? defaultOffset\n\t\t\tconst roundness = command.opts?.roundness ?? defaultRoundness\n\n\t\t\tif (command.type === 'move') {\n\t\t\t\tlastMoveCommandIdx = i\n\t\t\t}\n\n\t\t\tconst nextIdx = command.isClose\n\t\t\t\t? assertExists(lastMoveCommandIdx) + 1\n\t\t\t\t: !this.commands[i + 1] || this.commands[i + 1].type === 'move'\n\t\t\t\t\t? undefined\n\t\t\t\t\t: i + 1\n\n\t\t\tconst nextInfo =\n\t\t\t\tnextIdx !== undefined && this.commands[nextIdx] && this.commands[nextIdx]?.type !== 'move'\n\t\t\t\t\t? commandInfo[nextIdx]\n\t\t\t\t\t: undefined\n\n\t\t\tconst currentSupportsRoundness = commandsSupportingRoundness[command.type]\n\t\t\tconst nextSupportsRoundness =\n\t\t\t\tnextIdx !== undefined ? commandsSupportingRoundness[this.commands[nextIdx].type] : false\n\n\t\t\tconst currentInfo = commandInfo[i]\n\n\t\t\tconst tangentToPrev = currentInfo?.tangentEnd\n\t\t\tconst tangentToNext = nextInfo?.tangentStart\n\n\t\t\tconst roundnessClampedForAngle =\n\t\t\t\tcurrentSupportsRoundness &&\n\t\t\t\tnextSupportsRoundness &&\n\t\t\t\ttangentToPrev &&\n\t\t\t\ttangentToNext &&\n\t\t\t\tVec.Len2(tangentToPrev) > 0.01 &&\n\t\t\t\tVec.Len2(tangentToNext) > 0.01\n\t\t\t\t\t? modulate(\n\t\t\t\t\t\t\tMath.abs(Vec.AngleBetween(tangentToPrev, tangentToNext)),\n\t\t\t\t\t\t\t[Math.PI / 2, Math.PI],\n\t\t\t\t\t\t\t[roundness, 0],\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)\n\t\t\t\t\t: 0\n\n\t\t\tconst shortestDistance = Math.min(\n\t\t\t\tcurrentInfo?.length ?? Infinity,\n\t\t\t\tnextInfo?.length ?? Infinity\n\t\t\t)\n\t\t\tconst offsetLimit = shortestDistance - roundnessClampedForAngle * 2\n\n\t\t\tconst offsetAmount = clamp(offset, 0, offsetLimit / 4)\n\n\t\t\tconst roundnessBeforeClampedForLength = Math.min(\n\t\t\t\troundnessClampedForAngle,\n\t\t\t\t(currentInfo?.length ?? Infinity) / 4\n\t\t\t)\n\t\t\tconst roundnessAfterClampedForLength = Math.min(\n\t\t\t\troundnessClampedForAngle,\n\t\t\t\t(nextInfo?.length ?? Infinity) / 4\n\t\t\t)\n\n\t\t\tconst drawCommand = {\n\t\t\t\tcommand,\n\t\t\t\toffsetAmount,\n\t\t\t\troundnessBefore: roundnessBeforeClampedForLength,\n\t\t\t\troundnessAfter: roundnessAfterClampedForLength,\n\t\t\t\ttangentToPrev: commandInfo[i]?.tangentEnd,\n\t\t\t\ttangentToNext: nextInfo?.tangentStart,\n\t\t\t\tmoveDidClose: false,\n\t\t\t}\n\n\t\t\tdrawCommands.push(drawCommand)\n\n\t\t\tif (command.isClose && lastMoveCommandIdx !== null) {\n\t\t\t\tconst lastMoveCommand = drawCommands[lastMoveCommandIdx]\n\t\t\t\tlastMoveCommand.moveDidClose = true\n\t\t\t\tlastMoveCommand.roundnessAfter = roundnessAfterClampedForLength\n\t\t\t} else if (command.type === 'move') {\n\t\t\t\tlastMoveCommandIdx = i\n\t\t\t}\n\t\t}\n\n\t\tfor (let pass = 0; pass < passes; pass++) {\n\t\t\tconst random = rng(randomSeed + pass)\n\n\t\t\tlet lastMoveToOffset = { x: 0, y: 0 }\n\t\t\tlet isSkippingCurrentLine = false\n\t\t\tfor (const {\n\t\t\t\tcommand,\n\t\t\t\toffsetAmount,\n\t\t\t\troundnessBefore,\n\t\t\t\troundnessAfter,\n\t\t\t\ttangentToNext,\n\t\t\t\ttangentToPrev,\n\t\t\t} of drawCommands) {\n\t\t\t\tconst offset = command.isClose\n\t\t\t\t\t? lastMoveToOffset\n\t\t\t\t\t: { x: random() * offsetAmount, y: random() * offsetAmount }\n\n\t\t\t\tif (command.type === 'move') {\n\t\t\t\t\tlastMoveToOffset = offset\n\t\t\t\t\tconst isFilled =\n\t\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\t\tif (onlyFilled && !isFilled) {\n\t\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSkippingCurrentLine) continue\n\n\t\t\t\tconst offsetPoint = Vec.Add(command, offset)\n\n\t\t\t\tconst endPoint =\n\t\t\t\t\ttangentToNext && roundnessAfter > 0\n\t\t\t\t\t\t? Vec.Mul(tangentToNext, -roundnessAfter).add(offsetPoint)\n\t\t\t\t\t\t: offsetPoint\n\n\t\t\t\tconst startPoint =\n\t\t\t\t\ttangentToPrev && roundnessBefore > 0\n\t\t\t\t\t\t? Vec.Mul(tangentToPrev, roundnessBefore).add(offsetPoint)\n\t\t\t\t\t\t: offsetPoint\n\n\t\t\t\tif (endPoint === offsetPoint || startPoint === offsetPoint) {\n\t\t\t\t\tswitch (command.type) {\n\t\t\t\t\t\tcase 'move':\n\t\t\t\t\t\t\tparts.push('M', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t\tparts.push('L', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'cubic': {\n\t\t\t\t\t\t\tconst offsetCp1 = Vec.Add(command.cp1, offset)\n\t\t\t\t\t\t\tconst offsetCp2 = Vec.Add(command.cp2, offset)\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (command.type) {\n\t\t\t\t\t\tcase 'move':\n\t\t\t\t\t\t\tparts.push('M', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'L',\n\t\t\t\t\t\t\t\ttoDomPrecision(startPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(startPoint.y),\n\n\t\t\t\t\t\t\t\t'Q',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'cubic': {\n\t\t\t\t\t\t\tconst offsetCp1 = Vec.Add(command.cp1, offset)\n\t\t\t\t\t\t\tconst offsetCp2 = Vec.Add(command.cp2, offset)\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parts.join(' ')\n\t}\n\n\tprivate calculateSegmentLength(lastPoint: VecLike, command: PathBuilderCommand) {\n\t\tswitch (command.type) {\n\t\t\tcase 'move':\n\t\t\t\treturn 0\n\t\t\tcase 'line':\n\t\t\t\treturn Vec.Dist(lastPoint, command)\n\t\t\tcase 'cubic':\n\t\t\t\treturn CubicBezier.length(\n\t\t\t\t\tlastPoint.x,\n\t\t\t\t\tlastPoint.y,\n\t\t\t\t\tcommand.cp1.x,\n\t\t\t\t\tcommand.cp1.y,\n\t\t\t\t\tcommand.cp2.x,\n\t\t\t\t\tcommand.cp2.y,\n\t\t\t\t\tcommand.x,\n\t\t\t\t\tcommand.y\n\t\t\t\t)\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t}\n\t}\n\n\t/** @internal */\n\tgetCommands(): readonly PathBuilderCommand[] {\n\t\treturn this.commands\n\t}\n\n\t/** @internal */\n\tgetCommandInfo() {\n\t\tconst commandInfo: Array<undefined | PathBuilderCommandInfo> = []\n\t\tfor (let i = 1; i < this.commands.length; i++) {\n\t\t\tconst previous = this.commands[i - 1]\n\t\t\tconst current = this.commands[i]\n\n\t\t\tif (current._info) {\n\t\t\t\tcommandInfo[i] = current._info\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (current.type === 'move') {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet tangentStart, tangentEnd\n\t\t\tswitch (current.type) {\n\t\t\t\tcase 'line':\n\t\t\t\t\ttangentStart = tangentEnd = Vec.Sub(previous, current).uni()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic': {\n\t\t\t\t\ttangentStart = Vec.Sub(current.cp1, previous).uni()\n\t\t\t\t\ttangentEnd = Vec.Sub(current.cp2, current).uni()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(current, 'type')\n\t\t\t}\n\n\t\t\tcurrent._info = {\n\t\t\t\ttangentStart,\n\t\t\t\ttangentEnd,\n\t\t\t\tlength: this.calculateSegmentLength(previous, current),\n\t\t\t}\n\t\t\tcommandInfo[i] = current._info\n\t\t}\n\n\t\treturn commandInfo\n\t}\n}\n\nconst commandsSupportingRoundness = {\n\tline: true,\n\tmove: true,\n\tcubic: false,\n} as const satisfies Record<PathBuilderCommand['type'], boolean>\n\n/** @public */\nexport class PathBuilderGeometry2d extends Geometry2d {\n\tconstructor(\n\t\tprivate readonly path: PathBuilder,\n\t\tprivate readonly startIdx: number,\n\t\tprivate readonly endIdx: number,\n\t\toptions: Geometry2dOptions\n\t) {\n\t\tsuper(options)\n\t}\n\n\tprivate _segments: Geometry2d[] | null = null\n\tgetSegments() {\n\t\tif (this._segments) return this._segments\n\n\t\tthis._segments = []\n\t\tlet last = this.path.commands[this.startIdx]\n\t\tassert(last.type === 'move')\n\n\t\tfor (let i = this.startIdx + 1; i < this.endIdx; i++) {\n\t\t\tconst command = this.path.commands[i]\n\t\t\tassert(command.type !== 'move')\n\n\t\t\tswitch (command.type) {\n\t\t\t\tcase 'line':\n\t\t\t\t\tthis._segments.push(new Edge2d({ start: Vec.From(last), end: Vec.From(command) }))\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic': {\n\t\t\t\t\tthis._segments.push(\n\t\t\t\t\t\tnew CubicBezier2d({\n\t\t\t\t\t\t\tstart: Vec.From(last),\n\t\t\t\t\t\t\tcp1: Vec.From(command.cp1),\n\t\t\t\t\t\t\tcp2: Vec.From(command.cp2),\n\t\t\t\t\t\t\tend: Vec.From(command),\n\t\t\t\t\t\t\tresolution: command.resolution,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t}\n\n\t\t\tlast = command\n\t\t}\n\n\t\treturn this._segments\n\t}\n\n\toverride getVertices(filters: Geometry2dFilters): Vec[] {\n\t\tconst vs = this.getSegments()\n\t\t\t.flatMap((s) => s.getVertices(filters))\n\t\t\t.filter((vertex, i, vertices) => {\n\t\t\t\tconst prev = vertices[i - 1]\n\t\t\t\tif (!prev) return true\n\t\t\t\treturn !Vec.Equals(prev, vertex)\n\t\t\t})\n\n\t\tif (this.isClosed) {\n\t\t\tconst last = vs[vs.length - 1]\n\t\t\tconst first = vs[0]\n\t\t\tif (!Vec.Equals(last, first)) {\n\t\t\t\tvs.push(first)\n\t\t\t}\n\t\t}\n\n\t\treturn vs\n\t}\n\n\toverride nearestPoint(point: VecLike, _filters?: Geometry2dFilters): Vec {\n\t\tlet nearest: Vec | null = null\n\t\tlet nearestDistance = Infinity\n\n\t\tfor (const segment of this.getSegments()) {\n\t\t\tconst candidate = segment.nearestPoint(point)\n\t\t\tconst distance = Vec.Dist2(point, candidate)\n\t\t\tif (distance < nearestDistance) {\n\t\t\t\tnearestDistance = distance\n\t\t\t\tnearest = candidate\n\t\t\t}\n\t\t}\n\n\t\tassert(nearest, 'No nearest point found')\n\t\treturn nearest\n\t}\n\n\toverride hitTestLineSegment(\n\t\tA: VecLike,\n\t\tB: VecLike,\n\t\tdistance = 0,\n\t\tfilters?: Geometry2dFilters\n\t): boolean {\n\t\treturn super.hitTestLineSegment(A, B, distance, filters)\n\t}\n\toverride getSvgPathData(): string {\n\t\treturn this.path.toD({ startIdx: this.startIdx, endIdx: this.endIdx })\n\t}\n}\n\n/*!\n * Adapted from https://github.com/adobe-webplatform/Snap.svg/tree/master\n * Apache License: https://github.com/adobe-webplatform/Snap.svg/blob/master/LICENSE\n * https://github.com/adobe-webplatform/Snap.svg/blob/c8e483c9694517e24b282f8f59f985629f4994ce/dist/snap.svg.js#L5786\n */\nconst CubicBezier = {\n\tbase3(t: number, p1: number, p2: number, p3: number, p4: number) {\n\t\tconst t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4\n\t\tconst t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3\n\t\treturn t * t2 - 3 * p1 + 3 * p2\n\t},\n\t/**\n\t * Calculate the approximate length of a cubic bezier curve from (x1, y1) to (x4, y4) with\n\t * control points (x2, y2) and (x3, y3).\n\t */\n\tlength(\n\t\tx1: number,\n\t\ty1: number,\n\t\tx2: number,\n\t\ty2: number,\n\t\tx3: number,\n\t\ty3: number,\n\t\tx4: number,\n\t\ty4: number,\n\t\tz = 1\n\t) {\n\t\tz = z > 1 ? 1 : z < 0 ? 0 : z\n\t\tconst z2 = z / 2\n\t\tconst n = 12\n\n\t\tlet sum = 0\n\t\tsum = 0\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst ct = z2 * CubicBezier.Tvalues[i] + z2\n\t\t\tconst xbase = CubicBezier.base3(ct, x1, x2, x3, x4)\n\t\t\tconst ybase = CubicBezier.base3(ct, y1, y2, y3, y4)\n\t\t\tconst comb = xbase * xbase + ybase * ybase\n\t\t\tsum += CubicBezier.Cvalues[i] * Math.sqrt(comb)\n\t\t}\n\t\treturn z2 * sum\n\t},\n\tTvalues: [\n\t\t-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816,\n\t\t0.9816,\n\t],\n\tCvalues: [\n\t\t0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472,\n\t],\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/usePrefersReducedMotion.tsx"],"sourcesContent":["import { useMaybeEditor, useValue } from '@tldraw/editor'\nimport { useEffect, useState } from 'react'\n\n/** @public */\nexport function usePrefersReducedMotion() {\n\tconst editor = useMaybeEditor()\n\tconst animationSpeed = useValue('animationSpeed', () => editor?.user.getAnimationSpeed(), [\n\t\teditor,\n\t])\n\tconst [prefersReducedMotion, setPrefersReducedMotion] = useState(false)\n\n\tuseEffect(() => {\n\t\tif (animationSpeed !== undefined) {\n\t\t\tsetPrefersReducedMotion(animationSpeed === 0 ? true : false)\n\t\t\treturn\n\t\t}\n\n\t\tif (typeof window === 'undefined' || !('matchMedia' in window)) return\n\t\tconst mql = window.matchMedia('(prefers-reduced-motion: reduce)')\n\t\tconst handler = () => {\n\t\t\tsetPrefersReducedMotion(mql.matches)\n\t\t}\n\t\thandler()\n\t\tmql.addEventListener('change', handler)\n\t\treturn () => mql.removeEventListener('change', handler)\n\t}, [animationSpeed])\n\n\treturn prefersReducedMotion\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,gBAAgB,gBAAgB;AACzC,SAAS,WAAW,gBAAgB;;;AAG7B,SAAS,0BAA0B;IACzC,MAAM,aAAS,sPAAA,CAAe;IAC9B,MAAM,qBAAiB,oOAAA,EAAS;4DAAkB,IAAM,QAAQ,KAAK,kBAAkB;2DAAG;QACzF;KACA;IACD,MAAM,CAAC,sBAAsB,uBAAuB,CAAA,OAAI,2NAAA,EAAS,KAAK;IAEtE,IAAA,4NAAA;6CAAU,MAAM;YACf,IAAI,mBAAmB,KAAA,GAAW;gBACjC,wBAAwB,mBAAmB,IAAI,OAAO,KAAK;gBAC3D;YACD;YAEA,IAAI,OAAO,WAAW,eAAe,CAAA,CAAE,gBAAgB,MAAA,EAAS,CAAA;YAChE,MAAM,MAAM,OAAO,UAAA,CAAW,kCAAkC;YAChE,MAAM;6DAAU,MAAM;oBACrB,wBAAwB,IAAI,OAAO;gBACpC;;YACA,QAAQ;YACR,IAAI,gBAAA,CAAiB,UAAU,OAAO;YACtC;qDAAO,IAAM,IAAI,mBAAA,CAAoB,UAAU,OAAO;;QACvD;4CAAG;QAAC,cAAc;KAAC;IAEnB,OAAO;AACR"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useDefaultColorTheme.ts"],"sourcesContent":["import { getDefaultColorTheme, useIsDarkMode } from '@tldraw/editor'\n\n/** @public */\nexport function useDefaultColorTheme() {\n\treturn getDefaultColorTheme({ isDarkMode: useIsDarkMode() })\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,sBAAsB,qBAAqB;;AAG7C,SAAS,uBAAuB;IACtC,WAAO,0OAAA,EAAqB;QAAE,gBAAY,yPAAA,CAAc;IAAE,CAAC;AAC5D"}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/crop.ts"],"sourcesContent":["import {\n\tBox,\n\tShapeWithCrop,\n\tTLCropInfo,\n\tTLImageShape,\n\tTLShapeCrop,\n\tTLShapeId,\n\tVec,\n\tclamp,\n\tisEqual,\n} from '@tldraw/editor'\n\n/** @internal */\nexport const MIN_CROP_SIZE = 8\n\n/** @public */\nexport interface CropBoxOptions {\n\tminWidth?: number\n\tminHeight?: number\n}\n\n/** @public */\nexport function getDefaultCrop(): TLShapeCrop {\n\treturn {\n\t\ttopLeft: { x: 0, y: 0 },\n\t\tbottomRight: { x: 1, y: 1 },\n\t}\n}\n\n/** @public */\nexport type ASPECT_RATIO_OPTION =\n\t| 'original'\n\t| 'square'\n\t| 'circle'\n\t| 'landscape'\n\t| 'portrait'\n\t| 'wide'\n\n/** @public */\nexport const ASPECT_RATIO_OPTIONS: ASPECT_RATIO_OPTION[] = [\n\t'original',\n\t'square',\n\t'circle',\n\t'landscape',\n\t'portrait',\n\t'wide',\n]\n\n/** @public */\nexport const ASPECT_RATIO_TO_VALUE: Record<ASPECT_RATIO_OPTION, number> = {\n\toriginal: 0,\n\tsquare: 1,\n\tcircle: 1,\n\tlandscape: 4 / 3,\n\tportrait: 3 / 4,\n\twide: 16 / 9,\n}\n\n/**\n * Original (uncropped) width and height of shape.\n *\n * @public\n */\nexport function getUncroppedSize(\n\tshapeSize: { w: number; h: number },\n\tcrop: TLShapeCrop | null\n): { w: number; h: number } {\n\tif (!crop) return { w: shapeSize.w, h: shapeSize.h }\n\tconst w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x)\n\tconst h = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y)\n\treturn { w, h }\n}\n\n// Utility function to get crop dimensions\nfunction getCropDimensions(crop: TLShapeCrop) {\n\treturn {\n\t\twidth: crop.bottomRight.x - crop.topLeft.x,\n\t\theight: crop.bottomRight.y - crop.topLeft.y,\n\t}\n}\n\n// Utility function to get crop center\nfunction getCropCenter(crop: TLShapeCrop) {\n\tconst { width, height } = getCropDimensions(crop)\n\treturn {\n\t\tx: crop.topLeft.x + width / 2,\n\t\ty: crop.topLeft.y + height / 2,\n\t}\n}\n\n// Utility function to create crop with specified dimensions centered on given point\nfunction createCropAroundCenter(\n\tcenterX: number,\n\tcenterY: number,\n\twidth: number,\n\theight: number,\n\tisCircle?: boolean\n) {\n\tconst topLeftX = Math.max(0, Math.min(1 - width, centerX - width / 2))\n\tconst topLeftY = Math.max(0, Math.min(1 - height, centerY - height / 2))\n\n\treturn {\n\t\ttopLeft: { x: topLeftX, y: topLeftY },\n\t\tbottomRight: { x: topLeftX + width, y: topLeftY + height },\n\t\tisCircle,\n\t}\n}\n\n/** @public */\nexport function getCropBox<T extends ShapeWithCrop>(\n\tshape: T,\n\tinfo: TLCropInfo<T>,\n\topts = {} as CropBoxOptions\n):\n\t| {\n\t\t\tid: TLShapeId\n\t\t\ttype: T['type']\n\t\t\tx: number\n\t\t\ty: number\n\t\t\tprops: ShapeWithCrop['props']\n\t  }\n\t| undefined {\n\tconst { handle, change, crop, aspectRatioLocked } = info\n\tconst { w, h } = info.uncroppedSize\n\tconst { minWidth = MIN_CROP_SIZE, minHeight = MIN_CROP_SIZE } = opts\n\n\tif (w < minWidth || h < minHeight || (change.x === 0 && change.y === 0)) {\n\t\treturn\n\t}\n\n\t// Lets get a box here in pixel space. For simplicity, we'll do all the math in\n\t// pixel space, then convert to normalized space at the end.\n\tconst prevCropBox = new Box(\n\t\tcrop.topLeft.x * w,\n\t\tcrop.topLeft.y * h,\n\t\t(crop.bottomRight.x - crop.topLeft.x) * w,\n\t\t(crop.bottomRight.y - crop.topLeft.y) * h\n\t)\n\n\tconst targetRatio = prevCropBox.aspectRatio\n\tconst tempBox = prevCropBox.clone()\n\n\t// Basic resizing logic based on the handles\n\n\tif (handle === 'top_left' || handle === 'bottom_left' || handle === 'left') {\n\t\ttempBox.x = clamp(tempBox.x + change.x, 0, prevCropBox.maxX - minWidth)\n\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t} else if (handle === 'top_right' || handle === 'bottom_right' || handle === 'right') {\n\t\tconst tempRight = clamp(tempBox.maxX + change.x, prevCropBox.x + minWidth, w)\n\t\ttempBox.w = tempRight - tempBox.x\n\t}\n\n\tif (handle === 'top_left' || handle === 'top_right' || handle === 'top') {\n\t\ttempBox.y = clamp(tempBox.y + change.y, 0, prevCropBox.maxY - minHeight)\n\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t} else if (handle === 'bottom_left' || handle === 'bottom_right' || handle === 'bottom') {\n\t\tconst tempBottom = clamp(tempBox.maxY + change.y, prevCropBox.y + minHeight, h)\n\t\ttempBox.h = tempBottom - tempBox.y\n\t}\n\n\t// Aspect ratio locked resizing logic\n\n\tif (aspectRatioLocked) {\n\t\tconst isXLimiting = tempBox.aspectRatio > targetRatio\n\n\t\tif (isXLimiting) {\n\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t} else {\n\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t}\n\n\t\tswitch (handle) {\n\t\t\tcase 'top_left': {\n\t\t\t\t// preserve the bottom right corner\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top_right': {\n\t\t\t\t// preserve the bottom left corner\n\t\t\t\ttempBox.x = prevCropBox.x\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\ttempBox.w = w - prevCropBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom_left': {\n\t\t\t\t// preserve the top right corner\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\ttempBox.y = prevCropBox.y\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\ttempBox.h = h - prevCropBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom_right': {\n\t\t\t\t// preserve the top left corner\n\t\t\t\ttempBox.x = prevCropBox.x\n\t\t\t\ttempBox.y = prevCropBox.y\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\ttempBox.w = w - prevCropBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\ttempBox.h = h - prevCropBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top': {\n\t\t\t\t// preserve the bottom edge center\n\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\ttempBox.x -= (tempBox.w - prevCropBox.w) / 2\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\tconst leftSide = prevCropBox.midX\n\t\t\t\t\ttempBox.w = leftSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\tconst rightSide = w - prevCropBox.midX\n\t\t\t\t\ttempBox.w = rightSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = w - tempBox.w\n\t\t\t\t}\n\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'right': {\n\t\t\t\t// preserve the left edge center\n\t\t\t\ttempBox.w = tempBox.maxX - prevCropBox.x\n\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\ttempBox.y -= (tempBox.h - prevCropBox.h) / 2\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\tconst topSide = prevCropBox.midY\n\t\t\t\t\ttempBox.h = topSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\tconst bottomSide = h - prevCropBox.midY\n\t\t\t\t\ttempBox.h = bottomSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = h - tempBox.h\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom': {\n\t\t\t\t// preserve the top edge center\n\t\t\t\ttempBox.h = tempBox.maxY - prevCropBox.y\n\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\ttempBox.x -= (tempBox.w - prevCropBox.w) / 2\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\tconst leftSide = prevCropBox.midX\n\t\t\t\t\ttempBox.w = leftSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\tconst rightSide = w - prevCropBox.midX\n\t\t\t\t\ttempBox.w = rightSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = w - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'left': {\n\t\t\t\t// preserve the right edge center\n\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\ttempBox.y -= (tempBox.h - prevCropBox.h) / 2\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\tconst topSide = prevCropBox.midY\n\t\t\t\t\ttempBox.h = topSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\tconst bottomSide = h - prevCropBox.midY\n\t\t\t\t\ttempBox.h = bottomSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = h - tempBox.h\n\t\t\t\t}\n\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert the box back to normalized space\n\tconst newCrop: TLShapeCrop = {\n\t\ttopLeft: { x: tempBox.x / w, y: tempBox.y / h },\n\t\tbottomRight: { x: tempBox.maxX / w, y: tempBox.maxY / h },\n\t\tisCircle: crop.isCircle,\n\t}\n\n\t// If the crop hasn't changed, we can return early\n\tif (\n\t\tnewCrop.topLeft.x === crop.topLeft.x &&\n\t\tnewCrop.topLeft.y === crop.topLeft.y &&\n\t\tnewCrop.bottomRight.x === crop.bottomRight.x &&\n\t\tnewCrop.bottomRight.y === crop.bottomRight.y\n\t) {\n\t\treturn\n\t}\n\n\t// Adjust the shape's position to keep the crop's absolute coordinates correct\n\tconst newPoint = new Vec(tempBox.x - crop.topLeft.x * w, tempBox.y - crop.topLeft.y * h)\n\t\t.rot(shape.rotation)\n\t\t.add(shape)\n\n\treturn {\n\t\tid: shape.id,\n\t\ttype: shape.type,\n\t\tx: newPoint.x,\n\t\ty: newPoint.y,\n\t\tprops: {\n\t\t\t...shape.props,\n\t\t\tw: tempBox.w,\n\t\t\th: tempBox.h,\n\t\t\tcrop: newCrop,\n\t\t},\n\t}\n}\n\ninterface CropChange {\n\tcrop: {\n\t\ttopLeft: { x: number; y: number }\n\t\tbottomRight: { x: number; y: number }\n\t\tisCircle?: boolean\n\t}\n\tw: number\n\th: number\n\tx: number\n\ty: number\n}\n\n// Base function for calculating crop changes\nfunction calculateCropChange(\n\timageShape: TLImageShape,\n\tnewCropWidth: number,\n\tnewCropHeight: number,\n\tcenterOnCurrentCrop: boolean = true,\n\tisCircle: boolean = false\n): CropChange {\n\tconst { w, h } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop())\n\tconst currentCrop = imageShape.props.crop || getDefaultCrop()\n\n\t// Calculate image and crop centers\n\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\n\tlet cropCenterX, cropCenterY\n\tif (centerOnCurrentCrop) {\n\t\tconst { x, y } = getCropCenter(currentCrop)\n\t\tcropCenterX = x\n\t\tcropCenterY = y\n\t} else {\n\t\tcropCenterX = 0.5\n\t\tcropCenterY = 0.5\n\t}\n\n\t// Create new crop\n\tconst newCrop = createCropAroundCenter(\n\t\tcropCenterX,\n\t\tcropCenterY,\n\t\tnewCropWidth,\n\t\tnewCropHeight,\n\t\tisCircle\n\t)\n\n\t// Calculate new dimensions\n\tconst croppedW = newCropWidth * w\n\tconst croppedH = newCropHeight * h\n\n\treturn {\n\t\tcrop: newCrop,\n\t\tw: croppedW,\n\t\th: croppedH,\n\t\tx: imageCenterX - croppedW / 2,\n\t\ty: imageCenterY - croppedH / 2,\n\t}\n}\n\n/** @internal */\nexport const MAX_ZOOM = 3\n\n/**\n * Calculate new crop dimensions and position when zooming\n */\nexport function getCroppedImageDataWhenZooming(\n\tzoom: number,\n\timageShape: TLImageShape,\n\tmaxZoom?: number\n): CropChange {\n\tconst oldCrop = imageShape.props.crop || getDefaultCrop()\n\tconst { width: oldWidth, height: oldHeight } = getCropDimensions(oldCrop)\n\tconst aspectRatio = oldWidth / oldHeight\n\n\t// Calculate new crop size with zoom scale\n\tconst derivedMaxZoom = maxZoom ? 1 / (1 - maxZoom) : MAX_ZOOM\n\tconst zoomScale = 1 + zoom * (derivedMaxZoom - 1)\n\tlet newWidth, newHeight\n\n\tif (aspectRatio > 1) {\n\t\tnewWidth = Math.min(1, 1 / zoomScale)\n\t\tnewHeight = newWidth / aspectRatio\n\t} else {\n\t\tnewHeight = Math.min(1, 1 / zoomScale)\n\t\tnewWidth = newHeight * aspectRatio\n\t}\n\n\t// Calculate result with base function\n\tconst result = calculateCropChange(imageShape, newWidth, newHeight, true, oldCrop.isCircle)\n\n\t// Apply zoom factor to display dimensions\n\tconst scaleFactor = Math.min(MAX_ZOOM, oldWidth / newWidth)\n\tresult.w *= scaleFactor\n\tresult.h *= scaleFactor\n\n\t// Recenter\n\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\tresult.x = imageCenterX - result.w / 2\n\tresult.y = imageCenterY - result.h / 2\n\n\treturn result\n}\n\n/**\n * Calculate new crop dimensions and position when replacing an image\n */\nexport function getCroppedImageDataForReplacedImage(\n\timageShape: TLImageShape,\n\tnewImageWidth: number,\n\tnewImageHeight: number\n): CropChange {\n\tconst defaultCrop = getDefaultCrop()\n\tconst currentCrop = imageShape.props.crop || defaultCrop\n\tconst origDisplayW = imageShape.props.w\n\tconst origDisplayH = imageShape.props.h\n\tconst newImageAspectRatio = newImageWidth / newImageHeight\n\n\tlet crop = defaultCrop\n\tlet newDisplayW = origDisplayW\n\tlet newDisplayH = origDisplayH\n\tconst isOriginalCrop = isEqual(imageShape.props.crop, defaultCrop)\n\n\tif (isOriginalCrop) {\n\t\tnewDisplayW = origDisplayW\n\t\tnewDisplayH = (origDisplayW * newImageHeight) / newImageWidth\n\t} else {\n\t\tconst { w: uncroppedW, h: uncroppedH } = getUncroppedSize(\n\t\t\timageShape.props,\n\t\t\timageShape.props.crop || getDefaultCrop() // Use the ACTUAL current crop to correctly infer uncropped size\n\t\t)\n\t\tconst { width: cropW, height: cropH } = getCropDimensions(currentCrop)\n\t\tconst targetRatio = cropW / cropH\n\t\tconst oldImageAspectRatio = uncroppedW / uncroppedH\n\t\tlet newRelativeWidth: number\n\t\tlet newRelativeHeight: number\n\n\t\tconst currentCropCenter = getCropCenter(currentCrop)\n\n\t\t// Adjust the new crop dimensions to match the current crop zoom\n\t\tnewRelativeWidth = cropW\n\t\tconst ratioConversion = newImageAspectRatio / oldImageAspectRatio / targetRatio\n\t\tnewRelativeHeight = newRelativeWidth * ratioConversion\n\n\t\t// Check that our new crop dimensions are within the MAX_ZOOM bounds\n\t\tconst maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1)\n\t\tif (ratioConversion > maxRatioConversion) {\n\t\t\tconst minDimension = 1 / MAX_ZOOM\n\t\t\tif (1 / newRelativeHeight < 1 / newRelativeWidth) {\n\t\t\t\tconst scale = newRelativeHeight / minDimension\n\t\t\t\tnewRelativeHeight = newRelativeHeight / scale\n\t\t\t\tnewRelativeWidth = newRelativeWidth / scale\n\t\t\t} else {\n\t\t\t\tconst scale = newRelativeWidth / minDimension\n\t\t\t\tnewRelativeWidth = newRelativeWidth / scale\n\t\t\t\tnewRelativeHeight = newRelativeHeight / scale\n\t\t\t}\n\t\t}\n\n\t\t// Ensure dimensions are within [0, 1] bounds after adjustment\n\t\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\t\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\n\t\t// Create the new crop object, centered around the CURRENT crop's center\n\t\tcrop = createCropAroundCenter(\n\t\t\tcurrentCropCenter.x,\n\t\t\tcurrentCropCenter.y,\n\t\t\tnewRelativeWidth,\n\t\t\tnewRelativeHeight,\n\t\t\tcurrentCrop.isCircle\n\t\t)\n\t}\n\n\t// Position so visual center stays put\n\tconst pageCenterX = imageShape.x + origDisplayW / 2\n\tconst pageCenterY = imageShape.y + origDisplayH / 2\n\n\tconst newX = pageCenterX - newDisplayW / 2\n\tconst newY = pageCenterY - newDisplayH / 2\n\n\treturn {\n\t\tcrop,\n\t\tw: newDisplayW,\n\t\th: newDisplayH,\n\t\tx: newX,\n\t\ty: newY,\n\t}\n}\n\n/**\n * Calculate new crop dimensions and position when changing aspect ratio\n */\nexport function getCroppedImageDataForAspectRatio(\n\taspectRatioOption: ASPECT_RATIO_OPTION,\n\timageShape: TLImageShape\n): CropChange {\n\t// If original aspect ratio is requested, use default crop\n\tif (aspectRatioOption === 'original') {\n\t\tconst { w, h } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop())\n\t\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\t\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\n\t\treturn {\n\t\t\tcrop: getDefaultCrop(),\n\t\t\tw,\n\t\t\th,\n\t\t\tx: imageCenterX - w / 2,\n\t\t\ty: imageCenterY - h / 2,\n\t\t}\n\t}\n\n\t// Get target ratio and uncropped image properties\n\tconst targetRatio = ASPECT_RATIO_TO_VALUE[aspectRatioOption] // Assume valid option\n\tconst isCircle = aspectRatioOption === 'circle'\n\t// Use default crop to get uncropped size relative to the *original* image bounds\n\tconst { w: uncroppedW, h: uncroppedH } = getUncroppedSize(\n\t\timageShape.props,\n\t\timageShape.props.crop || getDefaultCrop() // Use the ACTUAL current crop to correctly infer uncropped size\n\t)\n\t// Calculate the original image aspect ratio\n\tconst imageAspectRatio = uncroppedW / uncroppedH\n\n\t// Get the current crop and its relative dimensions\n\tconst currentCrop = imageShape.props.crop || getDefaultCrop()\n\tconst { width: cropW, height: cropH } = getCropDimensions(currentCrop)\n\tconst currentCropCenter = getCropCenter(currentCrop)\n\n\t// Calculate the current crop zoom level\n\tconst currentCropZoom = Math.min(1 / cropW, 1 / cropH)\n\n\t// Calculate the relative width and height of the crop rectangle (0-1 scale)\n\t// Try to preserve the longest dimension of the current crop when changing aspect ratios\n\tlet newRelativeWidth: number\n\tlet newRelativeHeight: number\n\n\tif (imageAspectRatio === 0 || !Number.isFinite(imageAspectRatio) || targetRatio === 0) {\n\t\t// Avoid division by zero or NaN issues if image dimensions are invalid or target ratio is 0\n\t\tnewRelativeWidth = 1\n\t\tnewRelativeHeight = 1\n\t} else {\n\t\t// Get current crop dimensions in absolute units\n\t\tconst currentAbsoluteWidth = cropW * uncroppedW\n\t\tconst currentAbsoluteHeight = cropH * uncroppedH\n\n\t\t// Find the longest current dimension to preserve\n\t\tconst longestCurrentDimension = Math.max(currentAbsoluteWidth, currentAbsoluteHeight)\n\t\tconst isWidthLongest = currentAbsoluteWidth >= currentAbsoluteHeight\n\n\t\t// Calculate new dimensions preserving the longest dimension\n\t\tlet newAbsoluteWidth: number\n\t\tlet newAbsoluteHeight: number\n\n\t\tif (isWidthLongest) {\n\t\t\t// Preserve width, calculate height based on target ratio\n\t\t\tnewAbsoluteWidth = longestCurrentDimension\n\t\t\tnewAbsoluteHeight = newAbsoluteWidth / targetRatio\n\t\t} else {\n\t\t\t// Preserve height, calculate width based on target ratio\n\t\t\tnewAbsoluteHeight = longestCurrentDimension\n\t\t\tnewAbsoluteWidth = newAbsoluteHeight * targetRatio\n\t\t}\n\n\t\t// Convert back to relative coordinates\n\t\tnewRelativeWidth = newAbsoluteWidth / uncroppedW\n\t\tnewRelativeHeight = newAbsoluteHeight / uncroppedH\n\n\t\t// Clamp to image bounds and adjust if necessary\n\t\tif (newRelativeWidth > 1) {\n\t\t\t// Width exceeds bounds, clamp and recalculate height\n\t\t\tnewRelativeWidth = 1\n\t\t\tnewRelativeHeight = imageAspectRatio / targetRatio\n\t\t}\n\t\tif (newRelativeHeight > 1) {\n\t\t\t// Height exceeds bounds, clamp and recalculate width\n\t\t\tnewRelativeHeight = 1\n\t\t\tnewRelativeWidth = targetRatio / imageAspectRatio\n\t\t}\n\n\t\t// Final clamp to ensure we stay within bounds\n\t\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\t\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\t}\n\n\tconst newCropZoom = Math.min(1 / newRelativeWidth, 1 / newRelativeHeight)\n\t// Adjust the new crop dimensions to match the current crop zoom\n\tnewRelativeWidth *= newCropZoom / currentCropZoom\n\tnewRelativeHeight *= newCropZoom / currentCropZoom\n\n\t// Ensure dimensions are within [0, 1] bounds after adjustment\n\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\n\t// Create the new crop object, centered around the CURRENT crop's center\n\tconst newCrop = createCropAroundCenter(\n\t\tcurrentCropCenter.x,\n\t\tcurrentCropCenter.y,\n\t\tnewRelativeWidth,\n\t\tnewRelativeHeight,\n\t\tisCircle\n\t)\n\n\t// Get the actual relative dimensions from the new crop (after potential clamping)\n\tconst finalRelativeWidth = newCrop.bottomRight.x - newCrop.topLeft.x\n\tconst finalRelativeHeight = newCrop.bottomRight.y - newCrop.topLeft.y\n\n\t// Calculate the base dimensions (as if applying the new crop to the uncropped image at scale 1)\n\tconst baseW = finalRelativeWidth * uncroppedW\n\tconst baseH = finalRelativeHeight * uncroppedH\n\n\t// Determine the current effective scale of the shape\n\t// This preserves the visual size when the crop changes\n\tlet currentScale = 1.0\n\tif (cropW > 0) {\n\t\tcurrentScale = imageShape.props.w / (cropW * uncroppedW)\n\t} else if (cropH > 0) {\n\t\t// Fallback to height if width relative dimension is zero\n\t\tcurrentScale = imageShape.props.h / (cropH * uncroppedH)\n\t}\n\n\t// Apply the current scale to the base dimensions to get the final dimensions\n\tconst newW = baseW * currentScale\n\tconst newH = baseH * currentScale\n\n\t// Calculate the new top-left position (x, y) for the shape\n\t// to keep the visual center of the cropped area fixed on the page.\n\tconst currentCenterXPage = imageShape.x + imageShape.props.w / 2\n\tconst currentCenterYPage = imageShape.y + imageShape.props.h / 2\n\tconst newX = currentCenterXPage - newW / 2\n\tconst newY = currentCenterYPage - newH / 2\n\n\treturn {\n\t\tcrop: newCrop,\n\t\tw: newW,\n\t\th: newH,\n\t\tx: newX,\n\t\ty: newY,\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1318, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/getStrokeOutlinePoints.ts"],"sourcesContent":["import { Vec } from '@tldraw/editor'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst { PI } = Math\n\n// Browser strokes seem to be off if PI is regular, a tiny offset seems to fix it\nconst FIXED_PI = PI + 0.0001\n\n/**\n * @internal\n */\nexport function getStrokeOutlineTracks(\n\tstrokePoints: StrokePoint[],\n\toptions: StrokeOptions = {}\n): { left: Vec[]; right: Vec[] } {\n\tconst { size = 16, smoothing = 0.5 } = options\n\n\t// We can't do anything with an empty array or a stroke with negative size.\n\tif (strokePoints.length === 0 || size <= 0) {\n\t\treturn { left: [], right: [] }\n\t}\n\n\tconst firstStrokePoint = strokePoints[0]\n\tconst lastStrokePoint = strokePoints[strokePoints.length - 1]\n\n\t// The total length of the line\n\tconst totalLength = lastStrokePoint.runningLength\n\n\t// The minimum allowed distance between points (squared)\n\tconst minDistance = Math.pow(size * smoothing, 2)\n\n\t// Our collected left and right points\n\tconst leftPts: Vec[] = []\n\tconst rightPts: Vec[] = []\n\n\t// Previous vector\n\tlet prevVector = strokePoints[0].vector\n\n\t// Previous left and right points\n\tlet pl = strokePoints[0].point\n\tlet pr = pl\n\n\t// Temporary left and right points\n\tlet tl = pl\n\tlet tr = pr\n\n\t// Keep track of whether the previous point is a sharp corner\n\t// ... so that we don't detect the same corner twice\n\tlet isPrevPointSharpCorner = false\n\n\t/*\n    Find the outline's left and right points\n\n    Iterating through the points and populate the rightPts and leftPts arrays,\n    skipping the first and last pointsm, which will get caps later on.\n  */\n\n\tlet strokePoint: StrokePoint\n\n\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\tstrokePoint = strokePoints[i]\n\t\tconst { point, vector } = strokePoints[i]\n\n\t\t/*\n      Handle sharp corners\n\n      Find the difference (dot product) between the current and next vector.\n      If the next vector is at more than a right angle to the current vector,\n      draw a cap at the current point.\n    */\n\n\t\tconst prevDpr = strokePoint.vector.dpr(prevVector)\n\t\tconst nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector\n\t\tconst nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1\n\n\t\tconst isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner\n\t\tconst isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2\n\n\t\tif (isPointSharpCorner || isNextPointSharpCorner) {\n\t\t\t// It's a sharp corner. Draw a rounded cap and move on to the next point\n\t\t\t// Considering saving these and drawing them later? So that we can avoid\n\t\t\t// crossing future points.\n\n\t\t\tif (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {\n\t\t\t\t// Draw a \"soft\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius)\n\t\t\t\tconst cpr = prevVector.clone().cpr(nextVector)\n\n\t\t\t\tif (cpr < 0) {\n\t\t\t\t\ttl = Vec.Add(point, offset)\n\t\t\t\t\ttr = Vec.Sub(point, offset)\n\t\t\t\t} else {\n\t\t\t\t\ttl = Vec.Sub(point, offset)\n\t\t\t\t\ttr = Vec.Add(point, offset)\n\t\t\t\t}\n\n\t\t\t\tleftPts.push(tl)\n\t\t\t\trightPts.push(tr)\n\t\t\t} else {\n\t\t\t\t// Draw a \"sharp\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius).per()\n\t\t\t\tconst start = Vec.Sub(strokePoint.input, offset)\n\n\t\t\t\tfor (let step = 1 / 13, t = 0; t < 1; t += step) {\n\t\t\t\t\ttl = Vec.RotWith(start, strokePoint.input, FIXED_PI * t)\n\t\t\t\t\tleftPts.push(tl)\n\n\t\t\t\t\ttr = Vec.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t)\n\t\t\t\t\trightPts.push(tr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpl = tl\n\t\t\tpr = tr\n\n\t\t\tif (isNextPointSharpCorner) {\n\t\t\t\tisPrevPointSharpCorner = true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tisPrevPointSharpCorner = false\n\n\t\tif (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {\n\t\t\tconst offset = Vec.Per(vector).mul(strokePoint.radius)\n\t\t\tleftPts.push(Vec.Sub(point, offset))\n\t\t\trightPts.push(Vec.Add(point, offset))\n\n\t\t\tcontinue\n\t\t}\n\n\t\t/* \n      Add regular points\n\n      Project points to either side of the current point, using the\n      calculated size as a distance. If a point's distance to the \n      previous point on that side greater than the minimum distance\n      (or if the corner is kinda sharp), add the points to the side's\n      points array.\n    */\n\n\t\tconst offset = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius)\n\n\t\ttl = Vec.Sub(point, offset)\n\n\t\tif (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {\n\t\t\tleftPts.push(tl)\n\t\t\tpl = tl\n\t\t}\n\n\t\ttr = Vec.Add(point, offset)\n\n\t\tif (i <= 1 || Vec.Dist2(pr, tr) > minDistance) {\n\t\t\trightPts.push(tr)\n\t\t\tpr = tr\n\t\t}\n\n\t\t// Set variables for next iteration\n\t\tprevVector = vector\n\n\t\tcontinue\n\t}\n\n\t/*\n    Return the points in the correct winding order: begin on the left side, then \n    continue around the end cap, then come back along the right side, and finally \n    complete the start cap.\n  */\n\n\treturn {\n\t\tleft: leftPts,\n\t\tright: rightPts,\n\t}\n}\n\n/**\n * ## getStrokeOutlinePoints\n *\n * Get an array of points (as `[x, y]`) representing the outline of a stroke.\n *\n * @param points - An array of StrokePoints as returned from `getStrokePoints`.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokeOutlinePoints(\n\tstrokePoints: StrokePoint[],\n\toptions: StrokeOptions = {}\n): Vec[] {\n\tconst { size = 16, start = {}, end = {}, last: isComplete = false } = options\n\n\tconst { cap: capStart = true } = start\n\tconst { cap: capEnd = true } = end\n\n\t// We can't do anything with an empty array or a stroke with negative size.\n\tif (strokePoints.length === 0 || size <= 0) {\n\t\treturn []\n\t}\n\n\tconst firstStrokePoint = strokePoints[0]\n\tconst lastStrokePoint = strokePoints[strokePoints.length - 1]\n\n\t// The total length of the line\n\tconst totalLength = lastStrokePoint.runningLength\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (end.taper as number)\n\n\t// The minimum allowed distance between points (squared)\n\t// Our collected left and right points\n\tconst { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options)\n\n\t/*\n    Drawing caps\n    \n    Now that we have our points on either side of the line, we need to\n    draw caps at the start and end. Tapered lines don't have caps, but\n    may have dots for very short lines.\n  */\n\n\tconst firstPoint = firstStrokePoint.point\n\n\tconst lastPoint =\n\t\tstrokePoints.length > 1\n\t\t\t? strokePoints[strokePoints.length - 1].point\n\t\t\t: Vec.AddXY(firstStrokePoint.point, 1, 1)\n\n\t/* \n    Draw a dot for very short or completed strokes\n    \n    If the line is too short to gather left or right points and if the line is\n    not tapered on either side, draw a dot. If the line is tapered, then only\n    draw a dot if the line is both very short and complete. If we draw a dot,\n    we can just return those points.\n  */\n\n\tif (strokePoints.length === 1) {\n\t\tif (!(taperStart || taperEnd) || isComplete) {\n\t\t\tconst start = Vec.Add(\n\t\t\t\tfirstPoint,\n\t\t\t\tVec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)\n\t\t\t)\n\t\t\tconst dotPts: Vec[] = []\n\t\t\tfor (let step = 1 / 13, t = step; t <= 1; t += step) {\n\t\t\t\tdotPts.push(Vec.RotWith(start, firstPoint, FIXED_PI * 2 * t))\n\t\t\t}\n\t\t\treturn dotPts\n\t\t}\n\t}\n\n\t/*\n    Draw a start cap\n\n    Unless the line has a tapered start, or unless the line has a tapered end\n    and the line is very short, draw a start cap around the first point. Use\n    the distance between the second left and right point for the cap's radius.\n    Finally remove the first left and right points. :psyduck:\n  */\n\n\tconst startCap: Vec[] = []\n\tif (taperStart || (taperEnd && strokePoints.length === 1)) {\n\t\t// The start point is tapered, noop\n\t} else if (capStart) {\n\t\t// Draw the round cap - add thirteen points rotating the right point around the start point to the left point\n\t\tfor (let step = 1 / 8, t = step; t <= 1; t += step) {\n\t\t\tconst pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t)\n\t\t\tstartCap.push(pt)\n\t\t}\n\t} else {\n\t\t// Draw the flat cap - add a point to the left and right of the start point\n\t\tconst cornersVector = Vec.Sub(leftPts[0], rightPts[0])\n\t\tconst offsetA = Vec.Mul(cornersVector, 0.5)\n\t\tconst offsetB = Vec.Mul(cornersVector, 0.51)\n\n\t\tstartCap.push(\n\t\t\tVec.Sub(firstPoint, offsetA),\n\t\t\tVec.Sub(firstPoint, offsetB),\n\t\t\tVec.Add(firstPoint, offsetB),\n\t\t\tVec.Add(firstPoint, offsetA)\n\t\t)\n\t}\n\n\t/*\n    Draw an end cap\n\n    If the line does not have a tapered end, and unless the line has a tapered\n    start and the line is very short, draw a cap around the last point. Finally,\n    remove the last left and right points. Otherwise, add the last point. Note\n    that This cap is a full-turn-and-a-half: this prevents incorrect caps on\n    sharp end turns.\n  */\n\n\tconst endCap: Vec[] = []\n\tconst direction = lastStrokePoint.vector.clone().per().neg()\n\n\tif (taperEnd || (taperStart && strokePoints.length === 1)) {\n\t\t// Tapered end - push the last point to the line\n\t\tendCap.push(lastPoint)\n\t} else if (capEnd) {\n\t\t// Draw the round end cap\n\t\tconst start = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))\n\t\tfor (let step = 1 / 29, t = step; t < 1; t += step) {\n\t\t\tendCap.push(Vec.RotWith(start, lastPoint, FIXED_PI * 3 * t))\n\t\t}\n\t} else {\n\t\t// Draw the flat end cap\n\t\tendCap.push(\n\t\t\tVec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),\n\t\t\tVec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))\n\t\t)\n\t}\n\n\t/*\n    Return the points in the correct winding order: begin on the left side, then \n    continue around the end cap, then come back along the right side, and finally \n    complete the start cap.\n  */\n\n\treturn leftPts.concat(endCap, rightPts.reverse(), startCap)\n}\n"],"names":["offset", "start"],"mappings":";;;;;;;AAAA,SAAS,WAAW;;AAGpB,MAAM,EAAE,EAAA,CAAG,CAAA,GAAI;AAGf,MAAM,WAAW,KAAK;AAKf,SAAS,uBACf,YAAA,EACA,UAAyB,CAAC,CAAA,EACM;IAChC,MAAM,EAAE,OAAO,EAAA,EAAI,YAAY,GAAA,CAAI,CAAA,GAAI;IAGvC,IAAI,aAAa,MAAA,KAAW,KAAK,QAAQ,GAAG;QAC3C,OAAO;YAAE,MAAM,CAAC,CAAA;YAAG,OAAO,CAAC,CAAA;QAAE;IAC9B;IAEA,MAAM,mBAAmB,YAAA,CAAa,CAAC,CAAA;IACvC,MAAM,kBAAkB,YAAA,CAAa,aAAa,MAAA,GAAS,CAAC,CAAA;IAG5D,MAAM,cAAc,gBAAgB,aAAA;IAGpC,MAAM,cAAc,KAAK,GAAA,CAAI,OAAO,WAAW,CAAC;IAGhD,MAAM,UAAiB,CAAC,CAAA;IACxB,MAAM,WAAkB,CAAC,CAAA;IAGzB,IAAI,aAAa,YAAA,CAAa,CAAC,CAAA,CAAE,MAAA;IAGjC,IAAI,KAAK,YAAA,CAAa,CAAC,CAAA,CAAE,KAAA;IACzB,IAAI,KAAK;IAGT,IAAI,KAAK;IACT,IAAI,KAAK;IAIT,IAAI,yBAAyB;IAS7B,IAAI;IAEJ,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,IAAK;QAC7C,cAAc,YAAA,CAAa,CAAC,CAAA;QAC5B,MAAM,EAAE,KAAA,EAAO,MAAA,CAAO,CAAA,GAAI,YAAA,CAAa,CAAC,CAAA;QAUxC,MAAM,UAAU,YAAY,MAAA,CAAO,GAAA,CAAI,UAAU;QACjD,MAAM,aAAA,CAAc,IAAI,aAAa,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAC,CAAA,GAAI,YAAA,CAAa,CAAC,CAAA,EAAG,MAAA;QACzF,MAAM,UAAU,IAAI,aAAa,MAAA,GAAS,IAAI,WAAW,GAAA,CAAI,YAAY,MAAM,IAAI;QAEnF,MAAM,qBAAqB,UAAU,KAAK,CAAC;QAC3C,MAAM,yBAAyB,YAAY,QAAQ,UAAU;QAE7D,IAAI,sBAAsB,wBAAwB;YAKjD,IAAI,UAAU,CAAA,QAAS,cAAc,YAAY,aAAA,GAAgB,YAAY,MAAA,EAAQ;gBAEpF,MAAMA,UAAS,WAAW,KAAA,CAAM,EAAE,GAAA,CAAI,YAAY,MAAM;gBACxD,MAAM,MAAM,WAAW,KAAA,CAAM,EAAE,GAAA,CAAI,UAAU;gBAE7C,IAAI,MAAM,GAAG;oBACZ,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM;oBAC1B,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM;gBAC3B,OAAO;oBACN,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM;oBAC1B,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM;gBAC3B;gBAEA,QAAQ,IAAA,CAAK,EAAE;gBACf,SAAS,IAAA,CAAK,EAAE;YACjB,OAAO;gBAEN,MAAMA,UAAS,WAAW,KAAA,CAAM,EAAE,GAAA,CAAI,YAAY,MAAM,EAAE,GAAA,CAAI;gBAC9D,MAAM,QAAQ,0OAAA,CAAI,GAAA,CAAI,YAAY,KAAA,EAAOA,OAAM;gBAE/C,IAAA,IAAS,OAAO,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,KAAM;oBAChD,KAAK,0OAAA,CAAI,OAAA,CAAQ,OAAO,YAAY,KAAA,EAAO,WAAW,CAAC;oBACvD,QAAQ,IAAA,CAAK,EAAE;oBAEf,KAAK,0OAAA,CAAI,OAAA,CAAQ,OAAO,YAAY,KAAA,EAAO,WAAW,WAAW,CAAC,CAAC;oBACnE,SAAS,IAAA,CAAK,EAAE;gBACjB;YACD;YAEA,KAAK;YACL,KAAK;YAEL,IAAI,wBAAwB;gBAC3B,yBAAyB;YAC1B;YAEA;QACD;QAEA,yBAAyB;QAEzB,IAAI,gBAAgB,oBAAoB,gBAAgB,iBAAiB;YACxE,MAAMA,UAAS,0OAAA,CAAI,GAAA,CAAI,MAAM,EAAE,GAAA,CAAI,YAAY,MAAM;YACrD,QAAQ,IAAA,CAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM,CAAC;YACnC,SAAS,IAAA,CAAK,0OAAA,CAAI,GAAA,CAAI,OAAOA,OAAM,CAAC;YAEpC;QACD;QAYA,MAAM,SAAS,0OAAA,CAAI,GAAA,CAAI,YAAY,QAAQ,OAAO,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI,YAAY,MAAM;QAEhF,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAO,MAAM;QAE1B,IAAI,KAAK,KAAK,0OAAA,CAAI,KAAA,CAAM,IAAI,EAAE,IAAI,aAAa;YAC9C,QAAQ,IAAA,CAAK,EAAE;YACf,KAAK;QACN;QAEA,KAAK,0OAAA,CAAI,GAAA,CAAI,OAAO,MAAM;QAE1B,IAAI,KAAK,KAAK,0OAAA,CAAI,KAAA,CAAM,IAAI,EAAE,IAAI,aAAa;YAC9C,SAAS,IAAA,CAAK,EAAE;YAChB,KAAK;QACN;QAGA,aAAa;QAEb;IACD;IAQA,OAAO;QACN,MAAM;QACN,OAAO;IACR;AACD;AAWO,SAAS,uBACf,YAAA,EACA,UAAyB,CAAC,CAAA,EAClB;IACR,MAAM,EAAE,OAAO,EAAA,EAAI,QAAQ,CAAC,CAAA,EAAG,MAAM,CAAC,CAAA,EAAG,MAAM,aAAa,KAAA,CAAM,CAAA,GAAI;IAEtE,MAAM,EAAE,KAAK,WAAW,IAAA,CAAK,CAAA,GAAI;IACjC,MAAM,EAAE,KAAK,SAAS,IAAA,CAAK,CAAA,GAAI;IAG/B,IAAI,aAAa,MAAA,KAAW,KAAK,QAAQ,GAAG;QAC3C,OAAO,CAAC,CAAA;IACT;IAEA,MAAM,mBAAmB,YAAA,CAAa,CAAC,CAAA;IACvC,MAAM,kBAAkB,YAAA,CAAa,aAAa,MAAA,GAAS,CAAC,CAAA;IAG5D,MAAM,cAAc,gBAAgB,aAAA;IAEpC,MAAM,aACL,MAAM,KAAA,KAAU,QACb,IACA,MAAM,KAAA,KAAU,OACf,KAAK,GAAA,CAAI,MAAM,WAAW,IACzB,MAAM,KAAA;IAEZ,MAAM,WACL,IAAI,KAAA,KAAU,QACX,IACA,IAAI,KAAA,KAAU,OACb,KAAK,GAAA,CAAI,MAAM,WAAW,IACzB,IAAI,KAAA;IAIV,MAAM,EAAE,MAAM,OAAA,EAAS,OAAO,QAAA,CAAS,CAAA,GAAI,uBAAuB,cAAc,OAAO;IAUvF,MAAM,aAAa,iBAAiB,KAAA;IAEpC,MAAM,YACL,aAAa,MAAA,GAAS,IACnB,YAAA,CAAa,aAAa,MAAA,GAAS,CAAC,CAAA,CAAE,KAAA,GACtC,0OAAA,CAAI,KAAA,CAAM,iBAAiB,KAAA,EAAO,GAAG,CAAC;IAW1C,IAAI,aAAa,MAAA,KAAW,GAAG;QAC9B,IAAI,CAAA,CAAE,cAAc,QAAA,KAAa,YAAY;YAC5C,MAAMC,SAAQ,0OAAA,CAAI,GAAA,CACjB,YACA,0OAAA,CAAI,GAAA,CAAI,YAAY,SAAS,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI,CAAC,iBAAiB,MAAM;YAExE,MAAM,SAAgB,CAAC,CAAA;YACvB,IAAA,IAAS,OAAO,IAAI,IAAI,IAAI,MAAM,KAAK,GAAG,KAAK,KAAM;gBACpD,OAAO,IAAA,CAAK,0OAAA,CAAI,OAAA,CAAQA,QAAO,YAAY,WAAW,IAAI,CAAC,CAAC;YAC7D;YACA,OAAO;QACR;IACD;IAWA,MAAM,WAAkB,CAAC,CAAA;IACzB,IAAI,cAAe,YAAY,aAAa,MAAA,KAAW,GAAI,CAE3D,OAAA,IAAW,UAAU;QAEpB,IAAA,IAAS,OAAO,IAAI,GAAG,IAAI,MAAM,KAAK,GAAG,KAAK,KAAM;YACnD,MAAM,KAAK,0OAAA,CAAI,OAAA,CAAQ,QAAA,CAAS,CAAC,CAAA,EAAG,YAAY,WAAW,CAAC;YAC5D,SAAS,IAAA,CAAK,EAAE;QACjB;IACD,OAAO;QAEN,MAAM,gBAAgB,0OAAA,CAAI,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,EAAG,QAAA,CAAS,CAAC,CAAC;QACrD,MAAM,UAAU,0OAAA,CAAI,GAAA,CAAI,eAAe,GAAG;QAC1C,MAAM,UAAU,0OAAA,CAAI,GAAA,CAAI,eAAe,IAAI;QAE3C,SAAS,IAAA,CACR,0OAAA,CAAI,GAAA,CAAI,YAAY,OAAO,GAC3B,0OAAA,CAAI,GAAA,CAAI,YAAY,OAAO,GAC3B,0OAAA,CAAI,GAAA,CAAI,YAAY,OAAO,GAC3B,0OAAA,CAAI,GAAA,CAAI,YAAY,OAAO;IAE7B;IAYA,MAAM,SAAgB,CAAC,CAAA;IACvB,MAAM,YAAY,gBAAgB,MAAA,CAAO,KAAA,CAAM,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI;IAE3D,IAAI,YAAa,cAAc,aAAa,MAAA,KAAW,GAAI;QAE1D,OAAO,IAAA,CAAK,SAAS;IACtB,OAAA,IAAW,QAAQ;QAElB,MAAMA,SAAQ,0OAAA,CAAI,GAAA,CAAI,WAAW,0OAAA,CAAI,GAAA,CAAI,WAAW,gBAAgB,MAAM,CAAC;QAC3E,IAAA,IAAS,OAAO,IAAI,IAAI,IAAI,MAAM,IAAI,GAAG,KAAK,KAAM;YACnD,OAAO,IAAA,CAAK,0OAAA,CAAI,OAAA,CAAQA,QAAO,WAAW,WAAW,IAAI,CAAC,CAAC;QAC5D;IACD,OAAO;QAEN,OAAO,IAAA,CACN,0OAAA,CAAI,GAAA,CAAI,WAAW,0OAAA,CAAI,GAAA,CAAI,WAAW,gBAAgB,MAAM,CAAC,GAC7D,0OAAA,CAAI,GAAA,CAAI,WAAW,0OAAA,CAAI,GAAA,CAAI,WAAW,gBAAgB,MAAA,GAAS,IAAI,CAAC,GACpE,0OAAA,CAAI,GAAA,CAAI,WAAW,0OAAA,CAAI,GAAA,CAAI,WAAW,gBAAgB,MAAA,GAAS,IAAI,CAAC,GACpE,0OAAA,CAAI,GAAA,CAAI,WAAW,0OAAA,CAAI,GAAA,CAAI,WAAW,gBAAgB,MAAM,CAAC;IAE/D;IAQA,OAAO,QAAQ,MAAA,CAAO,QAAQ,SAAS,OAAA,CAAQ,GAAG,QAAQ;AAC3D"}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/getStrokePoints.ts"],"sourcesContent":["import { Vec, VecLike } from '@tldraw/editor'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst MIN_START_PRESSURE = 0.025\nconst MIN_END_PRESSURE = 0.01\n\n/**\n * ## getStrokePoints\n *\n * Get an array of points as objects with an adjusted point, pressure, vector, distance, and\n * runningLength.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokePoints(\n\trawInputPoints: VecLike[],\n\toptions: StrokeOptions = {}\n): StrokePoint[] {\n\tconst { streamline = 0.5, size = 16, simulatePressure = false } = options\n\n\t// If we don't have any points, return an empty array.\n\tif (rawInputPoints.length === 0) return []\n\n\t// Find the interpolation level between points.\n\tconst t = 0.15 + (1 - streamline) * 0.85\n\n\t// Whatever the input is, make sure that the points are in number[][].\n\tlet pts = rawInputPoints.map(Vec.From)\n\n\tlet pointsRemovedFromNearEnd = 0\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the start of the array.\n\t\tlet pt = pts[0]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_START_PRESSURE) break\n\t\t\tpts.shift()\n\t\t\tpt = pts[0]\n\t\t}\n\t}\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the end of the array.\n\t\tlet pt = pts[pts.length - 1]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_END_PRESSURE) break\n\t\t\tpts.pop()\n\t\t\tpt = pts[pts.length - 1]\n\t\t}\n\t}\n\n\tif (pts.length === 0)\n\t\treturn [\n\t\t\t{\n\t\t\t\tpoint: Vec.From(rawInputPoints[0]),\n\t\t\t\tinput: Vec.From(rawInputPoints[0]),\n\t\t\t\tpressure: simulatePressure ? 0.5 : 0.15,\n\t\t\t\tvector: new Vec(1, 1),\n\t\t\t\tdistance: 0,\n\t\t\t\trunningLength: 0,\n\t\t\t\tradius: 1,\n\t\t\t},\n\t\t]\n\n\t// Strip points that are too close to the first point.\n\tlet pt = pts[1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, pts[0]) > (size / 3) ** 2) break\n\t\tpts[0].z = Math.max(pts[0].z, pt.z) // Use maximum pressure\n\t\tpts.splice(1, 1)\n\t\tpt = pts[1]\n\t}\n\n\t// Strip points that are too close to the last point.\n\tconst last = pts.pop()!\n\tpt = pts[pts.length - 1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, last) > (size / 3) ** 2) break\n\t\tpts.pop()\n\t\tpt = pts[pts.length - 1]\n\t\tpointsRemovedFromNearEnd++\n\t}\n\tpts.push(last)\n\n\tconst isComplete =\n\t\toptions.last ||\n\t\t!options.simulatePressure ||\n\t\t(pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size ** 2) ||\n\t\tpointsRemovedFromNearEnd > 0\n\n\t// Add extra points between the two, to help avoid \"dash\" lines\n\t// for strokes with tapered start and ends. Don't mutate the\n\t// input array!\n\tif (pts.length === 2 && options.simulatePressure) {\n\t\tconst last = pts[1]\n\t\tpts = pts.slice(0, -1)\n\t\tfor (let i = 1; i < 5; i++) {\n\t\t\tconst next = Vec.Lrp(pts[0], last, i / 4)\n\t\t\tnext.z = ((pts[0].z + (last.z - pts[0].z)) * i) / 4\n\t\t\tpts.push(next)\n\t\t}\n\t}\n\n\t// The strokePoints array will hold the points for the stroke.\n\t// Start it out with the first point, which needs no adjustment.\n\tconst strokePoints: StrokePoint[] = [\n\t\t{\n\t\t\tpoint: pts[0],\n\t\t\tinput: pts[0],\n\t\t\tpressure: simulatePressure ? 0.5 : pts[0].z,\n\t\t\tvector: new Vec(1, 1),\n\t\t\tdistance: 0,\n\t\t\trunningLength: 0,\n\t\t\tradius: 1,\n\t\t},\n\t]\n\n\t// We use the totalLength to keep track of the total distance\n\tlet totalLength = 0\n\n\t// We're set this to the latest point, so we can use it to calculate\n\t// the distance and vector of the next point.\n\tlet prev = strokePoints[0]\n\n\t// Iterate through all of the points, creating StrokePoints.\n\tlet point: Vec, distance: number\n\n\tif (isComplete && streamline > 0) {\n\t\tpts.push(pts[pts.length - 1].clone())\n\t}\n\n\tfor (let i = 1, n = pts.length; i < n; i++) {\n\t\tpoint =\n\t\t\t!t || (options.last && i === n - 1) ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t)\n\n\t\t// If the new point is the same as the previous point, skip ahead.\n\t\tif (prev.point.equals(point)) continue\n\n\t\t// How far is the new point from the previous point?\n\t\tdistance = Vec.Dist(point, prev.point)\n\n\t\t// Add this distance to the total \"running length\" of the line.\n\t\ttotalLength += distance\n\n\t\t// At the start of the line, we wait until the new point is a\n\t\t// certain distance away from the original point, to avoid noise\n\n\t\tif (i < 4 && totalLength < size) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create a new strokepoint (it will be the new \"previous\" one).\n\t\tprev = {\n\t\t\tinput: pts[i],\n\t\t\t// The adjusted point\n\t\t\tpoint,\n\t\t\t// The input pressure (or .5 if not specified)\n\t\t\tpressure: simulatePressure ? 0.5 : pts[i].z,\n\t\t\t// The vector from the current point to the previous point\n\t\t\tvector: Vec.Sub(prev.point, point).uni(),\n\t\t\t// The distance between the current point and the previous point\n\t\t\tdistance,\n\t\t\t// The total distance so far\n\t\t\trunningLength: totalLength,\n\t\t\t// The stroke point's radius\n\t\t\tradius: 1,\n\t\t}\n\n\t\t// Push it to the strokePoints array.\n\t\tstrokePoints.push(prev)\n\t}\n\n\t// Set the vector of the first point to be the same as the second point.\n\tif (strokePoints[1]?.vector) {\n\t\tstrokePoints[0].vector = strokePoints[1].vector.clone()\n\t}\n\n\tif (totalLength < 1) {\n\t\tconst maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure))\n\t\tstrokePoints.forEach((s) => (s.pressure = maxPressureAmongPoints))\n\t}\n\n\treturn strokePoints\n}\n"],"names":["pt", "last"],"mappings":"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"}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/setStrokePointRadii.ts"],"sourcesContent":["import { EASINGS } from '@tldraw/editor'\nimport { StrokeOptions, StrokePoint } from './types'\n\nconst { min } = Math\n\n// This is the rate of change for simulated pressure. It could be an option.\nconst RATE_OF_PRESSURE_CHANGE = 0.275\n\n/** @public */\nexport function setStrokePointRadii(strokePoints: StrokePoint[], options: StrokeOptions) {\n\tconst {\n\t\tsize = 16,\n\t\tthinning = 0.5,\n\t\tsimulatePressure = true,\n\t\teasing = (t) => t,\n\t\tstart = {},\n\t\tend = {},\n\t} = options\n\n\tconst { easing: taperStartEase = EASINGS.easeOutQuad } = start\n\tconst { easing: taperEndEase = EASINGS.easeOutCubic } = end\n\n\tconst totalLength = strokePoints[strokePoints.length - 1].runningLength\n\n\tlet firstRadius: number | undefined\n\tlet prevPressure = strokePoints[0].pressure\n\tlet strokePoint: StrokePoint\n\n\tif (!simulatePressure && totalLength < size) {\n\t\tconst max = strokePoints.reduce((max, curr) => Math.max(max, curr.pressure), 0.5)\n\t\tstrokePoints.forEach((sp) => {\n\t\t\tsp.pressure = max\n\t\t\tsp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure))\n\t\t})\n\t\treturn strokePoints\n\t} else {\n\t\t// Calculate initial pressure based on the average of the first\n\t\t// n number of points. This prevents \"dots\" at the start of the\n\t\t// line. Drawn lines almost always start slow!\n\t\tlet p: number\n\t\tfor (let i = 0, n = strokePoints.length; i < n; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (strokePoint.runningLength > size * 5) break\n\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\tif (simulatePressure) {\n\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\tp = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t} else {\n\t\t\t\tp = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5)\n\t\t\t}\n\t\t\tprevPressure = prevPressure + (p - prevPressure) * 0.5\n\t\t}\n\n\t\t// Now calculate pressure and radius for each point\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (thinning) {\n\t\t\t\tlet { pressure } = strokePoint\n\t\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\t\tif (simulatePressure) {\n\t\t\t\t\t// If we're simulating pressure, then do so based on the distance\n\t\t\t\t\t// between the current point and the previous point, and the size\n\t\t\t\t\t// of the stroke.\n\t\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\t\tpressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, use the input pressure slightly smoothed based on the\n\t\t\t\t\t// distance between the current point and the previous point.\n\t\t\t\t\tpressure = min(\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tprevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tstrokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure))\n\n\t\t\t\tprevPressure = pressure\n\t\t\t} else {\n\t\t\t\tstrokePoint.radius = size / 2\n\t\t\t}\n\n\t\t\tif (firstRadius === undefined) {\n\t\t\t\tfirstRadius = strokePoint.radius\n\t\t\t}\n\t\t}\n\t}\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (end.taper as number)\n\n\tif (taperStart || taperEnd) {\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\t/*\n\t\t\t\tApply tapering\n\n\t\t\t\tIf the current length is within the taper distance at either the\n\t\t\t\tstart or the end, calculate the taper strengths. Apply the smaller \n\t\t\t\tof the two taper strengths to the radius.\n\t\t\t*/\n\n\t\t\tconst { runningLength } = strokePoint\n\n\t\t\tconst ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1\n\n\t\t\tconst te =\n\t\t\t\ttotalLength - runningLength < taperEnd\n\t\t\t\t\t? taperEndEase((totalLength - runningLength) / taperEnd)\n\t\t\t\t\t: 1\n\n\t\t\tstrokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te))\n\t\t}\n\t}\n\n\treturn strokePoints\n}\n"],"names":["max"],"mappings":"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"}},
    {"offset": {"line": 1674, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/getStroke.ts"],"sourcesContent":["import { Vec, VecLike } from '@tldraw/editor'\nimport { getStrokeOutlinePoints } from './getStrokeOutlinePoints'\nimport { getStrokePoints } from './getStrokePoints'\nimport { setStrokePointRadii } from './setStrokePointRadii'\nimport type { StrokeOptions } from './types'\n\n/**\n * ## getStroke\n *\n * Get an array of points describing a polygon that surrounds the input points.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\n\nexport function getStroke(points: VecLike[], options: StrokeOptions = {}): Vec[] {\n\treturn getStrokeOutlinePoints(\n\t\tsetStrokePointRadii(getStrokePoints(points, options), options),\n\t\toptions\n\t)\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,8BAA8B;AACvC,SAAS,uBAAuB;AAChC,SAAS,2BAA2B;;;;AAc7B,SAAS,UAAU,MAAA,EAAmB,UAAyB,CAAC,CAAA,EAAU;IAChF,WAAO,sRAAA,MACN,gRAAA,MAAoB,wQAAA,EAAgB,QAAQ,OAAO,GAAG,OAAO,GAC7D;AAEF"}},
    {"offset": {"line": 1693, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/default-shape-constants.ts"],"sourcesContent":["import { TLDefaultFontStyle, TLDefaultSizeStyle } from '@tldraw/editor'\n\n/** @public */\nexport const TEXT_PROPS = {\n\tlineHeight: 1.35,\n\tfontWeight: 'normal',\n\tfontVariant: 'normal',\n\tfontStyle: 'normal',\n\tpadding: '0px',\n}\n\n/** @public */\nexport const STROKE_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/** @public */\nexport const FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 24,\n\tl: 36,\n\txl: 44,\n}\n\n/** @public */\nexport const LABEL_FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 22,\n\tl: 26,\n\txl: 32,\n}\n\n/** @public */\nexport const ARROW_LABEL_FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 20,\n\tl: 24,\n\txl: 28,\n}\n\n/** @public */\nexport const FONT_FAMILIES: Record<TLDefaultFontStyle, string> = {\n\tdraw: 'var(--tl-font-draw)',\n\tsans: 'var(--tl-font-sans)',\n\tserif: 'var(--tl-font-serif)',\n\tmono: 'var(--tl-font-mono)',\n}\n\n/** @internal */\nexport const LABEL_TO_ARROW_PADDING = 20\n/** @internal */\nexport const ARROW_LABEL_PADDING = 4.25\n/** @internal */\nexport const LABEL_PADDING = 16\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAGO,MAAM,aAAa;IACzB,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,WAAW;IACX,SAAS;AACV;AAGO,MAAM,eAAmD;IAC/D,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,aAAiD;IAC7D,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,mBAAuD;IACnE,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,yBAA6D;IACzE,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,gBAAoD;IAChE,MAAM;IACN,MAAM;IACN,OAAO;IACP,MAAM;AACP;AAGO,MAAM,yBAAyB;AAE/B,MAAM,sBAAsB;AAE5B,MAAM,gBAAgB"}},
    {"offset": {"line": 1759, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/defaultFonts.tsx"],"sourcesContent":["import { objectMapValues, TLFontFace } from '@tldraw/editor'\n\n/** @public */\nexport interface TLDefaultFont {\n\tnormal: {\n\t\tnormal: TLFontFace\n\t\tbold: TLFontFace\n\t}\n\titalic: {\n\t\tnormal: TLFontFace\n\t\tbold: TLFontFace\n\t}\n}\n/** @public */\nexport interface TLDefaultFonts {\n\ttldraw_draw: TLDefaultFont\n\ttldraw_sans: TLDefaultFont\n\ttldraw_serif: TLDefaultFont\n\ttldraw_mono: TLDefaultFont\n}\n\n/** @public */\nexport const DefaultFontFaces: TLDefaultFonts = {\n\ttldraw_draw: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_sans: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_serif: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_mono: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n}\n\n/** @public */\nexport const allDefaultFontFaces = objectMapValues(DefaultFontFaces).flatMap((font) =>\n\tobjectMapValues(font).flatMap((fontFace) => Object.values(fontFace))\n)\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,uBAAmC;;AAsBrC,MAAM,mBAAmC;IAC/C,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;YACT;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;YACT;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,cAAc;QACb,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAgB,QAAQ;gBAAQ;gBAC5C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAqB,QAAQ;gBAAQ;gBACjD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAuB,QAAQ;gBAAQ;gBACnD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA4B,QAAQ;gBAAQ;gBACxD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;AACD;AAGO,MAAM,0BAAsB,kOAAA,EAAgB,gBAAgB,EAAE,OAAA,CAAQ,CAAC,WAC7E,kOAAA,EAAgB,IAAI,EAAE,OAAA,CAAQ,CAAC,WAAa,OAAO,MAAA,CAAO,QAAQ,CAAC"}},
    {"offset": {"line": 1943, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts"],"sourcesContent":["/**\t@public */\nexport const INDENT = '  '\n\n/** @internal */\nexport class TextHelpers {\n\tstatic fixNewLines = /\\r?\\n|\\r/g\n\n\tstatic normalizeText(text: string) {\n\t\treturn text.replace(TextHelpers.fixNewLines, '\\n')\n\t}\n\n\tstatic normalizeTextForDom(text: string) {\n\t\treturn text\n\t\t\t.replace(TextHelpers.fixNewLines, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map((x) => x || ' ')\n\t\t\t.join('\\n')\n\t}\n}\n"],"names":[],"mappings":";;;;;;AACO,MAAM,SAAS;AAGf,MAAM,YAAY;IACxB,OAAO,cAAc,YAAA;IAErB,OAAO,cAAc,IAAA,EAAc;QAClC,OAAO,KAAK,OAAA,CAAQ,YAAY,WAAA,EAAa,IAAI;IAClD;IAEA,OAAO,oBAAoB,IAAA,EAAc;QACxC,OAAO,KACL,OAAA,CAAQ,YAAY,WAAA,EAAa,IAAI,EACrC,KAAA,CAAM,IAAI,EACV,GAAA,CAAI,CAAC,IAAM,KAAK,GAAG,EACnB,IAAA,CAAK,IAAI;IACZ;AACD"}},
    {"offset": {"line": 1965, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/legacyProps.ts"],"sourcesContent":["import { Box, BoxModel, TLDefaultHorizontalAlignStyle } from '@tldraw/editor'\n\nexport function getLegacyOffsetX(\n\talign: TLDefaultHorizontalAlignStyle | string,\n\tpadding: number,\n\tspans: { text: string; box: BoxModel }[],\n\ttotalWidth: number\n): number | undefined {\n\tif ((align === 'start-legacy' || align === 'end-legacy') && spans.length !== 0) {\n\t\tconst spansBounds = Box.From(spans[0].box)\n\t\tfor (const { box } of spans) {\n\t\t\tspansBounds.union(box)\n\t\t}\n\t\tif (align === 'start-legacy') {\n\t\t\treturn (totalWidth - 2 * padding - spansBounds.width) / 2\n\t\t} else if (align === 'end-legacy') {\n\t\t\treturn -(totalWidth - 2 * padding - spansBounds.width) / 2\n\t\t}\n\t}\n}\n\n// sneaky TLDefaultHorizontalAlignStyle for legacies\nexport function isLegacyAlign(align: TLDefaultHorizontalAlignStyle | string): boolean {\n\treturn align === 'start-legacy' || align === 'middle-legacy' || align === 'end-legacy'\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,WAAoD;;AAEtD,SAAS,iBACf,KAAA,EACA,OAAA,EACA,KAAA,EACA,UAAA,EACqB;IACrB,IAAA,CAAK,UAAU,kBAAkB,UAAU,YAAA,KAAiB,MAAM,MAAA,KAAW,GAAG;QAC/E,MAAM,cAAc,0OAAA,CAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,GAAG;QACzC,KAAA,MAAW,EAAE,GAAA,CAAI,CAAA,IAAK,MAAO;YAC5B,YAAY,KAAA,CAAM,GAAG;QACtB;QACA,IAAI,UAAU,gBAAgB;YAC7B,OAAA,CAAQ,aAAa,IAAI,UAAU,YAAY,KAAA,IAAS;QACzD,OAAA,IAAW,UAAU,cAAc;YAClC,OAAO,CAAA,CAAE,aAAa,IAAI,UAAU,YAAY,KAAA,IAAS;QAC1D;IACD;AACD;AAGO,SAAS,cAAc,KAAA,EAAwD;IACrF,OAAO,UAAU,kBAAkB,UAAU,mBAAmB,UAAU;AAC3E"}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useEditablePlainText.ts"],"sourcesContent":["import {\n\tEditor,\n\tExtractShapeByProps,\n\tTLShapeId,\n\tgetPointerInfo,\n\tnoop,\n\tpreventDefault,\n\ttlenv,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport React, { useCallback, useEffect, useRef } from 'react'\nimport { TextHelpers } from './TextHelpers'\n\n/** @public */\nexport function useEditablePlainText(\n\tshapeId: TLShapeId,\n\ttype: ExtractShapeByProps<{ text: string }>['type'],\n\ttext?: string\n) {\n\tconst commonUseEditableTextHandlers = useEditableTextCommon(shapeId)\n\tconst isEditing = commonUseEditableTextHandlers.isEditing\n\tconst editor = useEditor()\n\tconst rInput = useRef<HTMLTextAreaElement>(null)\n\tconst isEmpty = (text || '').trim().length === 0\n\n\tuseEffect(() => {\n\t\tfunction selectAllIfEditing(event: { shapeId: TLShapeId }) {\n\t\t\tif (event.shapeId === shapeId) {\n\t\t\t\trInput.current?.select?.()\n\t\t\t}\n\t\t}\n\n\t\teditor.on('select-all-text', selectAllIfEditing)\n\t\treturn () => {\n\t\t\teditor.off('select-all-text', selectAllIfEditing)\n\t\t}\n\t}, [editor, shapeId, isEditing])\n\n\tuseEffect(() => {\n\t\tif (!isEditing) return\n\n\t\tif (document.activeElement !== rInput.current) {\n\t\t\trInput.current?.focus()\n\t\t}\n\n\t\tif (editor.getInstanceState().isCoarsePointer) {\n\t\t\trInput.current?.select()\n\t\t}\n\n\t\t// XXX(mime): This fixes iOS not showing the caret sometimes.\n\t\t// This \"shakes\" the caret awake.\n\t\tif (tlenv.isSafari) {\n\t\t\trInput.current?.blur()\n\t\t\trInput.current?.focus()\n\t\t}\n\t}, [editor, isEditing])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\tconst handleKeyDown = useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\tswitch (e.key) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t\teditor.complete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t({ plaintext }: { plaintext: string }) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\tconst normalizedPlaintext = TextHelpers.normalizeText(plaintext || '')\n\t\t\teditor.updateShape({\n\t\t\t\tid: shapeId,\n\t\t\t\ttype,\n\t\t\t\tprops: { text: normalizedPlaintext },\n\t\t\t})\n\t\t},\n\t\t[editor, shapeId, type]\n\t)\n\n\treturn {\n\t\trInput,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\tisEmpty,\n\t\t...commonUseEditableTextHandlers,\n\t}\n}\n\n/** @internal */\nexport function useIsReadyForEditing(editor: Editor, shapeId: TLShapeId) {\n\treturn useValue(\n\t\t'isReadyForEditing',\n\t\t() => {\n\t\t\tconst editingShapeId = editor.getEditingShapeId()\n\t\t\treturn (\n\t\t\t\t// something's being editing... and either it's this shape OR this shape is hovered\n\t\t\t\teditingShapeId !== null &&\n\t\t\t\t(editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)\n\t\t\t)\n\t\t},\n\t\t[editor, shapeId]\n\t)\n}\n\n/** @internal */\nexport function useEditableTextCommon(shapeId: TLShapeId) {\n\tconst editor = useEditor()\n\tconst isEditing = useValue('isEditing', () => editor.getEditingShapeId() === shapeId, [editor])\n\tconst isReadyForEditing = useIsReadyForEditing(editor, shapeId)\n\n\tconst handleInputPointerDown = useCallback(\n\t\t(e: React.PointerEvent) => {\n\t\t\t// N.B. We used to only do this only when isEditing to help\n\t\t\t// prevent an issue where you could drag a selected shape\n\t\t\t// behind another shape. That is addressed now by the CSS logic\n\t\t\t// looking at data-isselectinganything.\n\t\t\t//\n\t\t\t// We still need to follow this logic even if not isEditing\n\t\t\t// because otherwise there is some flakiness in selection.\n\t\t\t// When selecting text, it would sometimes select some text\n\t\t\t// partially if we didn't dispatch/stop below.\n\n\t\t\teditor.dispatch({\n\t\t\t\t...getPointerInfo(editor, e),\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_down',\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: editor.getShape(shapeId)!,\n\t\t\t})\n\n\t\t\te.stopPropagation() // we need to prevent blurring the input\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\tconst handlePaste = useCallback(\n\t\t(e: ClipboardEvent | React.ClipboardEvent<HTMLTextAreaElement>) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\t\t\tif (e.clipboardData) {\n\t\t\t\t// find html in the clipboard and look for the tldraw data\n\t\t\t\tconst html = e.clipboardData.getData('text/html')\n\t\t\t\tif (html) {\n\t\t\t\t\tif (html.includes('<div data-tldraw')) {\n\t\t\t\t\t\tpreventDefault(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\treturn {\n\t\thandleFocus: noop,\n\t\thandleBlur: noop,\n\t\thandleInputPointerDown,\n\t\thandleDoubleClick: editor.markEventAsHandled,\n\t\thandlePaste,\n\t\tisEditing,\n\t\tisReadyForEditing,\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2167, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useEditableRichText.ts"],"sourcesContent":["import { ExtractShapeByProps, TLRichText, TLShapeId, isAccelKey, useEditor } from '@tldraw/editor'\nimport { useCallback, useEffect, useRef } from 'react'\nimport { isEmptyRichText } from '../../utils/text/richText'\nimport { useEditableTextCommon } from './useEditablePlainText'\n\n/** @public */\nexport function useEditableRichText(\n\tshapeId: TLShapeId,\n\ttype: ExtractShapeByProps<{ richText: TLRichText }>['type'],\n\trichText?: TLRichText\n) {\n\tconst commonUseEditableTextHandlers = useEditableTextCommon(shapeId)\n\tconst isEditing = commonUseEditableTextHandlers.isEditing\n\tconst editor = useEditor()\n\tconst rInput = useRef<HTMLDivElement>(null)\n\tconst isEmpty = richText && isEmptyRichText(richText)\n\n\tuseEffect(() => {\n\t\tif (!isEditing) return\n\n\t\t// N.B. In Development mode you need to ensure you're testing this without StrictMode on.\n\t\t// Otherwise it's not gonna work as expected on iOS.\n\t\tconst contentEditable = rInput.current?.querySelector('[contenteditable]')\n\t\tif (contentEditable && document.activeElement !== rInput.current) {\n\t\t\t// This is a crucial difference with useEditablePlainText, that we need to select the\n\t\t\t// child contentEditable <div> not rInput.current directly.\n\t\t\t// Specifically, this is to ensure iOS works. Otherwise, we could just use rInput.current.\n\t\t\t;(contentEditable as HTMLElement).focus()\n\t\t}\n\t}, [editor, isEditing])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\tconst handleKeyDown = useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\t\t\tif (e.key === 'Enter' && isAccelKey(e)) editor.complete()\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t({ richText }: { richText: TLRichText }) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\teditor.updateShape({\n\t\t\t\tid: shapeId,\n\t\t\t\ttype,\n\t\t\t\tprops: { richText },\n\t\t\t})\n\t\t},\n\t\t[editor, shapeId, type]\n\t)\n\n\treturn {\n\t\trInput,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\tisEmpty,\n\t\t...commonUseEditableTextHandlers,\n\t}\n}\n"],"names":["richText"],"mappings":";;;;;;AAAA,SAAqD,YAAY,iBAAiB;AAClF,SAAS,aAAa,WAAW,cAAc;AAC/C,SAAS,uBAAuB;AAChC,SAAS,6BAA6B;;;;;AAG/B,SAAS,oBACf,OAAA,EACA,IAAA,EACA,QAAA,EACC;IACD,MAAM,oCAAgC,uQAAA,EAAsB,OAAO;IACnE,MAAM,YAAY,8BAA8B,SAAA;IAChD,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,aAAS,yNAAA,EAAuB,IAAI;IAC1C,MAAM,UAAU,gBAAY,kPAAA,EAAgB,QAAQ;IAEpD,IAAA,4NAAA;yCAAU,MAAM;YACf,IAAI,CAAC,UAAW,CAAA;YAIhB,MAAM,kBAAkB,OAAO,OAAA,EAAS,cAAc,mBAAmB;YACzE,IAAI,mBAAmB,SAAS,aAAA,KAAkB,OAAO,OAAA,EAAS;;gBAI/D,gBAAgC,KAAA,CAAM;YACzC;QACD;wCAAG;QAAC;QAAQ,SAAS;KAAC;IAGtB,MAAM,oBAAgB,8NAAA;0DACrB,CAAC,MAAqB;YACrB,IAAI,OAAO,iBAAA,CAAkB,MAAM,QAAS,CAAA;YAC5C,IAAI,EAAE,GAAA,KAAQ,eAAW,iPAAA,EAAW,CAAC,EAAG,CAAA,OAAO,QAAA,CAAS;QACzD;yDACA;QAAC;QAAQ,OAAO;KAAA;IAIjB,MAAM,mBAAe,8NAAA;yDACpB,CAAC,EAAE,UAAAA,SAAAA,CAAS,CAAA,KAAgC;YAC3C,IAAI,OAAO,iBAAA,CAAkB,MAAM,QAAS,CAAA;YAE5C,OAAO,WAAA,CAAY;gBAClB,IAAI;gBACJ;gBACA,OAAO;oBAAE,UAAAA;gBAAS;YACnB,CAAC;QACF;wDACA;QAAC;QAAQ;QAAS,IAAI;KAAA;IAGvB,OAAO;QACN;QACA;QACA;QACA;QACA,GAAG,6BAAA;IACJ;AACD"}},
    {"offset": {"line": 2239, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/RichTextLabel.tsx"],"sourcesContent":["import {\n\tBox,\n\tDefaultFontFamilies,\n\tExtractShapeByProps,\n\tTLDefaultFillStyle,\n\tTLDefaultFontStyle,\n\tTLDefaultHorizontalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n\tTLEventInfo,\n\tTLRichText,\n\tTLShapeId,\n\topenWindow,\n\tpreventDefault,\n\tuseEditor,\n\tuseReactor,\n\tuseValue,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport React, { useMemo } from 'react'\nimport { renderHtmlFromRichText } from '../../utils/text/richText'\nimport { RichTextArea } from '../text/RichTextArea'\nimport { TEXT_PROPS } from './default-shape-constants'\nimport { isLegacyAlign } from './legacyProps'\nimport { useEditableRichText } from './useEditableRichText'\n\n/** @public */\nexport interface RichTextLabelProps {\n\tshapeId: TLShapeId\n\ttype: ExtractShapeByProps<{ richText: TLRichText }>['type']\n\tfont: TLDefaultFontStyle\n\tfontSize: number\n\tlineHeight: number\n\tfill?: TLDefaultFillStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\trichText?: TLRichText\n\tlabelColor: string\n\tbounds?: Box\n\tisSelected: boolean\n\tonKeyDown?(e: KeyboardEvent): void\n\tclassNamePrefix?: string\n\tstyle?: React.CSSProperties\n\ttextWidth?: number\n\ttextHeight?: number\n\tpadding?: number\n\thasCustomTabBehavior?: boolean\n\tshowTextOutline?: boolean\n}\n\n/**\n * Renders a text label that can be used inside of shapes.\n * The component has the ability to be edited in place and furthermore\n * supports rich text editing.\n *\n * @public @react\n */\nexport const RichTextLabel = React.memo(function RichTextLabel({\n\tshapeId,\n\ttype,\n\trichText,\n\tlabelColor,\n\tfont,\n\tfontSize,\n\tlineHeight,\n\talign,\n\tverticalAlign,\n\twrap,\n\tisSelected,\n\tpadding = 0,\n\tonKeyDown: handleKeyDownCustom,\n\tclassNamePrefix,\n\tstyle,\n\ttextWidth,\n\ttextHeight,\n\thasCustomTabBehavior,\n\tshowTextOutline = true,\n}: RichTextLabelProps) {\n\tconst editor = useEditor()\n\tconst isDragging = React.useRef(false)\n\tconst { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } =\n\t\tuseEditableRichText(shapeId, type, richText)\n\n\tconst html = useMemo(() => {\n\t\tif (richText) {\n\t\t\treturn renderHtmlFromRichText(editor, richText)\n\t\t}\n\t}, [editor, richText])\n\n\tconst selectToolActive = useValue(\n\t\t'isSelectToolActive',\n\t\t() => editor.getCurrentToolId() === 'select',\n\t\t[editor]\n\t)\n\n\tuseReactor(\n\t\t'isDragging',\n\t\t() => {\n\t\t\teditor.getInstanceState()\n\t\t\tisDragging.current = editor.inputs.getIsDragging()\n\t\t},\n\t\t[editor]\n\t)\n\n\tconst legacyAlign = isLegacyAlign(align)\n\n\tconst handlePointerDown = (e: React.MouseEvent<HTMLDivElement>) => {\n\t\tif (e.target instanceof HTMLElement && (e.target.tagName === 'A' || e.target.closest('a'))) {\n\t\t\t// This mousedown prevent default is to let dragging when over a link work.\n\t\t\tpreventDefault(e)\n\n\t\t\tif (!selectToolActive) return\n\t\t\tconst link = e.target.closest('a')?.getAttribute('href') ?? ''\n\t\t\t// We don't get the mouseup event later because we preventDefault\n\t\t\t// so we have to do it manually.\n\t\t\tconst handlePointerUp = (e: TLEventInfo) => {\n\t\t\t\tif (e.name !== 'pointer_up' || !link) return\n\n\t\t\t\tif (!isDragging.current) {\n\t\t\t\t\topenWindow(link, '_blank', false)\n\t\t\t\t}\n\t\t\t\teditor.off('event', handlePointerUp)\n\t\t\t}\n\t\t\teditor.on('event', handlePointerUp)\n\t\t}\n\t}\n\n\t// Should be guarded higher up so that this doesn't render... but repeated here. This should never be true.\n\tif (!isEditing && isEmpty) return null\n\n\t// TODO: probably combine tl-text and tl-arrow eventually\n\tconst cssPrefix = classNamePrefix || 'tl-text'\n\treturn (\n\t\t<div\n\t\t\tclassName={classNames(\n\t\t\t\t`${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`,\n\t\t\t\tshowTextOutline ? 'tl-text__outline' : 'tl-text__no-outline'\n\t\t\t)}\n\t\t\taria-hidden={!isEditing}\n\t\t\tdata-font={font}\n\t\t\tdata-align={align}\n\t\t\tdata-hastext={!isEmpty}\n\t\t\tdata-isediting={isEditing}\n\t\t\tdata-textwrap={!!wrap}\n\t\t\tdata-isselected={isSelected}\n\t\t\tstyle={{\n\t\t\t\tjustifyContent: align === 'middle' || legacyAlign ? 'center' : align,\n\t\t\t\talignItems: verticalAlign === 'middle' ? 'center' : verticalAlign,\n\t\t\t\tpadding,\n\t\t\t\t...style,\n\t\t\t}}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName={`${cssPrefix}-label__inner tl-text-content__wrapper`}\n\t\t\t\tstyle={{\n\t\t\t\t\tfontSize,\n\t\t\t\t\tlineHeight: lineHeight.toString(),\n\t\t\t\t\tminHeight: Math.floor(fontSize * lineHeight) + 'px',\n\t\t\t\t\tminWidth: Math.ceil(textWidth || 0),\n\t\t\t\t\tcolor: labelColor,\n\t\t\t\t\twidth: textWidth ? Math.ceil(textWidth) : undefined,\n\t\t\t\t\theight: textHeight ? Math.ceil(textHeight) : undefined,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div className={`${cssPrefix} tl-text tl-text-content`} dir=\"auto\">\n\t\t\t\t\t{richText && (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"tl-rich-text\"\n\t\t\t\t\t\t\tdata-is-select-tool-active={selectToolActive}\n\t\t\t\t\t\t\t// todo: see if I can abuse this\n\t\t\t\t\t\t\tdangerouslySetInnerHTML={{ __html: html || '' }}\n\t\t\t\t\t\t\tonPointerDown={handlePointerDown}\n\t\t\t\t\t\t\tdata-is-ready-for-editing={isReadyForEditing}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{(isReadyForEditing || isSelected) && (\n\t\t\t\t\t<RichTextArea\n\t\t\t\t\t\t// Fudge the ref type because we're using forwardRef and it's not typed correctly.\n\t\t\t\t\t\tref={rInput as any}\n\t\t\t\t\t\trichText={richText}\n\t\t\t\t\t\tisEditing={isEditing}\n\t\t\t\t\t\tshapeId={shapeId}\n\t\t\t\t\t\t{...editableTextRest}\n\t\t\t\t\t\thasCustomTabBehavior={hasCustomTabBehavior}\n\t\t\t\t\t\thandleKeyDown={handleKeyDownCustom ?? editableTextRest.handleKeyDown}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n\n/** @public */\nexport interface RichTextSVGProps {\n\tbounds: Box\n\trichText: TLRichText\n\tfontSize: number\n\tfont: TLDefaultFontStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\tlabelColor: string\n\tpadding: number\n\tshowTextOutline?: boolean\n}\n\n/**\n * Renders a rich text string as SVG given bounds and text properties.\n *\n * @public @react\n */\nexport function RichTextSVG({\n\tbounds,\n\trichText,\n\tfontSize,\n\tfont,\n\talign,\n\tverticalAlign,\n\twrap,\n\tlabelColor,\n\tpadding,\n\tshowTextOutline = true,\n}: RichTextSVGProps) {\n\tconst editor = useEditor()\n\tconst html = renderHtmlFromRichText(editor, richText)\n\tconst textAlign =\n\t\talign === 'middle'\n\t\t\t? ('center' as const)\n\t\t\t: align === 'start'\n\t\t\t\t? ('start' as const)\n\t\t\t\t: ('end' as const)\n\tconst justifyContent =\n\t\talign === 'middle'\n\t\t\t? ('center' as const)\n\t\t\t: align === 'start'\n\t\t\t\t? ('flex-start' as const)\n\t\t\t\t: ('flex-end' as const)\n\tconst alignItems =\n\t\tverticalAlign === 'middle' ? 'center' : verticalAlign === 'start' ? 'flex-start' : 'flex-end'\n\tconst wrapperStyle = {\n\t\tdisplay: 'flex',\n\t\tfontFamily: DefaultFontFamilies[font],\n\t\theight: `100%`,\n\t\tjustifyContent,\n\t\talignItems,\n\t\tpadding: `${padding}px`,\n\t}\n\tconst style = {\n\t\tfontSize: `${fontSize}px`,\n\t\twrap: wrap ? 'wrap' : 'nowrap',\n\t\tcolor: labelColor,\n\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\ttextAlign,\n\t\twidth: '100%',\n\t\twordWrap: 'break-word' as const,\n\t\toverflowWrap: 'break-word' as const,\n\t\twhiteSpace: 'pre-wrap',\n\t\ttextShadow: showTextOutline ? 'var(--tl-text-outline)' : 'none',\n\t\ttabSize: 'var(--tl-tab-size, 2)',\n\t}\n\n\treturn (\n\t\t<foreignObject\n\t\t\tx={bounds.minX}\n\t\t\ty={bounds.minY}\n\t\t\twidth={bounds.w}\n\t\t\theight={bounds.h}\n\t\t\tclassName={classNames(\n\t\t\t\t'tl-export-embed-styles tl-rich-text tl-rich-text-svg',\n\t\t\t\tshowTextOutline ? 'tl-text__outline' : 'tl-text__no-outline'\n\t\t\t)}\n\t\t>\n\t\t\t<div style={wrapperStyle}>\n\t\t\t\t<div dangerouslySetInnerHTML={{ __html: html }} style={style} />\n\t\t\t</div>\n\t\t</foreignObject>\n\t)\n}\n"],"names":["RichTextLabel", "e"],"mappings":";;;;;;AAwJG,SAcG,KAdH;;;;;;AAxJH;AAiBA,OAAO,gBAAgB;AACvB,OAAO,SAAS,eAAe;AAC/B,SAAS,8BAA8B;AACvC,SAAS,oBAAoB;AAC7B,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B,SAAS,2BAA2B;;;;;;;;;;AAkC7B,MAAM,gBAAgB,0NAAA,CAAM,IAAA,CAAK,SAASA,eAAc,EAC9D,OAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,UAAU,CAAA,EACV,WAAW,mBAAA,EACX,eAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACA,oBAAA,EACA,kBAAkB,IAAA,EACnB,EAAuB;IACtB,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,aAAa,0NAAA,CAAM,MAAA,CAAO,KAAK;IACrC,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,SAAA,EAAW,iBAAA,EAAmB,GAAG,iBAAiB,CAAA,OAC1E,oQAAA,EAAoB,SAAS,MAAM,QAAQ;IAE5C,MAAM,WAAO,0NAAA;sDAAQ,MAAM;YAC1B,IAAI,UAAU;gBACb,WAAO,yPAAA,EAAuB,QAAQ,QAAQ;YAC/C;QACD;qDAAG;QAAC;QAAQ,QAAQ;KAAC;IAErB,MAAM,uBAAmB,oOAAA,EACxB;mEACA,IAAM,OAAO,gBAAA,CAAiB,MAAM;kEACpC;QAAC,MAAM;KAAA;IAGR,IAAA,sOAAA,EACC;mDACA,MAAM;YACL,OAAO,gBAAA,CAAiB;YACxB,WAAW,OAAA,GAAU,OAAO,MAAA,CAAO,aAAA,CAAc;QAClD;kDACA;QAAC,MAAM;KAAA;IAGR,MAAM,kBAAc,sPAAA,EAAc,KAAK;IAEvC,MAAM,oBAAoB,CAAC,MAAwC;QAClE,IAAI,EAAE,MAAA,YAAkB,eAAA,CAAgB,EAAE,MAAA,CAAO,OAAA,KAAY,OAAO,EAAE,MAAA,CAAO,OAAA,CAAQ,GAAG,CAAA,GAAI;YAE3F,IAAA,gPAAA,EAAe,CAAC;YAEhB,IAAI,CAAC,iBAAkB,CAAA;YACvB,MAAM,OAAO,EAAE,MAAA,CAAO,OAAA,CAAQ,GAAG,GAAG,aAAa,MAAM,KAAK;YAG5D,MAAM,kBAAkB,CAACC,OAAmB;gBAC3C,IAAIA,GAAE,IAAA,KAAS,gBAAgB,CAAC,KAAM,CAAA;gBAEtC,IAAI,CAAC,WAAW,OAAA,EAAS;oBACxB,IAAA,uPAAA,EAAW,MAAM,UAAU,KAAK;gBACjC;gBACA,OAAO,GAAA,CAAI,SAAS,eAAe;YACpC;YACA,OAAO,EAAA,CAAG,SAAS,eAAe;QACnC;IACD;IAGA,IAAI,CAAC,aAAa,QAAS,CAAA,OAAO;IAGlC,MAAM,YAAY,mBAAmB;IACrC,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;QACA,eAAW,mMAAA,EACV,GAAG,SAAS,CAAA,2CAAA,CAAA,EACZ,kBAAkB,qBAAqB;QAExC,eAAa,CAAC;QACd,aAAW;QACX,cAAY;QACZ,gBAAc,CAAC;QACf,kBAAgB;QAChB,iBAAe,CAAC,CAAC;QACjB,mBAAiB;QACjB,OAAO;YACN,gBAAgB,UAAU,YAAY,cAAc,WAAW;YAC/D,YAAY,kBAAkB,WAAW,WAAW;YACpD;YACA,GAAG,KAAA;QACJ;QAEA,UAAA,aAAA,GAAA,IAAA,gOAAA,EAAC,OAAA;YACA,WAAW,GAAG,SAAS,CAAA,sCAAA,CAAA;YACvB,OAAO;gBACN;gBACA,YAAY,WAAW,QAAA,CAAS;gBAChC,WAAW,KAAK,KAAA,CAAM,WAAW,UAAU,IAAI;gBAC/C,UAAU,KAAK,IAAA,CAAK,aAAa,CAAC;gBAClC,OAAO;gBACP,OAAO,YAAY,KAAK,IAAA,CAAK,SAAS,IAAI,KAAA;gBAC1C,QAAQ,aAAa,KAAK,IAAA,CAAK,UAAU,IAAI,KAAA;YAC9C;YAEA,UAAA;gBAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;oBAAI,WAAW,GAAG,SAAS,CAAA,wBAAA,CAAA;oBAA4B,KAAI;oBAC1D,UAAA,YACA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;wBACA,WAAU;wBACV,8BAA4B;wBAE5B,yBAAyB;4BAAE,QAAQ,QAAQ;wBAAG;wBAC9C,eAAe;wBACf,6BAA2B;oBAAA;gBAC5B,CAEF;gBAAA,CACE,qBAAqB,UAAA,KACtB,aAAA,GAAA,IAAA,+NAAA,EAAC,oPAAA,EAAA;oBAEA,KAAK;oBACL;oBACA;oBACA;oBACC,GAAG,gBAAA;oBACJ;oBACA,eAAe,uBAAuB,iBAAiB,aAAA;gBAAA;aACxD;QAAA;IAEF;AAGH,CAAC;AAqBM,SAAS,YAAY,EAC3B,MAAA,EACA,QAAA,EACA,QAAA,EACA,IAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,OAAA,EACA,kBAAkB,IAAA,EACnB,EAAqB;IACpB,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,WAAO,yPAAA,EAAuB,QAAQ,QAAQ;IACpD,MAAM,YACL,UAAU,WACN,WACD,UAAU,UACR,UACA;IACN,MAAM,iBACL,UAAU,WACN,WACD,UAAU,UACR,eACA;IACN,MAAM,aACL,kBAAkB,WAAW,WAAW,kBAAkB,UAAU,eAAe;IACpF,MAAM,eAAe;QACpB,SAAS;QACT,YAAY,yOAAA,CAAoB,IAAI,CAAA;QACpC,QAAQ,CAAA,IAAA,CAAA;QACR;QACA;QACA,SAAS,GAAG,OAAO,CAAA,EAAA,CAAA;IACpB;IACA,MAAM,QAAQ;QACb,UAAU,GAAG,QAAQ,CAAA,EAAA,CAAA;QACrB,MAAM,OAAO,SAAS;QACtB,OAAO;QACP,YAAY,qQAAA,CAAW,UAAA;QACvB;QACA,OAAO;QACP,UAAU;QACV,cAAc;QACd,YAAY;QACZ,YAAY,kBAAkB,2BAA2B;QACzD,SAAS;IACV;IAEA,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,iBAAA;QACA,GAAG,OAAO,IAAA;QACV,GAAG,OAAO,IAAA;QACV,OAAO,OAAO,CAAA;QACd,QAAQ,OAAO,CAAA;QACf,eAAW,mMAAA,EACV,wDACA,kBAAkB,qBAAqB;QAGxC,UAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;YAAI,OAAO;YACX,UAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;gBAAI,yBAAyB;oBAAE,QAAQ;gBAAK;gBAAG;YAAA,CAAc;QAAA,CAC/D;IAAA;AAGH"}},
    {"offset": {"line": 2416, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/defaultStyleDefs.tsx"],"sourcesContent":["import {\n\tDefaultColorThemePalette,\n\tDefaultFontStyle,\n\tSvgExportDef,\n\tTLDefaultColorTheme,\n\tTLDefaultFillStyle,\n\tTLShapeUtilCanvasSvgDef,\n\tdebugFlags,\n\tlast,\n\tsuffixSafeId,\n\ttlenv,\n\tuseEditor,\n\tuseSharedSafeId,\n\tuseUniqueSafeId,\n\tuseValue,\n} from '@tldraw/editor'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { useDefaultColorTheme } from './useDefaultColorTheme'\n\n/** @public */\nexport function getFillDefForExport(fill: TLDefaultFillStyle): SvgExportDef {\n\treturn {\n\t\tkey: `${DefaultFontStyle.id}:${fill}`,\n\t\tasync getElement() {\n\t\t\tif (fill !== 'pattern') return null\n\n\t\t\treturn <HashPatternForExport />\n\t\t},\n\t}\n}\n\nfunction HashPatternForExport() {\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\tconst maskId = useUniqueSafeId()\n\tconst theme = useDefaultColorTheme()\n\tconst t = 8 / 12\n\treturn (\n\t\t<>\n\t\t\t<mask id={maskId}>\n\t\t\t\t<rect x=\"0\" y=\"0\" width=\"8\" height=\"8\" fill=\"white\" />\n\t\t\t\t<g strokeLinecap=\"round\" stroke=\"black\">\n\t\t\t\t\t<line x1={t * 1} y1={t * 3} x2={t * 3} y2={t * 1} />\n\t\t\t\t\t<line x1={t * 5} y1={t * 7} x2={t * 7} y2={t * 5} />\n\t\t\t\t\t<line x1={t * 9} y1={t * 11} x2={t * 11} y2={t * 9} />\n\t\t\t\t</g>\n\t\t\t</mask>\n\t\t\t<pattern\n\t\t\t\tid={getHashPatternZoomName(1, theme.id)}\n\t\t\t\twidth=\"8\"\n\t\t\t\theight=\"8\"\n\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t>\n\t\t\t\t<rect x=\"0\" y=\"0\" width=\"8\" height=\"8\" fill={theme.solid} mask={`url(#${maskId})`} />\n\t\t\t</pattern>\n\t\t</>\n\t)\n}\n\nexport function getFillDefForCanvas(): TLShapeUtilCanvasSvgDef {\n\treturn {\n\t\tkey: `${DefaultFontStyle.id}:pattern`,\n\t\tcomponent: PatternFillDefForCanvas,\n\t}\n}\nconst TILE_PATTERN_SIZE = 8\n\nconst generateImage = (dpr: number, currentZoom: number, darkMode: boolean) => {\n\treturn new Promise<Blob>((resolve, reject) => {\n\t\tconst size = TILE_PATTERN_SIZE * currentZoom * dpr\n\n\t\tconst canvasEl = document.createElement('canvas')\n\t\tcanvasEl.width = size\n\t\tcanvasEl.height = size\n\n\t\tconst ctx = canvasEl.getContext('2d')\n\t\tif (!ctx) return\n\n\t\tctx.fillStyle = darkMode\n\t\t\t? DefaultColorThemePalette.darkMode.solid\n\t\t\t: DefaultColorThemePalette.lightMode.solid\n\t\tctx.fillRect(0, 0, size, size)\n\n\t\t// This essentially generates an inverse of the pattern we're drawing.\n\t\tctx.globalCompositeOperation = 'destination-out'\n\n\t\tctx.lineCap = 'round'\n\t\tctx.lineWidth = 1.25 * currentZoom * dpr\n\n\t\tconst t = 8 / 12\n\t\tconst s = (v: number) => v * currentZoom * dpr\n\n\t\tctx.beginPath()\n\t\tctx.moveTo(s(t * 1), s(t * 3))\n\t\tctx.lineTo(s(t * 3), s(t * 1))\n\n\t\tctx.moveTo(s(t * 5), s(t * 7))\n\t\tctx.lineTo(s(t * 7), s(t * 5))\n\n\t\tctx.moveTo(s(t * 9), s(t * 11))\n\t\tctx.lineTo(s(t * 11), s(t * 9))\n\t\tctx.stroke()\n\n\t\tcanvasEl.toBlob((blob) => {\n\t\t\tif (!blob || debugFlags.throwToBlob.get()) {\n\t\t\t\treject()\n\t\t\t} else {\n\t\t\t\tresolve(blob)\n\t\t\t}\n\t\t})\n\t})\n}\n\nconst canvasBlob = (size: [number, number], fn: (ctx: CanvasRenderingContext2D) => void) => {\n\tconst canvas = document.createElement('canvas')\n\tcanvas.width = size[0]\n\tcanvas.height = size[1]\n\tconst ctx = canvas.getContext('2d')\n\tif (!ctx) return ''\n\tfn(ctx)\n\treturn canvas.toDataURL()\n}\ninterface PatternDef {\n\tzoom: number\n\turl: string\n\ttheme: 'light' | 'dark'\n}\n\nlet defaultPixels: { white: string; black: string } | null = null\nfunction getDefaultPixels() {\n\tif (!defaultPixels) {\n\t\tdefaultPixels = {\n\t\t\twhite: canvasBlob([1, 1], (ctx) => {\n\t\t\t\tctx.fillStyle = '#f8f9fa'\n\t\t\t\tctx.fillRect(0, 0, 1, 1)\n\t\t\t}),\n\t\t\tblack: canvasBlob([1, 1], (ctx) => {\n\t\t\t\tctx.fillStyle = '#212529'\n\t\t\t\tctx.fillRect(0, 0, 1, 1)\n\t\t\t}),\n\t\t}\n\t}\n\treturn defaultPixels\n}\n\nfunction getPatternLodForZoomLevel(zoom: number) {\n\treturn Math.ceil(Math.log2(Math.max(1, zoom)))\n}\n\nexport function useGetHashPatternZoomName() {\n\tconst id = useSharedSafeId('hash_pattern')\n\treturn useCallback(\n\t\t(zoom: number, theme: TLDefaultColorTheme['id']) => {\n\t\t\tconst lod = getPatternLodForZoomLevel(zoom)\n\t\t\treturn suffixSafeId(id, `${theme}_${lod}`)\n\t\t},\n\t\t[id]\n\t)\n}\n\nfunction getPatternLodsToGenerate(maxZoom: number) {\n\tconst levels = []\n\tconst minLod = 0\n\tconst maxLod = getPatternLodForZoomLevel(maxZoom)\n\tfor (let i = minLod; i <= maxLod; i++) {\n\t\tlevels.push(Math.pow(2, i))\n\t}\n\treturn levels\n}\n\nfunction getDefaultPatterns(maxZoom: number): PatternDef[] {\n\tconst defaultPixels = getDefaultPixels()\n\treturn getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [\n\t\t{ zoom, url: defaultPixels.white, theme: 'light' },\n\t\t{ zoom, url: defaultPixels.black, theme: 'dark' },\n\t])\n}\n\nfunction usePattern() {\n\tconst editor = useEditor()\n\tconst dpr = useValue('devicePixelRatio', () => editor.getInstanceState().devicePixelRatio, [\n\t\teditor,\n\t])\n\tconst maxZoom = useValue('maxZoom', () => Math.ceil(last(editor.getCameraOptions().zoomSteps)!), [\n\t\teditor,\n\t])\n\tconst [isReady, setIsReady] = useState(false)\n\tconst [backgroundUrls, setBackgroundUrls] = useState<PatternDef[]>(() =>\n\t\tgetDefaultPatterns(maxZoom)\n\t)\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\n\tuseEffect(() => {\n\t\tif (process.env.NODE_ENV === 'test') {\n\t\t\tsetIsReady(true)\n\t\t\treturn\n\t\t}\n\n\t\tconst promise = Promise.all(\n\t\t\tgetPatternLodsToGenerate(maxZoom).flatMap<Promise<PatternDef>>((zoom) => [\n\t\t\t\tgenerateImage(dpr, zoom, false).then((blob) => ({\n\t\t\t\t\tzoom,\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\turl: URL.createObjectURL(blob),\n\t\t\t\t})),\n\t\t\t\tgenerateImage(dpr, zoom, true).then((blob) => ({\n\t\t\t\t\tzoom,\n\t\t\t\t\ttheme: 'dark',\n\t\t\t\t\turl: URL.createObjectURL(blob),\n\t\t\t\t})),\n\t\t\t])\n\t\t)\n\n\t\tlet isCancelled = false\n\t\tpromise.then((urls) => {\n\t\t\tif (isCancelled) return\n\t\t\tsetBackgroundUrls(urls)\n\t\t\tsetIsReady(true)\n\t\t})\n\t\treturn () => {\n\t\t\tisCancelled = true\n\t\t\tsetIsReady(false)\n\t\t\tpromise.then((patterns) => {\n\t\t\t\tfor (const { url } of patterns) {\n\t\t\t\t\tURL.revokeObjectURL(url)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}, [dpr, maxZoom])\n\n\tconst defs = (\n\t\t<>\n\t\t\t{backgroundUrls.map((item) => {\n\t\t\t\tconst id = getHashPatternZoomName(item.zoom, item.theme)\n\t\t\t\treturn (\n\t\t\t\t\t<pattern\n\t\t\t\t\t\tkey={id}\n\t\t\t\t\t\tid={id}\n\t\t\t\t\t\twidth={TILE_PATTERN_SIZE}\n\t\t\t\t\t\theight={TILE_PATTERN_SIZE}\n\t\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<image href={item.url} width={TILE_PATTERN_SIZE} height={TILE_PATTERN_SIZE} />\n\t\t\t\t\t</pattern>\n\t\t\t\t)\n\t\t\t})}\n\t\t</>\n\t)\n\n\treturn { defs, isReady }\n}\n\nfunction PatternFillDefForCanvas() {\n\tconst editor = useEditor()\n\tconst containerRef = useRef<SVGGElement>(null)\n\tconst { defs, isReady } = usePattern()\n\n\tuseEffect(() => {\n\t\tif (isReady && tlenv.isSafari) {\n\t\t\tconst htmlLayer = findHtmlLayerParent(containerRef.current!)\n\t\t\tif (htmlLayer) {\n\t\t\t\t// Wait for `patternContext` to be picked up\n\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\thtmlLayer.style.display = 'none'\n\n\t\t\t\t\t// Wait for 'display = \"none\"' to take effect\n\t\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\t\thtmlLayer.style.display = ''\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}, [editor, isReady])\n\n\treturn (\n\t\t<g ref={containerRef} data-testid={isReady ? 'ready-pattern-fill-defs' : undefined}>\n\t\t\t{defs}\n\t\t</g>\n\t)\n}\n\nfunction findHtmlLayerParent(element: Element): HTMLElement | null {\n\tif (element.classList.contains('tl-html-layer')) return element as HTMLElement\n\tif (element.parentElement) return findHtmlLayerParent(element.parentElement)\n\treturn null\n}\n"],"names":["defaultPixels"],"mappings":";;;;;;;;AAgMM,QAAQ,IAAI,aAAa,QAAQ;AAtK7B,SAWR,UAXQ,KAcN,YAdM;AA1BV;;;;;;;;AAgBA,SAAS,aAAa,WAAW,QAAQ,gBAAgB;AACzD,SAAS,4BAA4B;;;;;AAG9B,SAAS,oBAAoB,IAAA,EAAwC;IAC3E,OAAO;QACN,KAAK,GAAG,sOAAA,CAAiB,EAAE,CAAA,CAAA,EAAI,IAAI,EAAA;QACnC,MAAM,aAAa;YAClB,IAAI,SAAS,UAAW,CAAA,OAAO;YAE/B,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,sBAAA,CAAA,CAAqB;QAC9B;IACD;AACD;AAEA,SAAS,uBAAuB;IAC/B,MAAM,yBAAyB,0BAA0B;IACzD,MAAM,aAAS,uPAAA,CAAgB;IAC/B,MAAM,YAAQ,sQAAA,CAAqB;IACnC,MAAM,IAAI,IAAI;IACd,OACC,aAAA,GAAA,IAAA,gOAAA,EAAA,oOAAA,EAAA;QACC,UAAA;YAAA,aAAA,GAAA,IAAA,gOAAA,EAAC,QAAA;gBAAK,IAAI;gBACT,UAAA;oBAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;wBAAK,GAAE;wBAAI,GAAE;wBAAI,OAAM;wBAAI,QAAO;wBAAI,MAAK;oBAAA,CAAQ;oBACpD,aAAA,GAAA,IAAA,gOAAA,EAAC,KAAA;wBAAE,eAAc;wBAAQ,QAAO;wBAC/B,UAAA;4BAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gCAAK,IAAI,IAAI;gCAAG,IAAI,IAAI;gCAAG,IAAI,IAAI;gCAAG,IAAI,IAAI;4BAAA,CAAG;4BAClD,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gCAAK,IAAI,IAAI;gCAAG,IAAI,IAAI;gCAAG,IAAI,IAAI;gCAAG,IAAI,IAAI;4BAAA,CAAG;4BAClD,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gCAAK,IAAI,IAAI;gCAAG,IAAI,IAAI;gCAAI,IAAI,IAAI;gCAAI,IAAI,IAAI;4BAAA,CAAG;yBAAA;oBAAA,CACrD;iBAAA;YAAA,CACD;YACA,aAAA,GAAA,IAAA,+NAAA,EAAC,WAAA;gBACA,IAAI,uBAAuB,GAAG,MAAM,EAAE;gBACtC,OAAM;gBACN,QAAO;gBACP,cAAa;gBAEb,UAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;oBAAK,GAAE;oBAAI,GAAE;oBAAI,OAAM;oBAAI,QAAO;oBAAI,MAAM,MAAM,KAAA;oBAAO,MAAM,CAAA,KAAA,EAAQ,MAAM,CAAA,CAAA,CAAA;gBAAA,CAAK;YAAA;SACpF;IAAA,CACD;AAEF;AAEO,SAAS,sBAA+C;IAC9D,OAAO;QACN,KAAK,GAAG,sOAAA,CAAiB,EAAE,CAAA,QAAA,CAAA;QAC3B,WAAW;IACZ;AACD;AACA,MAAM,oBAAoB;AAE1B,MAAM,gBAAgB,CAAC,KAAa,aAAqB,aAAsB;IAC9E,OAAO,IAAI,QAAc,CAAC,SAAS,WAAW;QAC7C,MAAM,OAAO,oBAAoB,cAAc;QAE/C,MAAM,WAAW,SAAS,aAAA,CAAc,QAAQ;QAChD,SAAS,KAAA,GAAQ;QACjB,SAAS,MAAA,GAAS;QAElB,MAAM,MAAM,SAAS,UAAA,CAAW,IAAI;QACpC,IAAI,CAAC,IAAK,CAAA;QAEV,IAAI,SAAA,GAAY,WACb,8OAAA,CAAyB,QAAA,CAAS,KAAA,GAClC,8OAAA,CAAyB,SAAA,CAAU,KAAA;QACtC,IAAI,QAAA,CAAS,GAAG,GAAG,MAAM,IAAI;QAG7B,IAAI,wBAAA,GAA2B;QAE/B,IAAI,OAAA,GAAU;QACd,IAAI,SAAA,GAAY,OAAO,cAAc;QAErC,MAAM,IAAI,IAAI;QACd,MAAM,IAAI,CAAC,IAAc,IAAI,cAAc;QAE3C,IAAI,SAAA,CAAU;QACd,IAAI,MAAA,CAAO,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7B,IAAI,MAAA,CAAO,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAE7B,IAAI,MAAA,CAAO,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7B,IAAI,MAAA,CAAO,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAE7B,IAAI,MAAA,CAAO,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;QAC9B,IAAI,MAAA,CAAO,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QAC9B,IAAI,MAAA,CAAO;QAEX,SAAS,MAAA,CAAO,CAAC,SAAS;YACzB,IAAI,CAAC,QAAQ,uPAAA,CAAW,WAAA,CAAY,GAAA,CAAI,GAAG;gBAC1C,OAAO;YACR,OAAO;gBACN,QAAQ,IAAI;YACb;QACD,CAAC;IACF,CAAC;AACF;AAEA,MAAM,aAAa,CAAC,MAAwB,OAAgD;IAC3F,MAAM,SAAS,SAAS,aAAA,CAAc,QAAQ;IAC9C,OAAO,KAAA,GAAQ,IAAA,CAAK,CAAC,CAAA;IACrB,OAAO,MAAA,GAAS,IAAA,CAAK,CAAC,CAAA;IACtB,MAAM,MAAM,OAAO,UAAA,CAAW,IAAI;IAClC,IAAI,CAAC,IAAK,CAAA,OAAO;IACjB,GAAG,GAAG;IACN,OAAO,OAAO,SAAA,CAAU;AACzB;AAOA,IAAI,gBAAyD;AAC7D,SAAS,mBAAmB;IAC3B,IAAI,CAAC,eAAe;QACnB,gBAAgB;YACf,OAAO,WAAW;gBAAC;gBAAG,CAAC;aAAA,EAAG,CAAC,QAAQ;gBAClC,IAAI,SAAA,GAAY;gBAChB,IAAI,QAAA,CAAS,GAAG,GAAG,GAAG,CAAC;YACxB,CAAC;YACD,OAAO,WAAW;gBAAC;gBAAG,CAAC;aAAA,EAAG,CAAC,QAAQ;gBAClC,IAAI,SAAA,GAAY;gBAChB,IAAI,QAAA,CAAS,GAAG,GAAG,GAAG,CAAC;YACxB,CAAC;QACF;IACD;IACA,OAAO;AACR;AAEA,SAAS,0BAA0B,IAAA,EAAc;IAChD,OAAO,KAAK,IAAA,CAAK,KAAK,IAAA,CAAK,KAAK,GAAA,CAAI,GAAG,IAAI,CAAC,CAAC;AAC9C;AAEO,SAAS,4BAA4B;IAC3C,MAAM,SAAK,uPAAA,EAAgB,cAAc;IACzC,WAAO,8NAAA;iDACN,CAAC,MAAc,UAAqC;YACnD,MAAM,MAAM,0BAA0B,IAAI;YAC1C,WAAO,oPAAA,EAAa,IAAI,GAAG,KAAK,CAAA,CAAA,EAAI,GAAG,EAAE;QAC1C;gDACA;QAAC,EAAE;KAAA;AAEL;AAEA,SAAS,yBAAyB,OAAA,EAAiB;IAClD,MAAM,SAAS,CAAC,CAAA;IAChB,MAAM,SAAS;IACf,MAAM,SAAS,0BAA0B,OAAO;IAChD,IAAA,IAAS,IAAI,QAAQ,KAAK,QAAQ,IAAK;QACtC,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,GAAG,CAAC,CAAC;IAC3B;IACA,OAAO;AACR;AAEA,SAAS,mBAAmB,OAAA,EAA+B;IAC1D,MAAMA,iBAAgB,iBAAiB;IACvC,OAAO,yBAAyB,OAAO,EAAE,OAAA,CAAQ,CAAC,OAAS;YAC1D;gBAAE;gBAAM,KAAKA,eAAc,KAAA;gBAAO,OAAO;YAAQ;YACjD;gBAAE;gBAAM,KAAKA,eAAc,KAAA;gBAAO,OAAO;YAAO;SAChD;AACF;AAEA,SAAS,aAAa;IACrB,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,UAAM,oOAAA,EAAS;oCAAoB,IAAM,OAAO,gBAAA,CAAiB,EAAE,gBAAA;mCAAkB;QAC1F;KACA;IACD,MAAM,cAAU,oOAAA,EAAS;wCAAW,IAAM,KAAK,IAAA,KAAK,uNAAA,EAAK,OAAO,gBAAA,CAAiB,EAAE,SAAS,CAAE;uCAAG;QAChG;KACA;IACD,MAAM,CAAC,SAAS,UAAU,CAAA,OAAI,2NAAA,EAAS,KAAK;IAC5C,MAAM,CAAC,gBAAgB,iBAAiB,CAAA,OAAI,2NAAA;+BAAuB,IAClE,mBAAmB,OAAO;;IAE3B,MAAM,yBAAyB,0BAA0B;IAEzD,IAAA,4NAAA;gCAAU,MAAM;YACf;;YAKA,MAAM,UAAU,QAAQ,GAAA,CACvB,yBAAyB,OAAO,EAAE,OAAA;gDAA6B,CAAC,OAAS;wBACxE,cAAc,KAAK,MAAM,KAAK,EAAE,IAAA;4DAAK,CAAC,OAAA,CAAU;oCAC/C;oCACA,OAAO;oCACP,KAAK,IAAI,eAAA,CAAgB,IAAI;gCAC9B,CAAA,CAAE;;wBACF,cAAc,KAAK,MAAM,IAAI,EAAE,IAAA;4DAAK,CAAC,OAAA,CAAU;oCAC9C;oCACA,OAAO;oCACP,KAAK,IAAI,eAAA,CAAgB,IAAI;gCAC9B,CAAA,CAAE;;qBACF;;YAGF,IAAI,cAAc;YAClB,QAAQ,IAAA;wCAAK,CAAC,SAAS;oBACtB,IAAI,YAAa,CAAA;oBACjB,kBAAkB,IAAI;oBACtB,WAAW,IAAI;gBAChB,CAAC;;YACD;wCAAO,MAAM;oBACZ,cAAc;oBACd,WAAW,KAAK;oBAChB,QAAQ,IAAA;gDAAK,CAAC,aAAa;4BAC1B,KAAA,MAAW,EAAE,GAAA,CAAI,CAAA,IAAK,SAAU;gCAC/B,IAAI,eAAA,CAAgB,GAAG;4BACxB;wBACD,CAAC;;gBACF;;QACD;+BAAG;QAAC;QAAK,OAAO;KAAC;IAEjB,MAAM,OACL,aAAA,GAAA,IAAA,+NAAA,EAAA,oOAAA,EAAA;QACE,UAAA,eAAe,GAAA,CAAI,CAAC,SAAS;YAC7B,MAAM,KAAK,uBAAuB,KAAK,IAAA,EAAM,KAAK,KAAK;YACvD,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,WAAA;gBAEA;gBACA,OAAO;gBACP,QAAQ;gBACR,cAAa;gBAEb,UAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,SAAA;oBAAM,MAAM,KAAK,GAAA;oBAAK,OAAO;oBAAmB,QAAQ;gBAAA,CAAmB;YAAA,GANvE;QASR,CAAC;IAAA,CACF;IAGD,OAAO;QAAE;QAAM;IAAQ;AACxB;AAEA,SAAS,0BAA0B;IAClC,MAAM,SAAS,qPAAA,CAAU;IACzB,MAAM,mBAAe,yNAAA,EAAoB,IAAI;IAC7C,MAAM,EAAE,IAAA,EAAM,OAAA,CAAQ,CAAA,GAAI,WAAW;IAErC,IAAA,4NAAA;6CAAU,MAAM;YACf,IAAI,WAAW,iPAAA,CAAM,QAAA,EAAU;gBAC9B,MAAM,YAAY,oBAAoB,aAAa,OAAQ;gBAC3D,IAAI,WAAW;oBAEd,OAAO,MAAA,CAAO,qBAAA;6DAAsB,MAAM;4BACzC,UAAU,KAAA,CAAM,OAAA,GAAU;4BAG1B,OAAO,MAAA,CAAO,qBAAA;qEAAsB,MAAM;oCACzC,UAAU,KAAA,CAAM,OAAA,GAAU;gCAC3B,CAAC;;wBACF,CAAC;;gBACF;YACD;QACD;4CAAG;QAAC;QAAQ,OAAO;KAAC;IAEpB,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,KAAA;QAAE,KAAK;QAAc,eAAa,UAAU,4BAA4B,KAAA;QACvE,UAAA;IAAA,CACF;AAEF;AAEA,SAAS,oBAAoB,OAAA,EAAsC;IAClE,IAAI,QAAQ,SAAA,CAAU,QAAA,CAAS,eAAe,EAAG,CAAA,OAAO;IACxD,IAAI,QAAQ,aAAA,CAAe,CAAA,OAAO,oBAAoB,QAAQ,aAAa;IAC3E,OAAO;AACR"}},
    {"offset": {"line": 2746, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/ShapeFill.tsx"],"sourcesContent":["import {\n\tgetColorValue,\n\tTLDefaultColorStyle,\n\tTLDefaultColorTheme,\n\tTLDefaultFillStyle,\n\tuseEditor,\n\tuseSvgExportContext,\n\tuseValue,\n} from '@tldraw/editor'\nimport React from 'react'\nimport { useGetHashPatternZoomName } from './defaultStyleDefs'\n\ninterface ShapeFillProps {\n\td: string\n\tfill: TLDefaultFillStyle\n\tcolor: TLDefaultColorStyle\n\ttheme: TLDefaultColorTheme\n\tscale: number\n}\n\nexport const ShapeFill = React.memo(function ShapeFill({\n\ttheme,\n\td,\n\tcolor,\n\tfill,\n\tscale,\n}: ShapeFillProps) {\n\tswitch (fill) {\n\t\tcase 'none': {\n\t\t\treturn null\n\t\t}\n\t\tcase 'solid': {\n\t\t\treturn <path fill={getColorValue(theme, color, 'semi')} d={d} />\n\t\t}\n\t\tcase 'semi': {\n\t\t\treturn <path fill={theme.solid} d={d} />\n\t\t}\n\t\tcase 'fill': {\n\t\t\treturn <path fill={getColorValue(theme, color, 'fill')} d={d} />\n\t\t}\n\t\tcase 'pattern': {\n\t\t\treturn <PatternFill theme={theme} color={color} fill={fill} d={d} scale={scale} />\n\t\t}\n\t\tcase 'lined-fill': {\n\t\t\treturn <path fill={getColorValue(theme, color, 'linedFill')} d={d} />\n\t\t}\n\t}\n})\n\nexport function PatternFill({ d, color, theme }: ShapeFillProps) {\n\tconst editor = useEditor()\n\tconst svgExport = useSvgExportContext()\n\tconst zoomLevel = useValue('zoomLevel', () => editor.getEfficientZoomLevel(), [editor])\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\n\tconst teenyTiny = zoomLevel <= 0.18\n\n\treturn (\n\t\t<>\n\t\t\t<path fill={getColorValue(theme, color, 'pattern')} d={d} />\n\t\t\t<path\n\t\t\t\tfill={\n\t\t\t\t\tsvgExport\n\t\t\t\t\t\t? `url(#${getHashPatternZoomName(1, theme.id)})`\n\t\t\t\t\t\t: teenyTiny\n\t\t\t\t\t\t\t? getColorValue(theme, color, 'semi')\n\t\t\t\t\t\t\t: `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`\n\t\t\t\t}\n\t\t\t\td={d}\n\t\t\t/>\n\t\t</>\n\t)\n}\n"],"names":["ShapeFill"],"mappings":";;;;;;AAgCU,SA0BR,UA1BQ,KA0BR,YA1BQ;;;;;AAhCV;AASA,OAAO,WAAW;AAClB,SAAS,iCAAiC;;;;;AAUnC,MAAM,YAAY,0NAAA,CAAM,IAAA,CAAK,SAASA,WAAU,EACtD,KAAA,EACA,CAAA,EACA,KAAA,EACA,IAAA,EACA,KAAA,EACD,EAAmB;IAClB,OAAQ,MAAM;QACb,KAAK;YAAQ;gBACZ,OAAO;YACR;QACA,KAAK;YAAS;gBACb,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;oBAAK,UAAM,mOAAA,EAAc,OAAO,OAAO,MAAM;oBAAG;gBAAA,CAAM;YAC/D;QACA,KAAK;YAAQ;gBACZ,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;oBAAK,MAAM,MAAM,KAAA;oBAAO;gBAAA,CAAM;YACvC;QACA,KAAK;YAAQ;gBACZ,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;oBAAK,UAAM,mOAAA,EAAc,OAAO,OAAO,MAAM;oBAAG;gBAAA,CAAM;YAC/D;QACA,KAAK;YAAW;gBACf,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,aAAA;oBAAY;oBAAc;oBAAc;oBAAY;oBAAM;gBAAA,CAAc;YACjF;QACA,KAAK;YAAc;gBAClB,OAAO,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;oBAAK,UAAM,mOAAA,EAAc,OAAO,OAAO,WAAW;oBAAG;gBAAA,CAAM;YACpE;IACD;AACD,CAAC;AAEM,SAAS,YAAY,EAAE,CAAA,EAAG,KAAA,EAAO,KAAA,CAAM,CAAA,EAAmB;IAChE,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,gBAAY,4QAAA,CAAoB;IACtC,MAAM,gBAAY,oOAAA,EAAS;2CAAa,IAAM,OAAO,qBAAA,CAAsB;0CAAG;QAAC,MAAM;KAAC;IACtF,MAAM,6BAAyB,uQAAA,CAA0B;IAEzD,MAAM,YAAY,aAAa;IAE/B,OACC,aAAA,GAAA,IAAA,gOAAA,EAAA,oOAAA,EAAA;QACC,UAAA;YAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gBAAK,UAAM,mOAAA,EAAc,OAAO,OAAO,SAAS;gBAAG;YAAA,CAAM;YAC1D,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gBACA,MACC,YACG,CAAA,KAAA,EAAQ,uBAAuB,GAAG,MAAM,EAAE,CAAC,CAAA,CAAA,CAAA,GAC3C,gBACC,mOAAA,EAAc,OAAO,OAAO,MAAM,IAClC,CAAA,KAAA,EAAQ,uBAAuB,WAAW,MAAM,EAAE,CAAC,CAAA,CAAA,CAAA;gBAExD;YAAA;SACD;IAAA,CACD;AAEF"}},
    {"offset": {"line": 2839, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useEfficientZoomThreshold.ts"],"sourcesContent":["import { useEditor, useValue } from '@tldraw/editor'\n\n/** Returns true when zoomed out far enough that shapes should render in a simplified \"solid\" style. */\nexport function useEfficientZoomThreshold(threshold = 0.25) {\n\tconst editor = useEditor()\n\treturn useValue('efficient zoom threshold', () => editor.getEfficientZoomLevel() < threshold, [\n\t\teditor,\n\t\tthreshold,\n\t])\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,WAAW,gBAAgB;;AAG7B,SAAS,0BAA0B,YAAY,IAAA,EAAM;IAC3D,MAAM,aAAS,iPAAA,CAAU;IACzB,WAAO,oOAAA,EAAS;8CAA4B,IAAM,OAAO,qBAAA,CAAsB,IAAI;6CAAW;QAC7F;QACA;KACA;AACF"}},
    {"offset": {"line": 2862, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/HyperlinkButton.tsx"],"sourcesContent":["import { useEditor } from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { PointerEventHandler, useCallback } from 'react'\nimport { useEfficientZoomThreshold } from './useEfficientZoomThreshold'\n\nconst LINK_ICON =\n\t\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E\"\n\nexport function HyperlinkButton({ url }: { url: string }) {\n\tconst editor = useEditor()\n\tconst hideButton = useEfficientZoomThreshold()\n\tconst markAsHandledOnShiftKey = useCallback<PointerEventHandler>(\n\t\t(e) => {\n\t\t\tif (!editor.inputs.getShiftKey()) editor.markEventAsHandled(e)\n\t\t},\n\t\t[editor]\n\t)\n\treturn (\n\t\t<a\n\t\t\tclassName={classNames('tl-hyperlink-button', {\n\t\t\t\t'tl-hyperlink-button__hidden': hideButton,\n\t\t\t})}\n\t\t\thref={url}\n\t\t\ttarget=\"_blank\"\n\t\t\trel=\"noopener noreferrer\"\n\t\t\tonPointerDown={markAsHandledOnShiftKey}\n\t\t\tonPointerUp={markAsHandledOnShiftKey}\n\t\t\ttitle={url}\n\t\t\tdraggable={false}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName=\"tl-hyperlink__icon\"\n\t\t\t\tstyle={{\n\t\t\t\t\tmask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t\tWebkitMask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t}}\n\t\t\t/>\n\t\t</a>\n\t)\n}\n"],"names":[],"mappings":";;;;AA8BG;;AA9BH,SAAS,iBAAiB;AAC1B,OAAO,gBAAgB;AACvB,SAA8B,mBAAmB;AACjD,SAAS,iCAAiC;;;;;;AAE1C,MAAM,YACL;AAEM,SAAS,gBAAgB,EAAE,GAAA,CAAI,CAAA,EAAoB;IACzD,MAAM,aAAS,iPAAA,CAAU;IACzB,MAAM,iBAAa,gRAAA,CAA0B;IAC7C,MAAM,8BAA0B,8NAAA;gEAC/B,CAAC,MAAM;YACN,IAAI,CAAC,OAAO,MAAA,CAAO,WAAA,CAAY,EAAG,CAAA,OAAO,kBAAA,CAAmB,CAAC;QAC9D;+DACA;QAAC,MAAM;KAAA;IAER,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,KAAA;QACA,eAAW,mMAAA,EAAW,uBAAuB;YAC5C,+BAA+B;QAChC,CAAC;QACD,MAAM;QACN,QAAO;QACP,KAAI;QACJ,eAAe;QACf,aAAa;QACb,OAAO;QACP,WAAW;QAEX,UAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;YACA,WAAU;YACV,OAAO;gBACN,MAAM,CAAA,KAAA,EAAQ,SAAS,CAAA,+BAAA,CAAA;gBACvB,YAAY,CAAA,KAAA,EAAQ,SAAS,CAAA,+BAAA,CAAA;YAC9B;QAAA;IACD;AAGH"}},
    {"offset": {"line": 2914, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/icons-editor.ts"],"sourcesContent":["export const LINK_ICON =\n\t\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E\"\n"],"names":[],"mappings":";;;;AAAO,MAAM,YACZ"}},
    {"offset": {"line": 2925, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/rotated-box-shadow.ts"],"sourcesContent":["import { Vec } from '@tldraw/editor'\n\nconst ROTATING_BOX_SHADOWS = [\n\t{\n\t\toffsetX: 0,\n\t\toffsetY: 2,\n\t\tblur: 4,\n\t\tspread: 0,\n\t\tcolor: '#00000029',\n\t},\n\t{\n\t\toffsetX: 0,\n\t\toffsetY: 3,\n\t\tblur: 6,\n\t\tspread: 0,\n\t\tcolor: '#0000001f',\n\t},\n]\n\n/** @public */\nexport function getRotatedBoxShadow(rotation: number) {\n\tconst cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {\n\t\tconst { offsetX, offsetY, blur, spread, color } = shadow\n\t\tconst vec = new Vec(offsetX, offsetY)\n\t\tconst { x, y } = vec.rot(-rotation)\n\t\treturn `${x}px ${y}px ${blur}px ${spread}px ${color}`\n\t})\n\treturn cssStrings.join(', ')\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,WAAW;;AAEpB,MAAM,uBAAuB;IAC5B;QACC,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ;QACR,OAAO;IACR;IACA;QACC,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ;QACR,OAAO;IACR;CACD;AAGO,SAAS,oBAAoB,QAAA,EAAkB;IACrD,MAAM,aAAa,qBAAqB,GAAA,CAAI,CAAC,WAAW;QACvD,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,IAAA,EAAM,MAAA,EAAQ,KAAA,CAAM,CAAA,GAAI;QAClD,MAAM,MAAM,IAAI,0OAAA,CAAI,SAAS,OAAO;QACpC,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,IAAI,GAAA,CAAI,CAAC,QAAQ;QAClC,OAAO,GAAG,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA,GAAA,EAAM,IAAI,CAAA,GAAA,EAAM,MAAM,CAAA,GAAA,EAAM,KAAK,EAAA;IACpD,CAAC;IACD,OAAO,WAAW,IAAA,CAAK,IAAI;AAC5B"}},
    {"offset": {"line": 2963, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/svg.ts"],"sourcesContent":["import { average, precise } from '@tldraw/editor'\nimport { StrokePoint } from './types'\n\n/**\n * Turn an array of stroke points into a path of quadradic curves.\n *\n * @param points - The stroke points returned from perfect-freehand\n * @param closed - Whether the shape is closed\n *\n * @public\n */\nexport function getSvgPathFromStrokePoints(points: StrokePoint[], closed = false): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0].point\n\tlet b = points[1].point\n\n\tif (len === 2) {\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i].point\n\t\tb = points[i + 1].point\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}T${result}${average(points[len - 1].point, points[0].point)}${average(\n\t\t\tpoints[0].point,\n\t\t\tpoints[1].point\n\t\t)}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}${points.length > 3 ? 'T' : ''}${result}L${precise(points[len - 1].point)}`\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,SAAS,eAAe;;AAW1B,SAAS,2BAA2B,MAAA,EAAuB,SAAS,KAAA,EAAe;IACzF,MAAM,MAAM,OAAO,MAAA;IAEnB,IAAI,MAAM,GAAG;QACZ,OAAO;IACR;IAEA,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;IAClB,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;IAElB,IAAI,QAAQ,GAAG;QACd,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,CAAC,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,CAAC,CAAC,EAAA;IACpC;IAEA,IAAI,SAAS;IAEb,IAAA,IAAS,IAAI,GAAG,MAAM,MAAM,GAAG,IAAI,KAAK,IAAK;QAC5C,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;QACd,IAAI,MAAA,CAAO,IAAI,CAAC,CAAA,CAAE,KAAA;QAClB,cAAU,gPAAA,EAAQ,GAAG,CAAC;IACvB;IAEA,IAAI,QAAQ;QAEX,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EAAO,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,OAAG,gPAAA,EAClF,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,CAAA,EAAI,MAAM,OAAG,gPAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAA,CAAE,KAAA,EAAO,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,OAAG,gPAAA,EAC/D,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,CAAA,CAAA;IACF,OAAO;QAIN,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,OAAG,gPAAA,EACjE,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,IACP,OAAO,MAAA,GAAS,IAAI,MAAM,EAAE,GAAG,MAAM,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAA,CAAE,KAAK,CAAC,EAAA;IAC5E;AACD"}},
    {"offset": {"line": 2998, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/freehand/svgInk.ts"],"sourcesContent":["import { Vec, VecLike, assert, average, precise, toDomPrecision } from '@tldraw/editor'\nimport { getStrokeOutlineTracks } from './getStrokeOutlinePoints'\nimport { getStrokePoints } from './getStrokePoints'\nimport { setStrokePointRadii } from './setStrokePointRadii'\nimport { StrokeOptions, StrokePoint } from './types'\n\nexport function svgInk(rawInputPoints: VecLike[], options: StrokeOptions = {}) {\n\tconst { start = {}, end = {} } = options\n\tconst { cap: capStart = true } = start\n\tconst { cap: capEnd = true } = end\n\tassert(!start.taper && !end.taper, 'cap taper not supported here')\n\tassert(!start.easing && !end.easing, 'cap easing not supported here')\n\tassert(capStart && capEnd, 'cap must be true')\n\n\tconst points = getStrokePoints(rawInputPoints, options)\n\tsetStrokePointRadii(points, options)\n\tconst partitions = partitionAtElbows(points)\n\tlet svg = ''\n\tfor (const partition of partitions) {\n\t\tsvg += renderPartition(partition, options)\n\t}\n\n\treturn svg\n}\n\nfunction partitionAtElbows(points: StrokePoint[]): StrokePoint[][] {\n\tif (points.length <= 2) return [points]\n\n\tconst result: StrokePoint[][] = []\n\tlet currentPartition: StrokePoint[] = [points[0]]\n\tlet prevV = Vec.Sub(points[1].point, points[0].point).uni()\n\tlet nextV: Vec\n\tlet dpr: number\n\tlet prevPoint: StrokePoint, thisPoint: StrokePoint, nextPoint: StrokePoint\n\tfor (let i = 1, n = points.length; i < n - 1; i++) {\n\t\tprevPoint = points[i - 1]\n\t\tthisPoint = points[i]\n\t\tnextPoint = points[i + 1]\n\n\t\tnextV = Vec.Sub(nextPoint.point, thisPoint.point).uni()\n\t\tdpr = Vec.Dpr(prevV, nextV)\n\t\tprevV = nextV\n\n\t\tif (dpr < -0.8) {\n\t\t\t// always treat such acute angles as elbows\n\t\t\t// and use the extended .input point as the elbow point for swooshiness in fast zaggy lines\n\t\t\tconst elbowPoint = {\n\t\t\t\t...thisPoint,\n\t\t\t\tpoint: thisPoint.input,\n\t\t\t}\n\t\t\tcurrentPartition.push(elbowPoint)\n\t\t\tresult.push(cleanUpPartition(currentPartition))\n\t\t\tcurrentPartition = [elbowPoint]\n\t\t\tcontinue\n\t\t}\n\t\tcurrentPartition.push(thisPoint)\n\n\t\tif (dpr > 0.7) {\n\t\t\t// Not an elbow\n\t\t\tcontinue\n\t\t}\n\n\t\t// so now we have a reasonably acute angle but it might not be an elbow if it's far\n\t\t// away from it's neighbors, angular dist is a normalized representation of how far away the point is from it's neighbors\n\t\t// (normalized by the radius)\n\t\tif (\n\t\t\t(Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) /\n\t\t\t\t((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 <\n\t\t\t1.5\n\t\t) {\n\t\t\t// if this point is kinda close to its neighbors and it has a reasonably\n\t\t\t// acute angle, it's probably a hard elbow\n\t\t\tcurrentPartition.push(thisPoint)\n\t\t\tresult.push(cleanUpPartition(currentPartition))\n\t\t\tcurrentPartition = [thisPoint]\n\t\t\tcontinue\n\t\t}\n\t}\n\tcurrentPartition.push(points[points.length - 1])\n\tresult.push(cleanUpPartition(currentPartition))\n\n\treturn result\n}\n\nfunction cleanUpPartition(partition: StrokePoint[]) {\n\t// clean up start of partition (remove points that are too close to the start)\n\tconst startPoint = partition[0]\n\tlet nextPoint: StrokePoint\n\twhile (partition.length > 2) {\n\t\tnextPoint = partition[1]\n\t\tif (\n\t\t\tVec.Dist2(startPoint.point, nextPoint.point) <\n\t\t\t(((startPoint.radius + nextPoint.radius) / 2) * 0.5) ** 2\n\t\t) {\n\t\t\tpartition.splice(1, 1)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// clean up end of partition in the same fashion\n\tconst endPoint = partition[partition.length - 1]\n\tlet prevPoint: StrokePoint\n\twhile (partition.length > 2) {\n\t\tprevPoint = partition[partition.length - 2]\n\t\tif (\n\t\t\tVec.Dist2(endPoint.point, prevPoint.point) <\n\t\t\t(((endPoint.radius + prevPoint.radius) / 2) * 0.5) ** 2\n\t\t) {\n\t\t\tpartition.splice(partition.length - 2, 1)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// now readjust the cap point vectors to point to their nearest neighbors\n\tif (partition.length > 1) {\n\t\tpartition[0] = {\n\t\t\t...partition[0],\n\t\t\tvector: Vec.Sub(partition[0].point, partition[1].point).uni(),\n\t\t}\n\t\tpartition[partition.length - 1] = {\n\t\t\t...partition[partition.length - 1],\n\t\t\tvector: Vec.Sub(\n\t\t\t\tpartition[partition.length - 2].point,\n\t\t\t\tpartition[partition.length - 1].point\n\t\t\t).uni(),\n\t\t}\n\t}\n\treturn partition\n}\n\nfunction circlePath(cx: number, cy: number, r: number) {\n\treturn (\n\t\t'M ' +\n\t\tcx +\n\t\t' ' +\n\t\tcy +\n\t\t' m -' +\n\t\tr +\n\t\t', 0 a ' +\n\t\tr +\n\t\t',' +\n\t\tr +\n\t\t' 0 1,1 ' +\n\t\tr * 2 +\n\t\t',0 a ' +\n\t\tr +\n\t\t',' +\n\t\tr +\n\t\t' 0 1,1 -' +\n\t\tr * 2 +\n\t\t',0'\n\t)\n}\n\nfunction renderPartition(strokePoints: StrokePoint[], options: StrokeOptions = {}): string {\n\tif (strokePoints.length === 0) return ''\n\tif (strokePoints.length === 1) {\n\t\treturn circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius)\n\t}\n\n\tconst { left, right } = getStrokeOutlineTracks(strokePoints, options)\n\tright.reverse()\n\tlet svg = `M${precise(left[0])}T`\n\n\t// draw left track\n\tfor (let i = 1; i < left.length; i++) {\n\t\tsvg += average(left[i - 1], left[i])\n\t}\n\t// draw end cap arc\n\t{\n\t\tconst point = strokePoints[strokePoints.length - 1]\n\t\tconst radius = point.radius\n\t\tconst direction = point.vector.clone().per().neg()\n\t\tconst arcStart = Vec.Add(point.point, Vec.Mul(direction, radius))\n\t\tconst arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius))\n\t\tsvg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(\n\t\t\tradius\n\t\t)} 0 0 1 ${precise(arcEnd)}T`\n\t}\n\t// draw right track\n\tfor (let i = 1; i < right.length; i++) {\n\t\tsvg += average(right[i - 1], right[i])\n\t}\n\t// draw start cap arc\n\t{\n\t\tconst point = strokePoints[0]\n\t\tconst radius = point.radius\n\t\tconst direction = point.vector.clone().per()\n\t\tconst arcStart = Vec.Add(point.point, Vec.Mul(direction, radius))\n\t\tconst arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius))\n\t\tsvg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(\n\t\t\tradius\n\t\t)} 0 0 1 ${precise(arcEnd)}Z`\n\t}\n\treturn svg\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3151, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/interpolate-props.ts"],"sourcesContent":["import { TLDrawShapeSegment, VecModel, b64Vecs, lerp } from '@tldraw/editor'\n\n/** @public */\nexport const interpolateSegments = (\n\tstartSegments: TLDrawShapeSegment[],\n\tendSegments: TLDrawShapeSegment[],\n\tprogress: number\n): TLDrawShapeSegment[] => {\n\tconst startPoints: VecModel[] = []\n\tconst endPoints: VecModel[] = []\n\n\t// Extract all points from startSegments and endSegments\n\tstartSegments.forEach((segment) => startPoints.push(...b64Vecs.decodePoints(segment.path)))\n\tendSegments.forEach((segment) => endPoints.push(...b64Vecs.decodePoints(segment.path)))\n\n\tconst maxLength = Math.max(startPoints.length, endPoints.length)\n\tconst pointsToUseStart: VecModel[] = []\n\tconst pointsToUseEnd: VecModel[] = []\n\n\t// Ensure both arrays have the same length\n\tfor (let i = 0; i < maxLength; i++) {\n\t\tpointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1])\n\t\tpointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1])\n\t}\n\n\t// Interpolate points\n\tconst interpolatedPoints = pointsToUseStart.map((point, k) => {\n\t\tlet z = 0.5\n\t\tif (pointsToUseEnd[k].z !== undefined && point.z !== undefined) {\n\t\t\tz = lerp(point.z, pointsToUseEnd[k].z as number, progress)\n\t\t}\n\t\treturn {\n\t\t\tx: lerp(point.x, pointsToUseEnd[k].x, progress),\n\t\t\ty: lerp(point.y, pointsToUseEnd[k].y, progress),\n\t\t\tz,\n\t\t}\n\t})\n\t// Return all interpolated points in a single segment\n\treturn [\n\t\t{\n\t\t\ttype: 'free',\n\t\t\tpath: b64Vecs.encodePoints(interpolatedPoints),\n\t\t},\n\t]\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAuC,SAAS,YAAY;;AAGrD,MAAM,sBAAsB,CAClC,eACA,aACA,aAC0B;IAC1B,MAAM,cAA0B,CAAC,CAAA;IACjC,MAAM,YAAwB,CAAC,CAAA;IAG/B,cAAc,OAAA,CAAQ,CAAC,UAAY,YAAY,IAAA,CAAK,GAAG,6NAAA,CAAQ,YAAA,CAAa,QAAQ,IAAI,CAAC,CAAC;IAC1F,YAAY,OAAA,CAAQ,CAAC,UAAY,UAAU,IAAA,CAAK,GAAG,6NAAA,CAAQ,YAAA,CAAa,QAAQ,IAAI,CAAC,CAAC;IAEtF,MAAM,YAAY,KAAK,GAAA,CAAI,YAAY,MAAA,EAAQ,UAAU,MAAM;IAC/D,MAAM,mBAA+B,CAAC,CAAA;IACtC,MAAM,iBAA6B,CAAC,CAAA;IAGpC,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,IAAK;QACnC,iBAAiB,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA,IAAK,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAC;QAC3E,eAAe,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA,IAAK,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAC;IACpE;IAGA,MAAM,qBAAqB,iBAAiB,GAAA,CAAI,CAAC,OAAO,MAAM;QAC7D,IAAI,IAAI;QACR,IAAI,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,KAAM,KAAA,KAAa,MAAM,CAAA,KAAM,KAAA,GAAW;YAC/D,QAAI,uNAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAa,QAAQ;QAC1D;QACA,OAAO;YACN,OAAG,uNAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAG,QAAQ;YAC9C,OAAG,uNAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAG,QAAQ;YAC9C;QACD;IACD,CAAC;IAED,OAAO;QACN;YACC,MAAM;YACN,MAAM,6NAAA,CAAQ,YAAA,CAAa,kBAAkB;QAC9C;KACD;AACD"}},
    {"offset": {"line": 3195, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/createTextJsxFromSpans.tsx"],"sourcesContent":["import {\n\tBox,\n\tBoxModel,\n\tEditor,\n\tTLDefaultVerticalAlignStyle,\n\tTLMeasureTextSpanOpts,\n} from '@tldraw/editor'\n\nfunction correctSpacesToNbsp(input: string) {\n\treturn input.replace(/\\s/g, '\\xa0')\n}\n\nexport interface TLCreateTextJsxFromSpansOpts extends TLMeasureTextSpanOpts {\n\tverticalTextAlign: TLDefaultVerticalAlignStyle\n\toffsetX: number\n\toffsetY: number\n\tstroke?: string\n\tstrokeWidth?: number\n\tfill?: string\n}\n\n/** Get an SVG element for a text shape. */\nexport function createTextJsxFromSpans(\n\teditor: Editor,\n\tspans: { text: string; box: BoxModel }[],\n\topts: TLCreateTextJsxFromSpansOpts\n) {\n\tconst { padding = 0 } = opts\n\tif (spans.length === 0) return null\n\n\tconst bounds = Box.From(spans[0].box)\n\tfor (const { box } of spans) {\n\t\tbounds.union(box)\n\t}\n\n\tconst offsetX = padding + (opts.offsetX ?? 0)\n\tconst offsetY =\n\t\t(opts.offsetY ?? 0) +\n\t\topts.fontSize / 2 +\n\t\t(opts.verticalTextAlign === 'start'\n\t\t\t? padding\n\t\t\t: opts.verticalTextAlign === 'end'\n\t\t\t\t? opts.height - padding - bounds.height\n\t\t\t\t: (Math.ceil(opts.height) - bounds.height) / 2)\n\n\t// Create text span elements for each word\n\tlet currentLineTop = null\n\tconst children = []\n\tfor (const { text, box } of spans) {\n\t\t// if we broke a line, add a line break span. This helps tools like\n\t\t// figma import our exported svg correctly\n\t\tconst didBreakLine = currentLineTop !== null && box.y > currentLineTop\n\t\tif (didBreakLine) {\n\t\t\tchildren.push(\n\t\t\t\t<tspan\n\t\t\t\t\tkey={children.length}\n\t\t\t\t\talignmentBaseline=\"mathematical\"\n\t\t\t\t\tx={offsetX}\n\t\t\t\t\ty={box.y + offsetY}\n\t\t\t\t>\n\t\t\t\t\t{'\\n'}\n\t\t\t\t</tspan>\n\t\t\t)\n\t\t}\n\n\t\tchildren.push(\n\t\t\t<tspan\n\t\t\t\tkey={children.length}\n\t\t\t\talignmentBaseline=\"mathematical\"\n\t\t\t\tx={box.x + offsetX}\n\t\t\t\ty={box.y + offsetY}\n\t\t\t\t// N.B. This property, while discouraged (\"intended for Document Type Definition (DTD) designers\")\n\t\t\t\t// is necessary for ensuring correct mixed RTL/LTR behavior when exporting SVGs.\n\t\t\t\tunicodeBidi=\"plaintext\"\n\t\t\t>\n\t\t\t\t{correctSpacesToNbsp(text)}\n\t\t\t</tspan>\n\t\t)\n\n\t\tcurrentLineTop = box.y\n\t}\n\n\treturn (\n\t\t<text\n\t\t\tfontSize={opts.fontSize}\n\t\t\tfontFamily={opts.fontFamily}\n\t\t\tfontStyle={opts.fontStyle}\n\t\t\tfontWeight={opts.fontWeight}\n\t\t\tdominantBaseline=\"mathematical\"\n\t\t\talignmentBaseline=\"mathematical\"\n\t\t\tstroke={opts.stroke}\n\t\t\tstrokeWidth={opts.strokeWidth}\n\t\t\tfill={opts.fill}\n\t\t>\n\t\t\t{children}\n\t\t</text>\n\t)\n}\n"],"names":[],"mappings":";;;;AAsDI;;AAtDJ;;;AAQA,SAAS,oBAAoB,KAAA,EAAe;IAC3C,OAAO,MAAM,OAAA,CAAQ,OAAO,MAAM;AACnC;AAYO,SAAS,uBACf,MAAA,EACA,KAAA,EACA,IAAA,EACC;IACD,MAAM,EAAE,UAAU,CAAA,CAAE,CAAA,GAAI;IACxB,IAAI,MAAM,MAAA,KAAW,EAAG,CAAA,OAAO;IAE/B,MAAM,SAAS,0OAAA,CAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,GAAG;IACpC,KAAA,MAAW,EAAE,GAAA,CAAI,CAAA,IAAK,MAAO;QAC5B,OAAO,KAAA,CAAM,GAAG;IACjB;IAEA,MAAM,UAAU,UAAA,CAAW,KAAK,OAAA,IAAW,CAAA;IAC3C,MAAM,UAAA,CACJ,KAAK,OAAA,IAAW,CAAA,IACjB,KAAK,QAAA,GAAW,IAAA,CACf,KAAK,iBAAA,KAAsB,UACzB,UACA,KAAK,iBAAA,KAAsB,QAC1B,KAAK,MAAA,GAAS,UAAU,OAAO,MAAA,GAAA,CAC9B,KAAK,IAAA,CAAK,KAAK,MAAM,IAAI,OAAO,MAAA,IAAU,CAAA;IAGhD,IAAI,iBAAiB;IACrB,MAAM,WAAW,CAAC,CAAA;IAClB,KAAA,MAAW,EAAE,IAAA,EAAM,GAAA,CAAI,CAAA,IAAK,MAAO;QAGlC,MAAM,eAAe,mBAAmB,QAAQ,IAAI,CAAA,GAAI;QACxD,IAAI,cAAc;YACjB,SAAS,IAAA,CACR,aAAA,GAAA,IAAA,+NAAA,EAAC,SAAA;gBAEA,mBAAkB;gBAClB,GAAG;gBACH,GAAG,IAAI,CAAA,GAAI;gBAEV,UAAA;YAAA,GALI,SAAS,MAAA;QAQjB;QAEA,SAAS,IAAA,CACR,aAAA,GAAA,IAAA,+NAAA,EAAC,SAAA;YAEA,mBAAkB;YAClB,GAAG,IAAI,CAAA,GAAI;YACX,GAAG,IAAI,CAAA,GAAI;YAGX,aAAY;YAEX,UAAA,oBAAoB,IAAI;QAAA,GARpB,SAAS,MAAA;QAYhB,iBAAiB,IAAI,CAAA;IACtB;IAEA,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;QACA,UAAU,KAAK,QAAA;QACf,YAAY,KAAK,UAAA;QACjB,WAAW,KAAK,SAAA;QAChB,YAAY,KAAK,UAAA;QACjB,kBAAiB;QACjB,mBAAkB;QAClB,QAAQ,KAAK,MAAA;QACb,aAAa,KAAK,WAAA;QAClB,MAAM,KAAK,IAAA;QAEV;IAAA;AAGJ"}},
    {"offset": {"line": 3256, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useColorSpace.tsx"],"sourcesContent":["import { debugFlags, useValue } from '@tldraw/editor'\nimport { useEffect, useState } from 'react'\n\nexport function useColorSpace(): 'srgb' | 'p3' {\n\tconst [supportsP3, setSupportsP3] = useState(false)\n\n\tuseEffect(() => {\n\t\tconst supportsSyntax = CSS.supports('color', 'color(display-p3 1 1 1)')\n\t\tconst query = matchMedia('(color-gamut: p3)')\n\t\tsetSupportsP3(supportsSyntax && query.matches)\n\n\t\tconst onChange = () => setSupportsP3(supportsSyntax && query.matches)\n\n\t\tquery.addEventListener('change', onChange)\n\t\treturn () => query.removeEventListener('change', onChange)\n\t}, [])\n\n\tconst forceSrgb = useValue(debugFlags.forceSrgb)\n\n\treturn forceSrgb || !supportsP3 ? 'srgb' : 'p3'\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,YAAY,gBAAgB;AACrC,SAAS,WAAW,gBAAgB;;;AAE7B,SAAS,gBAA+B;IAC9C,MAAM,CAAC,YAAY,aAAa,CAAA,OAAI,2NAAA,EAAS,KAAK;IAElD,IAAA,4NAAA;mCAAU,MAAM;YACf,MAAM,iBAAiB,IAAI,QAAA,CAAS,SAAS,yBAAyB;YACtE,MAAM,QAAQ,WAAW,mBAAmB;YAC5C,cAAc,kBAAkB,MAAM,OAAO;YAE7C,MAAM;oDAAW,IAAM,cAAc,kBAAkB,MAAM,OAAO;;YAEpE,MAAM,gBAAA,CAAiB,UAAU,QAAQ;YACzC;2CAAO,IAAM,MAAM,mBAAA,CAAoB,UAAU,QAAQ;;QAC1D;kCAAG,CAAC,CAAC;IAEL,MAAM,gBAAY,oOAAA,EAAS,uPAAA,CAAW,SAAS;IAE/C,OAAO,aAAa,CAAC,aAAa,SAAS;AAC5C"}},
    {"offset": {"line": 3291, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/BrokenAssetIcon.tsx"],"sourcesContent":["export function BrokenAssetIcon() {\n\treturn (\n\t\t<svg\n\t\t\twidth=\"15\"\n\t\t\theight=\"15\"\n\t\t\tviewBox=\"0 0 30 30\"\n\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\tfill=\"none\"\n\t\t\tstroke=\"currentColor\"\n\t\t\tstrokeLinecap=\"round\"\n\t\t\tstrokeLinejoin=\"round\"\n\t\t>\n\t\t\t<path d=\"M3,11 L3,3 11,3\" strokeWidth=\"2\" />\n\t\t\t<path d=\"M19,27 L27,27 L27,19\" strokeWidth=\"2\" />\n\t\t\t<path d=\"M27,3 L3,27\" strokeWidth=\"2\" />\n\t\t</svg>\n\t)\n}\n"],"names":[],"mappings":";;;;AAEE,SAUC,KAVD;;AAFK,SAAS,kBAAkB;IACjC,OACC,aAAA,GAAA,IAAA,gOAAA,EAAC,OAAA;QACA,OAAM;QACN,QAAO;QACP,SAAQ;QACR,OAAM;QACN,MAAK;QACL,QAAO;QACP,eAAc;QACd,gBAAe;QAEf,UAAA;YAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gBAAK,GAAE;gBAAkB,aAAY;YAAA,CAAI;YAC1C,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gBAAK,GAAE;gBAAuB,aAAY;YAAA,CAAI;YAC/C,aAAA,GAAA,IAAA,+NAAA,EAAC,QAAA;gBAAK,GAAE;gBAAc,aAAY;YAAA,CAAI;SAAA;IAAA;AAGzC"}},
    {"offset": {"line": 3329, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/useImageOrVideoAsset.ts"],"sourcesContent":["import {\n\tEditor,\n\tSvgExportContext,\n\tTLAssetId,\n\tTLImageAsset,\n\tTLShapeId,\n\tTLVideoAsset,\n\treact,\n\tuseDelaySvgExport,\n\tuseEditor,\n\tuseSvgExportContext,\n} from '@tldraw/editor'\nimport { useEffect, useRef, useState } from 'react'\n\n/**\n * Options for {@link useImageOrVideoAsset}.\n *\n * @public\n */\nexport interface UseImageOrVideoAssetOptions {\n\t/** The asset ID you want a URL for. */\n\tassetId: TLAssetId | null\n\t/**\n\t * The shape the asset is being used for. We won't update the resolved URL while the shape is\n\t * off-screen.\n\t */\n\tshapeId?: TLShapeId\n\t/**\n\t * The width at which the asset will be displayed, in shape-space pixels.\n\t */\n\twidth: number\n}\n\n/**\n * This is a handy helper hook that resolves an asset to an optimized URL for a given shape, or its\n * {@link @tldraw/editor#Editor.createTemporaryAssetPreview | placeholder} if the asset is still\n * uploading. This is used in particular for high-resolution images when you want lower and higher\n * resolution depending on the size of the image on the canvas and the zoom level.\n *\n * For image scaling to work, you need to implement scaled URLs in\n * {@link @tldraw/tlschema#TLAssetStore.resolve}.\n *\n * @public\n */\nexport function useImageOrVideoAsset({ shapeId, assetId, width }: UseImageOrVideoAssetOptions) {\n\tconst editor = useEditor()\n\tconst exportInfo = useSvgExportContext()\n\tconst exportIsReady = useDelaySvgExport()\n\n\t// We use a state to store the result of the asset resolution, and we're going to avoid updating this whenever we can\n\tconst [result, setResult] = useState<{\n\t\tasset: (TLImageAsset | TLVideoAsset) | null\n\t\turl: string | null\n\t}>(() => ({\n\t\tasset: assetId ? (editor.getAsset<TLImageAsset | TLVideoAsset>(assetId) ?? null) : null,\n\t\turl: null as string | null,\n\t}))\n\n\t// A flag for whether we've resolved the asset URL at least once, after which we can debounce\n\tconst didAlreadyResolve = useRef(false)\n\n\t// Track the previous assetId to detect when the asset itself changes\n\tconst previousAssetId = useRef<TLAssetId | null>(null)\n\n\t// Track whether we should run immediately (skip debouncing) for the next resolution\n\tconst shouldRunImmediately = useRef(false)\n\n\t// The last URL that we've seen for the shape\n\tconst previousUrl = useRef<string | null>(null)\n\n\tuseEffect(() => {\n\t\t// Check if the assetId changed (not just resolution/scale updates)\n\t\tconst assetIdChanged = previousAssetId.current !== assetId\n\t\tpreviousAssetId.current = assetId\n\n\t\t// Set flag to run immediately (skip debouncing) for the next resolution\n\t\tif (assetIdChanged) {\n\t\t\tshouldRunImmediately.current = true\n\t\t}\n\n\t\tif (!assetId) return\n\n\t\tlet isCancelled = false\n\t\tlet cancelDebounceFn: (() => void) | undefined\n\n\t\tconst cleanupEffectScheduler = react('update state', () => {\n\t\t\tif (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId)) return\n\n\t\t\t// Get the fresh asset\n\t\t\tconst asset = editor.getAsset<TLImageAsset | TLVideoAsset>(assetId)\n\t\t\tif (!asset) {\n\t\t\t\t// If the asset is deleted, such as when an upload fails, set the URL to null\n\t\t\t\tsetResult((prev) => ({ ...prev, asset: null, url: null }))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Set initial preview for the shape if it has no source (if it was pasted into a local project as base64)\n\t\t\tif (!asset.props.src) {\n\t\t\t\tconst preview = editor.getTemporaryAssetPreview(asset.id)\n\t\t\t\tif (preview) {\n\t\t\t\t\tif (previousUrl.current !== preview) {\n\t\t\t\t\t\tpreviousUrl.current = preview // just for kicks, let's save the url as the previous URL\n\t\t\t\t\t\tsetResult((prev) => ({ ...prev, isPlaceholder: true, url: preview })) // set the preview as the URL\n\t\t\t\t\t\texportIsReady() // let the SVG export know we're ready for export\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// aside ...we could bail here if the only thing that has changed is the shape has changed from culled to not culled\n\n\t\t\tconst screenScale = exportInfo\n\t\t\t\t? exportInfo.scale * (width / asset.props.w)\n\t\t\t\t: editor.getEfficientZoomLevel() * (width / asset.props.w)\n\n\t\t\tfunction resolve(asset: TLImageAsset | TLVideoAsset, url: string | null) {\n\t\t\t\tif (isCancelled) return // don't update if the hook has remounted\n\t\t\t\tif (previousUrl.current === url) return // don't update the state if the url is the same\n\t\t\t\tdidAlreadyResolve.current = true // mark that we've resolved our first image\n\t\t\t\tpreviousUrl.current = url // keep the url around to compare with the next one\n\t\t\t\tsetResult({ asset, url })\n\t\t\t\texportIsReady() // let the SVG export know we're ready for export\n\t\t\t}\n\n\t\t\t// Debounce fetching potentially multiple image variations (e.g. during zoom or resize).\n\t\t\t// Don't debounce when the asset itself changes - resolve immediately.\n\t\t\tif (didAlreadyResolve.current && !shouldRunImmediately.current) {\n\t\t\t\tlet tick = 0\n\n\t\t\t\tconst resolveAssetAfterAWhile = () => {\n\t\t\t\t\ttick++\n\t\t\t\t\tif (tick > 500 / 16) {\n\t\t\t\t\t\t// debounce for 500ms\n\t\t\t\t\t\tresolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url))\n\t\t\t\t\t\tcancelDebounceFn?.()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcancelDebounceFn?.()\n\t\t\t\teditor.on('tick', resolveAssetAfterAWhile)\n\t\t\t\tcancelDebounceFn = () => editor.off('tick', resolveAssetAfterAWhile)\n\t\t\t} else {\n\t\t\t\t// Resolve immediately when: first resolution, or the asset itself changed.\n\t\t\t\t// Cancel any pending debounce to prevent stale updates.\n\t\t\t\tcancelDebounceFn?.()\n\t\t\t\tresolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url))\n\t\t\t\t// Reset the flag after immediate resolution so subsequent updates are debounced\n\t\t\t\tshouldRunImmediately.current = false\n\t\t\t}\n\t\t})\n\n\t\treturn () => {\n\t\t\tcleanupEffectScheduler()\n\t\t\tcancelDebounceFn?.()\n\t\t\tisCancelled = true\n\t\t}\n\t}, [editor, assetId, exportInfo, exportIsReady, shapeId, width])\n\n\treturn result\n}\n\nfunction resolveAssetUrl(\n\teditor: Editor,\n\tassetId: TLAssetId,\n\tscreenScale: number,\n\texportInfo: SvgExportContext | null,\n\tcallback: (url: string | null) => void\n) {\n\teditor\n\t\t.resolveAssetUrl(assetId, {\n\t\t\tscreenScale,\n\t\t\tshouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,\n\t\t\tdpr: exportInfo?.pixelRatio ?? undefined,\n\t\t})\n\t\t// There's a weird bug with out debounce function that doesn't\n\t\t// make it work right with async functions, so we use a callback\n\t\t// here instead of returning a promise.\n\t\t.then((url) => {\n\t\t\tcallback(url)\n\t\t})\n}\n"],"names":["asset"],"mappings":"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"}},
    {"offset": {"line": 3467, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/shared/PlainTextLabel.tsx"],"sourcesContent":["import {\n\tBox,\n\tExtractShapeByProps,\n\tTLDefaultFillStyle,\n\tTLDefaultFontStyle,\n\tTLDefaultHorizontalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n\tTLShapeId,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport React from 'react'\nimport { PlainTextArea } from '../text/PlainTextArea'\nimport { TextHelpers } from './TextHelpers'\nimport { isLegacyAlign } from './legacyProps'\nimport { useEditablePlainText } from './useEditablePlainText'\n\n/** @public */\nexport interface PlainTextLabelProps {\n\tshapeId: TLShapeId\n\ttype: ExtractShapeByProps<{ text: string }>['type']\n\tfont: TLDefaultFontStyle\n\tfontSize: number\n\tlineHeight: number\n\tfill?: TLDefaultFillStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\ttext?: string\n\tlabelColor: string\n\tbounds?: Box\n\tisSelected: boolean\n\tonKeyDown?(e: KeyboardEvent): void\n\tclassNamePrefix?: string\n\tstyle?: React.CSSProperties\n\ttextWidth?: number\n\ttextHeight?: number\n\tpadding?: number\n\tshowTextOutline?: boolean\n}\n\n/**\n * Renders a text label that can be used inside of shapes.\n * The component has the ability to be edited in place and furthermore\n * supports rich text editing.\n *\n * @public @react\n */\nexport const PlainTextLabel = React.memo(function PlainTextLabel({\n\tshapeId,\n\ttype,\n\ttext: plaintext,\n\tlabelColor,\n\tfont,\n\tfontSize,\n\tlineHeight,\n\talign,\n\tverticalAlign,\n\twrap,\n\tisSelected,\n\tpadding = 0,\n\tonKeyDown: handleKeyDownCustom,\n\tclassNamePrefix,\n\tstyle,\n\ttextWidth,\n\ttextHeight,\n\tshowTextOutline = true,\n}: PlainTextLabelProps) {\n\tconst { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } =\n\t\tuseEditablePlainText(shapeId, type, plaintext)\n\n\tconst finalPlainText = TextHelpers.normalizeTextForDom(plaintext || '')\n\tconst hasText = finalPlainText.length > 0\n\n\tconst legacyAlign = isLegacyAlign(align)\n\n\tif (!isEditing && !hasText) {\n\t\treturn null\n\t}\n\n\t// TODO: probably combine tl-text and tl-arrow eventually\n\t// In case you're grepping for this, it breaks down as follows:\n\t// tl-text-label, tl-text-label__inner, tl-text-shape-label, tl-text\n\t// tl-arrow-label, tl-arrow-label__inner, tl-arrow\n\tconst cssPrefix = classNamePrefix || 'tl-text'\n\treturn (\n\t\t<div\n\t\t\tclassName={`${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`}\n\t\t\taria-hidden={!isEditing}\n\t\t\tdata-font={font}\n\t\t\tdata-align={align}\n\t\t\tdata-hastext={!isEmpty}\n\t\t\tdata-isediting={isEditing}\n\t\t\tdata-is-ready-for-editing={isReadyForEditing}\n\t\t\tdata-textwrap={!!wrap}\n\t\t\tdata-isselected={isSelected}\n\t\t\tstyle={{\n\t\t\t\tjustifyContent: align === 'middle' || legacyAlign ? 'center' : align,\n\t\t\t\talignItems: verticalAlign === 'middle' ? 'center' : verticalAlign,\n\t\t\t\tpadding,\n\t\t\t\t...style,\n\t\t\t}}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName={`${cssPrefix}-label__inner tl-text-content__wrapper`}\n\t\t\t\tstyle={{\n\t\t\t\t\tfontSize,\n\t\t\t\t\tlineHeight: lineHeight.toString(),\n\t\t\t\t\tminHeight: Math.floor(fontSize * lineHeight) + 'px',\n\t\t\t\t\tminWidth: Math.ceil(textWidth || 0),\n\t\t\t\t\tcolor: labelColor,\n\t\t\t\t\twidth: textWidth ? Math.ceil(textWidth) : undefined,\n\t\t\t\t\theight: textHeight ? Math.ceil(textHeight) : undefined,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclassName={classNames(\n\t\t\t\t\t\t`${cssPrefix} tl-text tl-text-content`,\n\t\t\t\t\t\tshowTextOutline ? 'tl-text__outline' : 'tl-text__no-outline'\n\t\t\t\t\t)}\n\t\t\t\t\tdir=\"auto\"\n\t\t\t\t>\n\t\t\t\t\t{finalPlainText.split('\\n').map((lineOfText, index) => (\n\t\t\t\t\t\t<div key={index} dir=\"auto\">\n\t\t\t\t\t\t\t{lineOfText}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t\t{(isReadyForEditing || isSelected) && (\n\t\t\t\t\t<PlainTextArea\n\t\t\t\t\t\t// Fudge the ref type because we're using forwardRef and it's not typed correctly.\n\t\t\t\t\t\tref={rInput as any}\n\t\t\t\t\t\ttext={plaintext}\n\t\t\t\t\t\tisEditing={isEditing}\n\t\t\t\t\t\tshapeId={shapeId}\n\t\t\t\t\t\t{...editableTextRest}\n\t\t\t\t\t\thandleKeyDown={handleKeyDownCustom ?? editableTextRest.handleKeyDown}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n"],"names":["PlainTextLabel"],"mappings":";;;;AAsGG,SAoBG,KApBH;AA7FH,OAAO,gBAAgB;AACvB,OAAO,WAAW;AAClB,SAAS,qBAAqB;AAC9B,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;AAC9B,SAAS,4BAA4B;;;;;;;;AAiC9B,MAAM,iBAAiB,0NAAA,CAAM,IAAA,CAAK,SAASA,gBAAe,EAChE,OAAA,EACA,IAAA,EACA,MAAM,SAAA,EACN,UAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,UAAU,CAAA,EACV,WAAW,mBAAA,EACX,eAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACA,kBAAkB,IAAA,EACnB,EAAwB;IACvB,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,SAAA,EAAW,iBAAA,EAAmB,GAAG,iBAAiB,CAAA,OAC1E,sQAAA,EAAqB,SAAS,MAAM,SAAS;IAE9C,MAAM,iBAAiB,oPAAA,CAAY,mBAAA,CAAoB,aAAa,EAAE;IACtE,MAAM,UAAU,eAAe,MAAA,GAAS;IAExC,MAAM,kBAAc,sPAAA,EAAc,KAAK;IAEvC,IAAI,CAAC,aAAa,CAAC,SAAS;QAC3B,OAAO;IACR;IAMA,MAAM,YAAY,mBAAmB;IACrC,OACC,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;QACA,WAAW,GAAG,SAAS,CAAA,4CAAA,CAAA;QACvB,eAAa,CAAC;QACd,aAAW;QACX,cAAY;QACZ,gBAAc,CAAC;QACf,kBAAgB;QAChB,6BAA2B;QAC3B,iBAAe,CAAC,CAAC;QACjB,mBAAiB;QACjB,OAAO;YACN,gBAAgB,UAAU,YAAY,cAAc,WAAW;YAC/D,YAAY,kBAAkB,WAAW,WAAW;YACpD;YACA,GAAG,KAAA;QACJ;QAEA,UAAA,aAAA,GAAA,IAAA,gOAAA,EAAC,OAAA;YACA,WAAW,GAAG,SAAS,CAAA,sCAAA,CAAA;YACvB,OAAO;gBACN;gBACA,YAAY,WAAW,QAAA,CAAS;gBAChC,WAAW,KAAK,KAAA,CAAM,WAAW,UAAU,IAAI;gBAC/C,UAAU,KAAK,IAAA,CAAK,aAAa,CAAC;gBAClC,OAAO;gBACP,OAAO,YAAY,KAAK,IAAA,CAAK,SAAS,IAAI,KAAA;gBAC1C,QAAQ,aAAa,KAAK,IAAA,CAAK,UAAU,IAAI,KAAA;YAC9C;YAEA,UAAA;gBAAA,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;oBACA,eAAW,mMAAA,EACV,GAAG,SAAS,CAAA,wBAAA,CAAA,EACZ,kBAAkB,qBAAqB;oBAExC,KAAI;oBAEH,UAAA,eAAe,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAC,YAAY,QAC5C,aAAA,GAAA,IAAA,+NAAA,EAAC,OAAA;4BAAgB,KAAI;4BACnB,UAAA;wBAAA,GADQ,KAEV,CACA;gBAAA;gBACF,CACE,qBAAqB,UAAA,KACtB,aAAA,GAAA,IAAA,+NAAA,EAAC,sPAAA,EAAA;oBAEA,KAAK;oBACL,MAAM;oBACN;oBACA;oBACC,GAAG,gBAAA;oBACJ,eAAe,uBAAuB,iBAAiB,aAAA;gBAAA;aACxD;QAAA;IAEF;AAGH,CAAC"}}]
}