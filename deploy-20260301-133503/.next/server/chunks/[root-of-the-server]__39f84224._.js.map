{
  "version": 3,
  "sources": [],
  "debugId": "8f324052-395b-e5db-2d82-d3380e6927c3",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../../../ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/sanitize.ts","../../../../../../ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/src/sql/functions/aggregate.ts"],"sourcesContent":["/**\n * XSS prevention: sanitize user input before rendering or storing.\n * Use for display and for any user-generated content that may be shown as HTML.\n */\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi\nconst ON_EVENT_REGEX = /\\s*on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi\nconst JAVASCRIPT_URL_REGEX = /javascript\\s*:/gi\nconst DATA_URL_REGEX = /data\\s*:\\s*[^,]*\\s*,/gi\n// Strip dangerous tags (iframe, object, embed, form, meta with refresh, link with import)\nconst DANGEROUS_TAGS_REGEX = /<(?:iframe|object|embed|form|meta|link)\\b[^>]*>/gi\n\n/**\n * Strip script tags, event handlers, javascript: URLs, data: URLs, and dangerous tags.\n * Safe for inserting into text content or plain HTML contexts.\n */\nexport function sanitizeHtml(input: string): string {\n  if (typeof input !== 'string') return ''\n  return input\n    .replace(SCRIPT_REGEX, '')\n    .replace(DANGEROUS_TAGS_REGEX, '')\n    .replace(ON_EVENT_REGEX, '')\n    .replace(JAVASCRIPT_URL_REGEX, '')\n    .replace(DATA_URL_REGEX, '')\n}\n\n/**\n * Sanitize and optionally truncate to a max length (for DB/store).\n */\nexport function sanitizeHtmlWithMax(input: string, maxLength: number = 50_000): string {\n  const s = sanitizeHtml(input)\n  if (s.length <= maxLength) return s\n  return s.slice(0, maxLength)\n}\n\n/**\n * Escape HTML entities so the string is safe for use in text nodes or attributes.\n */\nexport function escapeHtml(input: string): string {\n  if (typeof input !== 'string') return ''\n  const map: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;'\n  }\n  return input.replace(/[&<>\"'/]/g, (c) => map[c] ?? c)\n}\n\n/**\n * Sanitize for display in a context where only safe text is allowed (e.g. profile name, bio).\n * Prefer escapeHtml when rendering in React (React escapes by default); use this for legacy or raw HTML.\n */\nexport function sanitizeForDisplay(input: string): string {\n  return escapeHtml(sanitizeHtml(input))\n}\n","import { type AnyColumn, Column } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { type SQL, sql, type SQLWrapper } from '../sql.ts';\n\n/**\n * Returns the number of values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Number employees with null values\n * db.select({ value: count() }).from(employees)\n * // Number of employees where `name` is not null\n * db.select({ value: count(employees.name) }).from(employees)\n * ```\n *\n * @see countDistinct to get the number of non-duplicate values in `expression`\n */\nexport function count(expression?: SQLWrapper): SQL<number> {\n\treturn sql`count(${expression || sql.raw('*')})`.mapWith(Number);\n}\n\n/**\n * Returns the number of non-duplicate values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Number of employees where `name` is distinct\n * db.select({ value: countDistinct(employees.name) }).from(employees)\n * ```\n *\n * @see count to get the number of values in `expression`, including duplicates\n */\nexport function countDistinct(expression: SQLWrapper): SQL<number> {\n\treturn sql`count(distinct ${expression})`.mapWith(Number);\n}\n\n/**\n * Returns the average (arithmetic mean) of all non-null values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Average salary of an employee\n * db.select({ value: avg(employees.salary) }).from(employees)\n * ```\n *\n * @see avgDistinct to get the average of all non-null and non-duplicate values in `expression`\n */\nexport function avg(expression: SQLWrapper): SQL<string | null> {\n\treturn sql`avg(${expression})`.mapWith(String);\n}\n\n/**\n * Returns the average (arithmetic mean) of all non-null and non-duplicate values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Average salary of an employee where `salary` is distinct\n * db.select({ value: avgDistinct(employees.salary) }).from(employees)\n * ```\n *\n * @see avg to get the average of all non-null values in `expression`, including duplicates\n */\nexport function avgDistinct(expression: SQLWrapper): SQL<string | null> {\n\treturn sql`avg(distinct ${expression})`.mapWith(String);\n}\n\n/**\n * Returns the sum of all non-null values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Sum of every employee's salary\n * db.select({ value: sum(employees.salary) }).from(employees)\n * ```\n *\n * @see sumDistinct to get the sum of all non-null and non-duplicate values in `expression`\n */\nexport function sum(expression: SQLWrapper): SQL<string | null> {\n\treturn sql`sum(${expression})`.mapWith(String);\n}\n\n/**\n * Returns the sum of all non-null and non-duplicate values in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // Sum of every employee's salary where `salary` is distinct (no duplicates)\n * db.select({ value: sumDistinct(employees.salary) }).from(employees)\n * ```\n *\n * @see sum to get the sum of all non-null values in `expression`, including duplicates\n */\nexport function sumDistinct(expression: SQLWrapper): SQL<string | null> {\n\treturn sql`sum(distinct ${expression})`.mapWith(String);\n}\n\n/**\n * Returns the maximum value in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // The employee with the highest salary\n * db.select({ value: max(employees.salary) }).from(employees)\n * ```\n */\nexport function max<T extends SQLWrapper>(expression: T): SQL<(T extends AnyColumn ? T['_']['data'] : string) | null> {\n\treturn sql`max(${expression})`.mapWith(is(expression, Column) ? expression : String) as any;\n}\n\n/**\n * Returns the minimum value in `expression`.\n *\n * ## Examples\n *\n * ```ts\n * // The employee with the lowest salary\n * db.select({ value: min(employees.salary) }).from(employees)\n * ```\n */\nexport function min<T extends SQLWrapper>(expression: T): SQL<(T extends AnyColumn ? T['_']['data'] : string) | null> {\n\treturn sql`min(${expression})`.mapWith(is(expression, Column) ? expression : String) as any;\n}\n"],"names":[],"mappings":"wCAKA,IAAM,EAAe,sDACf,EAAiB,kCACjB,EAAuB,mBACvB,EAAiB,yBAEjB,EAAuB,oDAMtB,SAAS,EAAa,CAAa,QACxC,AAAI,AAAiB,UAAU,OAApB,EAA2B,GAC/B,EACJ,OAAO,CAAC,EAAc,IACtB,OAAO,CAAC,EAAsB,IAC9B,OAAO,CAAC,EAAgB,IACxB,OAAO,CAAC,EAAsB,IAC9B,OAAO,CAAC,EAAgB,GAC7B,CAKO,SAAS,EAAoB,CAAa,CAAE,EAAoB,GAAM,EAC3E,IAAM,EAAI,EAAa,UACvB,AAAI,EAAE,MAAM,EAAI,EAAkB,EAC3B,EAAE,KADkB,AACb,CAAC,EAAG,EACpB,kFCjCA,IAAA,EAAuC,EAAA,CAAd,AAAc,CAAA,QACvC,EAAmB,EAAA,CAAV,AAAU,AADoB,CACpB,QACnB,CADmB,CAC4B,EAAA,CAA5B,AAA4B,CAAA,QAgBxC,EAhBwC,OAgB/B,EAAM,CAAA,EAAsC,AAC3D,OAAO,EAAA,GAAA,CAAA,MAAA,EAAY,GAAc,EAAA,GAAA,CAAI,GAAA,CAAI,GAAG,CAAC,CAAA,CAAA,CAAA,CAAI,OAAA,CAAQ,MAAM,CAChE,CAcO,SAAS,EAAc,CAAA,EAAqC,AAClE,OAAO,EAAA,GAAA,CAAA,eAAA,EAAqB,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAQ,MAAM,CACzD,CAcO,SAAS,EAAI,CAAA,EAA4C,AAC/D,OAAO,EAAA,GAAA,CAAA,IAAA,EAAU,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAQ,MAAM,CAC9C,CAcO,SAAS,EAAY,CAAA,EAC3B,AADuE,OAChE,EAAA,GAAA,CAAA,aAAA,EAAmB,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAQ,MAAM,CACvD,CAcO,SAAS,EAAI,CAAA,EAA4C,AAC/D,OAAO,EAAA,GAAA,CAAA,IAAA,EAAU,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAQ,MAAM,CAC9C,CAcO,SAAS,EAAY,CAAA,EAA4C,AACvE,OAAO,EAAA,GAAA,CAAA,aAAA,EAAmB,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAQ,MAAM,CACvD,CAYO,SAAS,EAA0B,CAAA,EACzC,AADqH,OAC9G,EAAA,GAAA,CAAA,IAAA,EAAU,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAA,CAAA,EAAQ,EAAA,EAAA,EAAG,EAAY,EAAA,MAAM,EAAI,EAAa,MAAM,CACpF,CAYO,SAAS,EAA0B,CAAA,EAA4E,AACrH,OAAO,EAAA,GAAA,CAAA,IAAA,EAAU,EAAU,CAAA,CAAA,CAAI,KAAJ,EAAI,CAAA,CAAA,EAAQ,EAAA,EAAA,EAAG,EAAY,EAAA,MAAM,EAAI,EAAa,MAAM,CACpF"}}]
}