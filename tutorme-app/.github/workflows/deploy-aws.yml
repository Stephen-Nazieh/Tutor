# Deploy TutorMe app to AWS EC2 via SSM
# Trigger: push to main, or manual dispatch.
# Requires: GitHub secrets AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY; optional AWS_REGION.

name: Deploy to AWS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  STACK_NAME: InfrastructureStack

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance ID
        id: instance
        run: |
          INSTANCE_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='TutormeAppInstanceId'].OutputValue" \
            --output text 2>/dev/null || true)
          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "::error::Stack ${{ env.STACK_NAME }} or output TutormeAppInstanceId not found. Deploy CDK first: cd infrastructure && npx cdk deploy"
            exit 1
          fi
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Using instance: $INSTANCE_ID"

      - name: Run deploy on EC2 (SSM)
        id: ssm
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["export REPO_ROOT=/opt/tutorme && bash /opt/tutorme/tutorme-app/scripts/aws-deploy.sh"]' \
            --timeout-seconds 600 \
            --query "Command.CommandId" \
            --output text)
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "SSM Command ID: $COMMAND_ID"

      - name: Wait for SSM command
        run: |
          for i in $(seq 1 60); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "${{ steps.ssm.outputs.command_id }}" \
              --instance-id "${{ steps.instance.outputs.instance_id }}" \
              --query "Status" --output text 2>/dev/null || echo "Pending")
            echo "Status: $STATUS"
            if [[ "$STATUS" == "Success" ]]; then exit 0; fi
            if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              aws ssm get-command-invocation \
                --command-id "${{ steps.ssm.outputs.command_id }}" \
                --instance-id "${{ steps.instance.outputs.instance_id }}" || true
              exit 1
            fi
            sleep 10
          done
          echo "::error::Deploy timed out"
          exit 1

      - name: Show deploy output
        if: always()
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.ssm.outputs.command_id }}" \
            --instance-id "${{ steps.instance.outputs.instance_id }}" \
            --query "[Status, StandardOutputContent, StandardErrorContent]" --output text || true
