{
  "version": 3,
  "sources": [],
  "debugId": "6a7c0ba3-519f-d490-5ba6-f371f9847c8e",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/straight-arrow.ts"],"sourcesContent":["import { Editor, Mat, MatModel, TLArrowShape, Vec, VecLike } from '@tldraw/editor'\nimport { TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tBoundShapeInfo,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tTLArrowBindings,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\n\nexport function getStraightArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n): TLArrowInfo {\n\tconst { arrowheadStart, arrowheadEnd } = shape.props\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings)\n\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = Vec.Med(a, b)\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tbindings,\n\t\t\ttype: 'straight',\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst uAB = Vec.Sub(b, a).uni()\n\n\t// Update the arrowhead points using intersections with the bound shapes, if any.\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'start')\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'end')\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\t// Update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\tb, // <-- will be mutated\n\t\tterminalsInArrowSpace.start,\n\t\tarrowPageTransform,\n\t\tendShapeInfo\n\t)\n\n\t// Then update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\ta, // <-- will be mutated\n\t\tterminalsInArrowSpace.end,\n\t\tarrowPageTransform,\n\t\tstartShapeInfo\n\t)\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\tlet strokeOffsetA = 0\n\tlet strokeOffsetB = 0\n\tlet minLength = MIN_ARROW_LENGTH * shape.props.scale\n\n\tconst isSelfIntersection =\n\t\tstartShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape\n\n\tconst relationship =\n\t\tstartShapeInfo && endShapeInfo\n\t\t\t? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id)\n\t\t\t: 'safe'\n\n\tif (\n\t\trelationship === 'safe' &&\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\t!isSelfIntersection &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\tif (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, then make it\n\t\t\t// a short arrow ending at the end shape intersection.\n\t\t\tif (startShapeInfo.isClosed) {\n\t\t\t\ta.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t\t}\n\t\t} else if (!endShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, or if neither\n\t\t\t// shape intersected, then make it a short arrow starting\n\t\t\t// at the start shape intersection.\n\t\t\tif (endShapeInfo.isClosed) {\n\t\t\t\tb.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t\t}\n\t\t}\n\t}\n\n\tconst distance = Vec.Sub(b, a)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance)\n\tconst didFlip = !Vec.Equals(u, uAB)\n\n\t// If the arrow is bound non-exact to a start shape and the\n\t// start point has an arrowhead, then offset the start point\n\tif (!isSelfIntersection) {\n\t\tif (\n\t\t\trelationship !== 'start-contains-end' &&\n\t\t\tstartShapeInfo &&\n\t\t\tarrowheadStart !== 'none' &&\n\t\t\t!startShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetA =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t: 0)\n\t\t\toffsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale\n\t\t\tminLength += strokeOffsetA * shape.props.scale\n\t\t}\n\n\t\t// If the arrow is bound non-exact to an end shape and the\n\t\t// end point has an arrowhead offset the end point\n\t\tif (\n\t\t\trelationship !== 'end-contains-start' &&\n\t\t\tendShapeInfo &&\n\t\t\tarrowheadEnd !== 'none' &&\n\t\t\t!endShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetB =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\toffsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale\n\t\t\tminLength += strokeOffsetB * shape.props.scale\n\t\t}\n\t}\n\n\t// Adjust offsets if the length of the arrow is too small\n\n\tconst tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tconst tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\tif (Vec.DistMin(tA, tB, minLength)) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\t// both bound + offset\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\t// start bound + offset\n\t\t\toffsetA *= -1\n\t\t} else if (offsetB !== 0) {\n\t\t\t// end bound + offset\n\t\t\toffsetB *= -1\n\t\t} else {\n\t\t\t// noop, its just a really short arrow\n\t\t}\n\t}\n\n\ta.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tb.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\t// If the handles flipped their order, then set the center handle\n\t// to the midpoint of the terminals (rather than the midpoint of the\n\t// arrow body); otherwise, it may not be \"between\" the other terminals.\n\tif (didFlip) {\n\t\tif (startShapeInfo && endShapeInfo) {\n\t\t\t// If we have two bound shapes...then make the arrow a short arrow from\n\t\t\t// the start point towards where the end point should be.\n\t\t\tb.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t}\n\t\tc.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))\n\t} else {\n\t\tc.setTo(Vec.Med(a, b))\n\t}\n\n\tconst length = Vec.Dist(a, b)\n\n\treturn {\n\t\tbindings,\n\t\ttype: 'straight',\n\t\tstart: {\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tpoint: a,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tpoint: b,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\tisValid: length > 0,\n\t\tlength,\n\t}\n}\n\n/** Get an intersection point from A -> B with bound shape (target) from shape (arrow). */\nfunction updateArrowheadPointWithBoundShape(\n\tpoint: Vec,\n\topposite: Vec,\n\tarrowPageTransform: MatModel,\n\ttargetShapeInfo?: BoundShapeInfo\n) {\n\tif (targetShapeInfo === undefined) {\n\t\t// No bound shape? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tif (targetShapeInfo.isExact) {\n\t\t// Exact type binding? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\t// From and To in page space\n\tconst pageFrom = Mat.applyToPoint(arrowPageTransform, opposite)\n\tconst pageTo = Mat.applyToPoint(arrowPageTransform, point)\n\n\t// From and To in local space of the target shape\n\tconst targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom)\n\tconst targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo)\n\n\tconst intersection = Array.from(\n\t\ttargetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\t)\n\n\tlet targetInt: VecLike | undefined\n\n\tif (intersection.length) {\n\t\ttargetInt =\n\t\t\tintersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ??\n\t\t\t(targetShapeInfo.isClosed ? undefined : targetTo)\n\t}\n\n\tif (targetInt === undefined) {\n\t\t// No intersection? The arrowhead point will be at the arrow terminal.\n\t\t// if we _almost_ hit the target, just put the arrowhead at the target.\n\t\ttargetInt = targetShapeInfo.geometry.nearestPoint(targetTo, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\n\t\tif (!Vec.DistMin(targetInt, targetTo, 1)) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tconst pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt)\n\tconst arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt)\n\n\tpoint.setTo(arrowInt)\n\n\ttargetShapeInfo.didIntersect = true\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/curved-arrow.ts"],"sourcesContent":["import {\n\tEditor,\n\tMat,\n\tPI,\n\tPI2,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tcenterOfCircleFromThreePoints,\n\tclockwiseAngleDist,\n\tcounterClockwiseAngleDist,\n\tisSafeFloat,\n} from '@tldraw/editor'\nimport { TLArcInfo, TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tTLArrowBindings,\n\tWAY_TOO_BIG_ARROW_BEND_FACTOR,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nexport function getCurvedArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n): TLArrowInfo {\n\tconst { arrowheadEnd, arrowheadStart } = shape.props\n\tconst bend = shape.props.bend\n\n\tif (\n\t\tMath.abs(bend) >\n\t\tMath.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings)\n\n\tconst med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end) // point between start and end\n\tconst distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance) // unit vector between start and end\n\tconst middle = Vec.Add(med, u.per().mul(-bend)) // middle handle\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'start')\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'end')\n\n\t// The positions of the body of the arrow, which may be different\n\t// than the arrow's start / end points if the arrow is bound to shapes\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = middle.clone()\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tbindings,\n\t\t\ttype: 'straight',\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst isClockwise = shape.props.bend < 0\n\tconst distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist\n\n\tconst handleArc = getArcInfo(a, b, c)\n\tconst handle_aCA = Vec.Angle(handleArc.center, a)\n\tconst handle_aCB = Vec.Angle(handleArc.center, b)\n\tconst handle_dAB = distFn(handle_aCA, handle_aCB)\n\n\tif (\n\t\thandleArc.length === 0 ||\n\t\thandleArc.size === 0 ||\n\t\t!isSafeFloat(handleArc.length) ||\n\t\t!isSafeFloat(handleArc.size)\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst tempA = a.clone()\n\tconst tempB = b.clone()\n\tconst tempC = c.clone()\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\n\tlet minLength = MIN_ARROW_LENGTH * shape.props.scale\n\n\tif (startShapeInfo && !startShapeInfo.isExact) {\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\n\t\tconst inverseTransform = Mat.Inverse(startShapeInfo.transform)\n\n\t\tconst startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst { isClosed } = startShapeInfo\n\t\tlet point: VecLike | undefined\n\t\tlet intersections = Array.from(\n\t\t\tstartShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t})\n\t\t)\n\n\t\tif (intersections.length) {\n\t\t\tconst angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\n\t\t\t// Filter out any intersections that aren't in the arc\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tconst targetDist = dAB * 0.25\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0]\n\t\t}\n\t\tif (!point) {\n\t\t\tif (isClosed) {\n\t\t\t\tconst nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace, {\n\t\t\t\t\tincludeInternal: false,\n\t\t\t\t\tincludeLabels: false,\n\t\t\t\t})\n\t\t\t\tif (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {\n\t\t\t\t\tpoint = nearestPoint\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = startInStartShapeLocalSpace\n\t\t\t}\n\t\t}\n\n\t\tif (point) {\n\t\t\ttempA.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tstartShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadStart !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t\t: 0)\n\t\t\t\toffsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endShapeInfo && !endShapeInfo.isExact) {\n\t\t// get points in shape's coordinates?\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\tconst inverseTransform = Mat.Inverse(endShapeInfo.transform)\n\n\t\tconst startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst isClosed = endShapeInfo.isClosed\n\t\tlet point: VecLike | undefined\n\t\tlet intersections = Array.from(\n\t\t\tendShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t})\n\t\t)\n\n\t\tif (intersections.length) {\n\t\t\tconst angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\t\t\tconst targetDist = dAB * 0.75\n\n\t\t\t// or simplified...\n\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0]\n\t\t}\n\t\tif (!point) {\n\t\t\tif (isClosed) {\n\t\t\t\tconst nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace, {\n\t\t\t\t\tincludeInternal: false,\n\t\t\t\t\tincludeLabels: false,\n\t\t\t\t})\n\t\t\t\tif (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {\n\t\t\t\t\tpoint = nearestPoint\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = endInEndShapeLocalSpace\n\t\t\t}\n\t\t}\n\n\t\tif (point) {\n\t\t\t// Set b to target local point -> page point -> shape local point\n\t\t\ttempB.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tendShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadEnd !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\t\toffsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply arrowhead offsets\n\n\tlet aCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\tlet aCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\tlet dAB = distFn(aCA, aCB) // angle distance between a and b\n\tlet lAB = dAB * handleArc.radius // length of arc between a and b\n\n\t// Try the offsets first, then check whether the distance between the points is too small;\n\t// if it is, flip the offsets and expand them. We need to do this using temporary points\n\t// so that we can apply them both in a balanced way.\n\tconst tA = tempA.clone()\n\tconst tB = tempB.clone()\n\n\tif (offsetA !== 0) {\n\t\ttA.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttB.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (Vec.DistMin(tA, tB, minLength)) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\toffsetA *= -2\n\t\t} else if (offsetB !== 0) {\n\t\t\toffsetB *= -2\n\t\t} else {\n\t\t\t// noop\n\t\t}\n\n\t\t// if we're using negative offsets, we need to make sure that the body arc doesn't end up\n\t\t// larger than the handle arc or things will get weird:\n\t\tconst minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius\n\t\tconst minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius\n\t\toffsetA = Math.max(offsetA, minOffsetA)\n\t\toffsetB = Math.max(offsetB, minOffsetB)\n\t}\n\n\tif (offsetA !== 0) {\n\t\ttempA\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttempB\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\t// Did we miss intersections? This happens when we have overlapping shapes.\n\tif (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n\t\taCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\t\taCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\t\tdAB = distFn(aCA, aCB) // angle distance between a and b\n\t\tlAB = dAB * handleArc.radius // length of arc between a and b\n\t\tconst relationship = getBoundShapeRelationships(\n\t\t\teditor,\n\t\t\tstartShapeInfo.shape.id,\n\t\t\tendShapeInfo.shape.id\n\t\t)\n\n\t\tif (relationship === 'double-bound' && lAB < 30) {\n\t\t\ttempA.setTo(a)\n\t\t\ttempB.setTo(b)\n\t\t\ttempC.setTo(c)\n\t\t} else if (relationship === 'safe') {\n\t\t\tif (startShapeInfo && !startShapeInfo.didIntersect) {\n\t\t\t\ttempA.setTo(a)\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(endShapeInfo && !endShapeInfo.didIntersect) ||\n\t\t\t\tdistFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)\n\t\t\t) {\n\t\t\t\ttempB\n\t\t\t\t\t.setTo(handleArc.center)\n\t\t\t\t\t.add(\n\t\t\t\t\t\tVec.FromAngle(\n\t\t\t\t\t\t\taCA +\n\t\t\t\t\t\t\t\tdAB *\n\t\t\t\t\t\t\t\t\t(Math.min(0.9, (MIN_ARROW_LENGTH * shape.props.scale) / lAB) *\n\t\t\t\t\t\t\t\t\t\t(isClockwise ? 1 : -1))\n\t\t\t\t\t\t).mul(handleArc.radius)\n\t\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tplaceCenterHandle(\n\t\thandleArc.center,\n\t\thandleArc.radius,\n\t\ttempA,\n\t\ttempB,\n\t\ttempC,\n\t\thandle_dAB,\n\t\tisClockwise\n\t)\n\n\tif (tempA.equals(tempB)) {\n\t\ttempA.setTo(tempC.clone().addXY(1, 1))\n\t\ttempB.setTo(tempC.clone().subXY(1, 1))\n\t}\n\n\ta.setTo(tempA)\n\tb.setTo(tempB)\n\tc.setTo(tempC)\n\tconst bodyArc = getArcInfo(a, b, c)\n\n\treturn {\n\t\tbindings,\n\t\ttype: 'arc',\n\t\tstart: {\n\t\t\tpoint: a,\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\tpoint: b,\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\thandleArc,\n\t\tbodyArc,\n\t\tisValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),\n\t}\n}\n\n/**\n * Get info about an arc formed by three points.\n *\n * @param a - The start of the arc\n * @param b - The end of the arc\n * @param c - A point on the arc\n */\nfunction getArcInfo(a: VecLike, b: VecLike, c: VecLike): TLArcInfo {\n\t// find a circle from the three points\n\tconst center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b)\n\n\tconst radius = Vec.Dist(center, a)\n\n\t// Whether to draw the arc clockwise or counter-clockwise (are the points clockwise?)\n\tconst sweepFlag = +Vec.Clockwise(a, c, b)\n\n\t// The base angle of the arc in radians\n\tconst ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5\n\tconst bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5\n\tconst ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5\n\n\tconst theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2\n\n\t// Whether to draw the long arc or short arc\n\tconst largeArcFlag = +(PI > theta)\n\n\t// The size of the arc to draw in radians\n\tconst size = (PI2 - theta) * (sweepFlag ? 1 : -1)\n\n\t// The length of the arc to draw in distance units\n\tconst length = size * radius\n\n\treturn {\n\t\tcenter,\n\t\tradius,\n\t\tsize,\n\t\tlength,\n\t\tlargeArcFlag,\n\t\tsweepFlag,\n\t}\n}\n\nfunction placeCenterHandle(\n\tcenter: VecLike,\n\tradius: number,\n\ttempA: Vec,\n\ttempB: Vec,\n\ttempC: Vec,\n\toriginalArcLength: number,\n\tisClockwise: boolean\n) {\n\tconst aCA = Vec.Angle(center, tempA) // angle center -> a\n\tconst aCB = Vec.Angle(center, tempB) // angle center -> b\n\tlet dAB = clockwiseAngleDist(aCA, aCB) // angle distance between a and b\n\tif (!isClockwise) dAB = PI2 - dAB\n\n\ttempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius))\n\n\tif (dAB > originalArcLength) {\n\t\ttempC.rotWith(center, PI)\n\t\tconst t = tempB.clone()\n\t\ttempB.setTo(tempA)\n\t\ttempA.setTo(t)\n\t}\n}\n"],"names":["dAB"],"mappings":"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"}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/definitions.ts"],"sourcesContent":["import { Box, ElbowArrowSnap, Geometry2d, TLShapeId, Vec, VecLike, VecModel } from '@tldraw/editor'\n\n/**\n * The side of a box that an elbow arrow could enter/exit from.\n * @public\n */\nexport type ElbowArrowSide = 'top' | 'right' | 'bottom' | 'left'\n\n/**\n * The reason a particular side of a shape was chosen for an elbow arrow to enter / exit. Used only\n * for debugging information.\n *\n * - `manual`: The side was chosen because the user indicated this was the desired side\n * - `auto`: The side was chosen automatically based on heuristics for nice-looking arrows\n * - `fallback`: We couldn't draw a route to the edge the user indicated, so fell back to our\n *   heuristics\n *\n * @internal\n */\nexport type ElbowArrowSideReason = 'manual' | 'auto' | 'fallback'\n\n/**\n * A route for an elbow arrow.\n *\n * @public\n */\nexport interface ElbowArrowRoute {\n\t/**\n\t * The name of the route - this is used only for debugging.\n\t * @internal\n\t */\n\tname: string\n\t/** The vertices of the route. Draw a line through them to see the route. */\n\tpoints: Vec[]\n\t/** The total distance of the route, in arrow-space pixels. */\n\tdistance: number\n\t/**\n\t * Why did we pick edge A?\n\t * @internal\n\t */\n\taEdgePicking: ElbowArrowSideReason\n\t/**\n\t * Why did we pick edge B?\n\t * @internal\n\t */\n\tbEdgePicking: ElbowArrowSideReason\n\t/**\n\t * Some points on the line are there for more informative than display reasons - e.g. where the\n\t * midpoint handle is. If we draw these in our \"draw\" style, the line will look weird. We still\n\t * need them for some of the calculations we do, but we want to skip them specifically when\n\t * rendering the arrow.\n\t */\n\tskipPointsWhenDrawing: Set<Vec>\n\t/**\n\t * The midpoint handle of the route, if any.\n\t */\n\tmidpointHandle: ElbowArrowMidpointHandle | null\n}\n\n/**\n * Part of an {@link ElbowArrowRoute} that describes a handle for dragging the midpoint line, a line\n * roughly halfway between the two shapes.\n * @public\n */\nexport interface ElbowArrowMidpointHandle {\n\taxis: 'x' | 'y'\n\t/** The start point of the segment in the route that the handle is on. */\n\tsegmentStart: VecLike\n\t/** The end point of the segment in the route that the handle is on. */\n\tsegmentEnd: VecLike\n\t/** The position of the handle, in arrow-space. */\n\tpoint: VecLike\n}\n\nexport const ElbowArrowSides = ['right', 'bottom', 'left', 'top'] as const\n\n/**\n * Extracted from {@link ArrowShapeOptions}. Options for one specific arrow.\n * @public\n */\nexport interface ElbowArrowOptions {\n\texpandElbowLegLength: number\n\tminElbowLegLength: number\n\telbowMidpoint: number\n}\n\n/**\n * Vectors that point out of each side of a box.\n */\nexport const ElbowArrowSideDeltas = {\n\ttop: { x: 0, y: -1 },\n\tright: { x: 1, y: 0 },\n\tbottom: { x: 0, y: 1 },\n\tleft: { x: -1, y: 0 },\n} as const satisfies Record<ElbowArrowSide, VecModel>\n\n/**\n * The axis along when each side of a box lies.\n */\nexport const ElbowArrowSideAxes = {\n\tleft: 'x',\n\tright: 'x',\n\ttop: 'y',\n\tbottom: 'y',\n} as const satisfies Record<ElbowArrowSide, 'x' | 'y'>\n\n/**\n * The opposite of each side of a box.\n */\nexport const ElbowArrowSideOpposites = {\n\ttop: 'bottom',\n\tright: 'left',\n\tbottom: 'top',\n\tleft: 'right',\n} as const satisfies Record<ElbowArrowSide, ElbowArrowSide>\n\nexport const ElbowArrowAxes = {\n\tx: {\n\t\tv: (x: number, y: number) => new Vec(x, y),\n\t\tloEdge: 'left',\n\t\thiEdge: 'right',\n\t\tcrossMid: 'midY',\n\t\tgap: 'gapX',\n\t\tmidRange: 'midXRange',\n\t\tself: 'x',\n\t\tcross: 'y',\n\t\tsize: 'width',\n\t},\n\ty: {\n\t\tv: (y: number, x: number) => new Vec(x, y),\n\t\tloEdge: 'top',\n\t\thiEdge: 'bottom',\n\t\tcrossMid: 'midX',\n\t\tgap: 'gapY',\n\t\tmidRange: 'midYRange',\n\t\tself: 'y',\n\t\tcross: 'x',\n\t\tsize: 'height',\n\t},\n} as const\n\nexport type ElbowArrowAxis = (typeof ElbowArrowAxes)[keyof typeof ElbowArrowAxes]\n\nexport type ElbowArrowSideWithAxis = ElbowArrowSide | 'x' | 'y'\n\n/** @public */\nexport interface ElbowArrowBoxes {\n\t/** The starting bounding box */\n\tA: Box\n\t/** The ending bounding box */\n\tB: Box\n\t/** The common bounding box of A and B */\n\tcommon: Box\n}\n\n/** @public */\nexport interface ElbowArrowRange {\n\tmin: number\n\tmax: number\n}\n\n/**\n * An edge on a box.\n * @public\n */\nexport interface ElbowArrowEdge {\n\t/**\n\t * The co-ordinate of the edge. An x-coordinate if left/right, a y-coordinate if top/bottom.\n\t */\n\tvalue: number\n\t/**\n\t * The co-ordinate of the edge, expanded by {@link ArrowShapeOptions.expandElbowLegLength}. May\n\t * be null if the target is a point.\n\t */\n\texpanded: number | null\n\t/**\n\t * The usable range of the edge along its cross-axis. Y-coordinates if left/right, x-coordinated\n\t * if top/bottom.\n\t */\n\tcross: ElbowArrowRange\n\t/**\n\t * The point of the target along the edge, constrained to within {@link ElbowArrowEdge.cross}.\n\t */\n\tcrossTarget: number\n\t/**\n\t * Whether the cross-axis range is shrunk from the original range to make space for the other shape.\n\t */\n\tisPartial: boolean\n}\n\n/**\n * The usable range of the edges of a box. Each edge might be null if the edge is not usable for\n * entry/exit.\n * @public\n */\nexport interface ElbowArrowBoxEdges {\n\ttop: ElbowArrowEdge | null\n\tright: ElbowArrowEdge | null\n\tbottom: ElbowArrowEdge | null\n\tleft: ElbowArrowEdge | null\n}\n\n/**\n * @public\n */\nexport interface ElbowArrowBox {\n\t/** The original bounding box */\n\toriginal: Box\n\t/**\n\t * The bounding box, expanded by {@link ArrowShapeOptions.expandElbowLegLength}.\n\t */\n\texpanded: Box\n}\n\n/**\n * @public\n */\nexport interface ElbowArrowTargetBox extends ElbowArrowBox {\n\t/** What specific point in the box are we aiming for? */\n\ttarget: Vec\n\t/**\n\t * If true, the arrow should end at `target`. If false, the arrow should end at the edge of the\n\t * shape, pointing at `target`.\n\t */\n\tisExact: boolean\n\t/**\n\t * How far away from this box should the arrow terminate to leave space for the arrowhead?\n\t */\n\tarrowheadOffset: number\n\t/**\n\t * The minimum length of the segment of the arrow that actually reaches the target - and has the\n\t * arrowhead on it.\n\t */\n\tminEndSegmentLength: number\n\t/**\n\t * The usable edges of the box.\n\t */\n\tedges: ElbowArrowBoxEdges\n\t/**\n\t * The geometry of the bound shape, in arrow space.\n\t */\n\tgeometry: Geometry2d | null\n\t/**\n\t * Are we treating this target as a single point in space rather than a bounding box?\n\t */\n\tisPoint: boolean\n}\n\n/** @public */\nexport interface ElbowArrowInfoWithoutRoute {\n\t/**\n\t * The options used for this elbow arrow\n\t */\n\toptions: ElbowArrowOptions\n\n\t/**\n\t * If false, A is the start shape and B is the end shape. If true, A is the end shape and B is\n\t * the start shape.\n\t */\n\tswapOrder: boolean\n\n\t/**\n\t * One of the two shapes we're drawing an arrow between. Could be either the start or end\n\t * depending on `swapOrder`.\n\t */\n\tA: ElbowArrowTargetBox\n\t/**\n\t * The other shape we're drawing an arrow between. Could be either the start or end\n\t * depending on `swapOrder`.\n\t */\n\tB: ElbowArrowTargetBox\n\t/**\n\t * The common bounding box of A and B.\n\t */\n\tcommon: ElbowArrowBox\n\n\t/**\n\t * The gap between the right edge of A and the left edge of B.\n\t */\n\tgapX: number\n\t/**\n\t * The gap between the bottom edge of A and the top edge of B.\n\t */\n\tgapY: number\n\t/**\n\t * The X coordinate of the middle line between the two boxes. If the boxes are too close or\n\t * overlap, this may be null.\n\t */\n\tmidX: number | null\n\t/**\n\t * The Y coordinate of the middle line between the two boxes. If the boxes are too close or\n\t * overlap, this may be null.\n\t */\n\tmidY: number | null\n}\n\n/** @public */\nexport interface ElbowArrowInfo extends ElbowArrowInfoWithoutRoute {\n\t/**\n\t * The route of the arrow.\n\t */\n\troute: ElbowArrowRoute | null\n\n\tmidXRange: { lo: number; hi: number } | null\n\tmidYRange: { lo: number; hi: number } | null\n}\n\nexport interface ElbowArrowTerminal {\n\t/**\n\t * The id of the shape we're binding to, if any.\n\t */\n\ttargetShapeId: TLShapeId | null\n\t/**\n\t * The side of the box that the arrow should enter from.\n\t */\n\tside: ElbowArrowSideWithAxis | null\n\t/**\n\t * The bounding box of the shape. May have width/height of 0 if the shape is a point.\n\t */\n\tbounds: Box\n\t/**\n\t * The geometry of the we're binding to, if it exists.\n\t */\n\tgeometry: Geometry2d | null\n\t/**\n\t * The target point of the arrow.\n\t */\n\ttarget: Vec\n\t/**\n\t * How far away from the target should the arrow terminate to leave space for the arrowhead?\n\t */\n\tarrowheadOffset: number\n\t/**\n\t * The minimum length of the segment of the arrow that actually reaches the target - and has the\n\t * arrowhead on it.\n\t */\n\tminEndSegmentLength: number\n\t/**\n\t * Whether the target is an exact point. within a shape's geometry.\n\t */\n\tisExact: boolean\n\t/**\n\t * Whether the target is a point, rather than a bounding box\n\t */\n\tisPoint: boolean\n\t/**\n\t * How did this binding get snapped to the target shape?\n\t */\n\tsnap: ElbowArrowSnap\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,SAAqD,WAA8B;;AA0E5E,MAAM,kBAAkB;IAAC;IAAS;IAAU;IAAQ,KAAK;CAAA;AAezD,MAAM,uBAAuB;IACnC,KAAK;QAAE,GAAG;QAAG,GAAG,CAAA;IAAG;IACnB,OAAO;QAAE,GAAG;QAAG,GAAG;IAAE;IACpB,QAAQ;QAAE,GAAG;QAAG,GAAG;IAAE;IACrB,MAAM;QAAE,GAAG,CAAA;QAAI,GAAG;IAAE;AACrB;AAKO,MAAM,qBAAqB;IACjC,MAAM;IACN,OAAO;IACP,KAAK;IACL,QAAQ;AACT;AAKO,MAAM,0BAA0B;IACtC,KAAK;IACL,OAAO;IACP,QAAQ;IACR,MAAM;AACP;AAEO,MAAM,iBAAiB;IAC7B,GAAG;QACF,GAAG,CAAC,GAAW,IAAc,IAAI,uOAAA,CAAI,GAAG,CAAC;QACzC,QAAQ;QACR,QAAQ;QACR,UAAU;QACV,KAAK;QACL,UAAU;QACV,MAAM;QACN,OAAO;QACP,MAAM;IACP;IACA,GAAG;QACF,GAAG,CAAC,GAAW,IAAc,IAAI,uOAAA,CAAI,GAAG,CAAC;QACzC,QAAQ;QACR,QAAQ;QACR,UAAU;QACV,KAAK;QACL,UAAU;QACV,MAAM;QACN,OAAO;QACP,MAAM;IACP;AACD"}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/range.tsx"],"sourcesContent":["import { assert, clamp } from '@tldraw/editor'\n\nexport interface Range {\n\tmin: number\n\tmax: number\n}\n\nexport function expandRange(range: Range, amount: number) {\n\tconst newRange: Range = {\n\t\tmin: range.min - amount,\n\t\tmax: range.max + amount,\n\t}\n\tif (newRange.min > newRange.max) {\n\t\treturn null\n\t}\n\treturn newRange\n}\n\nexport function clampToRange(value: number, range: Range) {\n\treturn clamp(value, range.min, range.max)\n}\n\n/**\n * Subtract the range b from the range a. If b is completely inside a, return the two ranges of a\n * that are outside of b. If b contains a, return []. Otherwise, return the range of a that is\n * outside of b.\n */\nexport function subtractRange(a: Range, b: Range): [] | [Range] | [Range, Range] {\n\tassert(a.min <= a.max && b.min <= b.max)\n\n\t// if b is completely inside a:\n\tif (a.min <= b.min && b.max <= a.max) {\n\t\treturn [\n\t\t\t{ min: a.min, max: b.min },\n\t\t\t{ min: b.max, max: a.max },\n\t\t]\n\t}\n\n\t// if b is completely outside of a:\n\tif (b.max <= a.min || b.min >= a.max) {\n\t\treturn [a]\n\t}\n\n\t// if b fully contains a:\n\tif (b.min <= a.min && a.max <= b.max) {\n\t\treturn []\n\t}\n\n\t// if b overlaps a on the low side:\n\tif (isWithinRange(a.min, b)) {\n\t\treturn [{ min: b.max, max: a.max }]\n\t}\n\n\t// if b overlaps a on the high side:\n\tif (isWithinRange(a.max, b)) {\n\t\treturn [{ min: a.min, max: b.min }]\n\t}\n\n\t// unreachable (?)\n\treturn []\n}\n\nexport function createRange(a: number, b: number) {\n\treturn { min: Math.min(a, b), max: Math.max(a, b) }\n}\n\nexport function doRangesOverlap(a: Range, b: Range) {\n\treturn a.min <= b.max && a.max >= b.min\n}\n\nexport function isWithinRange(value: number, range: Range) {\n\treturn value >= range.min && value <= range.max\n}\n\nexport function rangeSize(range: Range) {\n\treturn range.max - range.min\n}\n\nexport function rangeCenter(range: Range) {\n\treturn (range.min + range.max) / 2\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,SAAS,QAAQ,aAAa;;AAOvB,SAAS,YAAY,KAAA,EAAc,MAAA,EAAgB;IACzD,MAAM,WAAkB;QACvB,KAAK,MAAM,GAAA,GAAM;QACjB,KAAK,MAAM,GAAA,GAAM;IAClB;IACA,IAAI,SAAS,GAAA,GAAM,SAAS,GAAA,EAAK;QAChC,OAAO;IACR;IACA,OAAO;AACR;AAEO,SAAS,aAAa,KAAA,EAAe,KAAA,EAAc;IACzD,WAAO,2OAAA,EAAM,OAAO,MAAM,GAAA,EAAK,MAAM,GAAG;AACzC;AAOO,SAAS,cAAc,CAAA,EAAU,CAAA,EAAyC;IAChF,IAAA,sNAAA,EAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAG;IAGvC,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO;YACN;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI;YACzB;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI;SAC1B;IACD;IAGA,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO;YAAC,CAAC;SAAA;IACV;IAGA,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO,CAAC,CAAA;IACT;IAGA,IAAI,cAAc,EAAE,GAAA,EAAK,CAAC,GAAG;QAC5B,OAAO;YAAC;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI,CAAC;SAAA;IACnC;IAGA,IAAI,cAAc,EAAE,GAAA,EAAK,CAAC,GAAG;QAC5B,OAAO;YAAC;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI,CAAC;SAAA;IACnC;IAGA,OAAO,CAAC,CAAA;AACT;AAEO,SAAS,YAAY,CAAA,EAAW,CAAA,EAAW;IACjD,OAAO;QAAE,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC;QAAG,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC;IAAE;AACnD;AAEO,SAAS,gBAAgB,CAAA,EAAU,CAAA,EAAU;IACnD,OAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA;AACrC;AAEO,SAAS,cAAc,KAAA,EAAe,KAAA,EAAc;IAC1D,OAAO,SAAS,MAAM,GAAA,IAAO,SAAS,MAAM,GAAA;AAC7C;AAEO,SAAS,UAAU,KAAA,EAAc;IACvC,OAAO,MAAM,GAAA,GAAM,MAAM,GAAA;AAC1B;AAEO,SAAS,YAAY,KAAA,EAAc;IACzC,OAAA,CAAQ,MAAM,GAAA,GAAM,MAAM,GAAA,IAAO;AAClC"}},
    {"offset": {"line": 615, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/ElbowArrowWorkingInfo.ts"],"sourcesContent":["import { Box, Vec, VecLike } from '@tldraw/editor'\nimport {\n\tElbowArrowBoxEdges,\n\tElbowArrowEdge,\n\tElbowArrowInfoWithoutRoute,\n\tElbowArrowOptions,\n} from '../definitions'\n\n/**\n * A transform that can be applied when working on elbow arrows. This only models flipping x/y or\n * transposing x/y (for 90 degree rotations).\n */\nexport interface ElbowArrowTransform {\n\treadonly x: 1 | -1\n\treadonly y: 1 | -1\n\treadonly transpose: boolean\n}\n\nfunction flipEdgeCrossInPlace(edge: ElbowArrowEdge | null) {\n\tif (!edge) return\n\tconst tmp = edge.cross.min\n\tedge.cross.min = -edge.cross.max\n\tedge.cross.max = -tmp\n\tedge.crossTarget = -edge.crossTarget\n}\n\nfunction flipEdgeValueInPlace(edge: ElbowArrowEdge | null) {\n\tif (!edge) return\n\tedge.value = -edge.value\n\tedge.expanded = edge.expanded === null ? null : -edge.expanded\n}\n\nexport const ElbowArrowTransform = {\n\tIdentity: { x: 1, y: 1, transpose: false } as const,\n\tRotate90: { x: -1, y: 1, transpose: true } as const,\n\tRotate180: { x: -1, y: -1, transpose: false } as const,\n\tRotate270: { x: 1, y: -1, transpose: true } as const,\n\tFlipX: { x: -1, y: 1, transpose: false } as const,\n\tFlipY: { x: 1, y: -1, transpose: false } as const,\n}\n\nfunction invertElbowArrowTransform(transform: ElbowArrowTransform): ElbowArrowTransform {\n\tif (transform.transpose) {\n\t\treturn {\n\t\t\tx: transform.y,\n\t\t\ty: transform.x,\n\t\t\ttranspose: true,\n\t\t}\n\t}\n\n\treturn transform\n}\n\nexport function transformElbowArrowTransform(a: ElbowArrowTransform, b: ElbowArrowTransform) {\n\t// apply b to a:\n\tconst next = { ...a }\n\n\tif (b.transpose) {\n\t\tswap(next, 'x', 'y')\n\t\tnext.transpose = !next.transpose\n\t}\n\n\tif (b.x === -1) {\n\t\tnext.x = -next.x as 1 | -1\n\t}\n\tif (b.y === -1) {\n\t\tnext.y = -next.y as 1 | -1\n\t}\n\n\treturn next\n}\n\nfunction swap<const A extends string, const B extends string>(\n\tobject: { [key in A | B]: any },\n\ta: A,\n\tb: B\n) {\n\tconst temp = object[a]\n\tobject[a] = object[b]\n\tobject[b] = temp\n}\n\nfunction transformVecInPlace(transform: ElbowArrowTransform, point: VecLike) {\n\tpoint.x = transform.x * point.x\n\tpoint.y = transform.y * point.y\n\n\tif (transform.transpose) {\n\t\tswap(point, 'x', 'y')\n\t}\n}\n\nfunction transformBoxInPlace(transform: ElbowArrowTransform, box: Box) {\n\tif (transform.x === -1) {\n\t\tbox.x = -(box.x + box.width)\n\t}\n\tif (transform.y === -1) {\n\t\tbox.y = -(box.y + box.height)\n\t}\n\tif (transform.transpose) {\n\t\tswap(box, 'x', 'y')\n\t\tswap(box, 'width', 'height')\n\t}\n}\n\nfunction transformEdgesInPlace(transform: ElbowArrowTransform, edges: ElbowArrowBoxEdges) {\n\tif (transform.x === -1) {\n\t\tswap(edges, 'left', 'right')\n\t\tflipEdgeCrossInPlace(edges.top)\n\t\tflipEdgeCrossInPlace(edges.bottom)\n\t\tflipEdgeValueInPlace(edges.left)\n\t\tflipEdgeValueInPlace(edges.right)\n\t}\n\tif (transform.y === -1) {\n\t\tswap(edges, 'top', 'bottom')\n\t\tflipEdgeCrossInPlace(edges.left)\n\t\tflipEdgeCrossInPlace(edges.right)\n\t\tflipEdgeValueInPlace(edges.top)\n\t\tflipEdgeValueInPlace(edges.bottom)\n\t}\n\tif (transform.transpose) {\n\t\tswap(edges, 'left', 'top')\n\t\tswap(edges, 'right', 'bottom')\n\t}\n}\n\nexport function debugElbowArrowTransform(transform: ElbowArrowTransform) {\n\tswitch (\n\t\t`${transform.transpose ? 't' : ''}${transform.x === -1 ? 'x' : ''}${transform.y === -1 ? 'y' : ''}`\n\t) {\n\t\tcase '':\n\t\t\treturn 'Identity'\n\t\tcase 't':\n\t\t\treturn 'Transpose'\n\t\tcase 'x':\n\t\t\treturn 'FlipX'\n\t\tcase 'y':\n\t\t\treturn 'FlipY'\n\t\tcase 'tx':\n\t\t\treturn 'Rotate90'\n\t\tcase 'ty':\n\t\t\treturn 'Rotate270'\n\t\tcase 'xy':\n\t\t\treturn 'Rotate180'\n\t\tcase 'txy':\n\t\t\treturn 'spooky (transpose + flip both)'\n\t\tdefault:\n\t\t\tthrow new Error('Unknown transform')\n\t}\n}\n\nexport interface ElbowArrowWorkingBox {\n\toriginal: Box\n\texpanded: Box\n\tedges: ElbowArrowBoxEdges\n\tisPoint: boolean\n}\n\nexport class ElbowArrowWorkingInfo {\n\toptions: ElbowArrowOptions\n\tA: ElbowArrowWorkingBox\n\tB: ElbowArrowWorkingBox\n\tcommon: {\n\t\toriginal: Box\n\t\texpanded: Box\n\t}\n\tgapX: number\n\tgapY: number\n\tmidX: number | null\n\tmidY: number | null\n\tbias: Vec\n\n\tconstructor(info: ElbowArrowInfoWithoutRoute) {\n\t\tthis.options = info.options\n\t\tthis.A = info.A\n\t\tthis.B = info.B\n\t\tthis.common = info.common\n\t\tthis.midX = info.midX\n\t\tthis.midY = info.midY\n\t\tthis.gapX = info.gapX\n\t\tthis.gapY = info.gapY\n\t\t// prefer down/right when routing arrows\n\t\tthis.bias = new Vec(1, 1)\n\t}\n\n\ttransform: ElbowArrowTransform = ElbowArrowTransform.Identity\n\tinverse: ElbowArrowTransform = ElbowArrowTransform.Identity\n\n\tapply(transform: ElbowArrowTransform) {\n\t\tthis.transform = transformElbowArrowTransform(transform, this.transform)\n\t\tthis.inverse = invertElbowArrowTransform(this.transform)\n\n\t\ttransformBoxInPlace(transform, this.A.original)\n\t\ttransformBoxInPlace(transform, this.B.original)\n\t\ttransformBoxInPlace(transform, this.common.original)\n\n\t\ttransformBoxInPlace(transform, this.A.expanded)\n\t\ttransformBoxInPlace(transform, this.B.expanded)\n\t\ttransformBoxInPlace(transform, this.common.expanded)\n\n\t\ttransformEdgesInPlace(transform, this.A.edges)\n\t\ttransformEdgesInPlace(transform, this.B.edges)\n\n\t\ttransformVecInPlace(transform, this.bias)\n\n\t\tif (transform.x === -1) {\n\t\t\tthis.gapX = -this.gapX\n\t\t\tthis.midX = this.midX === null ? null : -this.midX\n\t\t}\n\t\tif (transform.y === -1) {\n\t\t\tthis.gapY = -this.gapY\n\t\t\tthis.midY = this.midY === null ? null : -this.midY\n\t\t}\n\n\t\tif (transform.transpose) {\n\t\t\tlet temp = this.midX\n\t\t\tthis.midX = this.midY\n\t\t\tthis.midY = temp\n\t\t\ttemp = this.gapX\n\t\t\tthis.gapX = this.gapY\n\t\t\tthis.gapY = temp\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.apply(this.inverse)\n\t}\n\n\tvec(x: number, y: number) {\n\t\tconst point = new Vec(x, y)\n\t\ttransformVecInPlace(this.inverse, point)\n\t\treturn point\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 831, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/ElbowArrowRouteBuilder.ts"],"sourcesContent":["import { assert, Vec, VecLike } from '@tldraw/editor'\nimport { ElbowArrowMidpointHandle, ElbowArrowRoute } from '../definitions'\nimport { ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\n\nconst MIN_DISTANCE = 0.01\n\nexport class ElbowArrowRouteBuilder {\n\tpoints: Vec[] = []\n\n\tconstructor(\n\t\tprivate readonly info: ElbowArrowWorkingInfo,\n\t\tpublic readonly name: string\n\t) {}\n\n\tadd(x: number, y: number): this {\n\t\tthis.points.push(this.info.vec(x, y))\n\n\t\treturn this\n\t}\n\n\tprivate _midpointHandle: ElbowArrowMidpointHandle | null = null\n\tmidpointHandle(axis: 'x' | 'y'): this {\n\t\tassert(this._midpointHandle === null, 'midX/midY called multiple times')\n\n\t\tconst point = Vec.Lrp(\n\t\t\tthis.points[this.points.length - 2],\n\t\t\tthis.points[this.points.length - 1],\n\t\t\t0.5\n\t\t)\n\n\t\tthis._midpointHandle = {\n\t\t\taxis: this.info.transform.transpose ? (axis === 'x' ? 'y' : 'x') : axis,\n\t\t\tpoint,\n\t\t\tsegmentStart: this.points[this.points.length - 2].clone(),\n\t\t\tsegmentEnd: this.points[this.points.length - 1].clone(),\n\t\t}\n\n\t\treturn this\n\t}\n\n\tbuild(): ElbowArrowRoute {\n\t\tconst finalPoints = []\n\t\tfor (let i = 0; i < this.points.length; i++) {\n\t\t\tconst p0 = this.points[i]\n\t\t\tconst p1 = finalPoints[finalPoints.length - 1]\n\t\t\tconst p2 = finalPoints[finalPoints.length - 2]\n\n\t\t\tif (!p1 || !p2) {\n\t\t\t\tfinalPoints.push(p0)\n\t\t\t} else {\n\t\t\t\tconst d1x = Math.abs(p0.x - p1.x)\n\t\t\t\tconst d1y = Math.abs(p0.y - p1.y)\n\t\t\t\tconst d2x = Math.abs(p0.x - p2.x)\n\t\t\t\tconst d2y = Math.abs(p0.y - p2.y)\n\n\t\t\t\tif (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) {\n\t\t\t\t\t// this point is basically in the same place as the last one, so ignore it\n\t\t\t\t} else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same vertical line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.y = p0.y\n\t\t\t\t} else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same horizontal line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.x = p0.x\n\t\t\t\t} else {\n\t\t\t\t\t// this coord is changing direction, so add it to the points\n\t\t\t\t\tfinalPoints.push(p0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tpoints: finalPoints,\n\t\t\tdistance: measureRouteManhattanDistance(finalPoints),\n\t\t\taEdgePicking: 'manual',\n\t\t\tbEdgePicking: 'manual',\n\t\t\tskipPointsWhenDrawing: new Set(),\n\t\t\tmidpointHandle: this._midpointHandle,\n\t\t}\n\t}\n}\n\nfunction measureRouteManhattanDistance(path: VecLike[]): number {\n\tlet distance = 0\n\tfor (let i = 0; i < path.length - 1; i++) {\n\t\tconst start = path[i]\n\t\tconst end = path[i + 1]\n\t\tdistance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y)\n\t}\n\treturn distance\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 910, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/elbowArrowRoutes.tsx"],"sourcesContent":["import { ElbowArrowRoute, ElbowArrowSide } from '../definitions'\nimport { ElbowArrowRouteBuilder } from './ElbowArrowRouteBuilder'\nimport { ElbowArrowTransform, ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\n\n/**\n * Draw one of these arrows:\n *\n * ```\n * 1:              2:         3:          4:          5:\n * \u250C\u2500\u2500\u2500\u2510           \u250C\u2500\u2500\u2500\u2510      \u250C\u2500\u2500\u2500\u2510       \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250C\u2500\u2500\u2500\u2510\n * \u2502 A \u251C\u2500\u2510         \u2502 A \u251C\u2500\u2510    \u2502 A \u251C\u2500\u2500\u2500\u2510   \u2502 \u250C\u2500\u2500\u2500\u2510 \u2502   \u2502 \u250C\u2500\u2500\u2500\u2510 \u2502 \u2502 A \u251C\u2500\u2510\n * \u2514\u2500\u2500\u2500\u2518 \u2502 \u250C\u2500\u2500\u2500\u2510   \u2514\u2500\u2500\u2500\u2518 \u2502    \u2514\u2500\u2500\u2500\u2518   \u2502   \u2502 \u2502 A \u251C\u2500\u2518   \u2514\u2500\u25BA B \u2502 \u2502 \u2514\u2500\u2500\u2500\u2518 \u2502\n *       \u2514\u2500\u25BA B \u2502    \u250C\u2500\u2500\u2500\u2500\u2518      \u250C\u2500\u2500\u2500\u2510 \u2502   \u2502 \u2514\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *         \u2514\u2500\u2500\u2500\u2518    \u2502 \u250C\u2500\u2500\u2500\u2510   \u250C\u25BA\u2502 B \u2502 \u2502   \u2502   \u250C\u2500\u2500\u2500\u2510\n *                  \u2514\u2500\u25BA B \u2502   \u2502 \u2514\u2500\u2500\u2500\u2518 \u2502   \u2514\u2500\u2500\u2500\u25BA B \u2502\n *                    \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2518\n * ```\n */\nexport function routeRightToLeft(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.left\n\n\t// we can't draw this arrow if we don't have the proper edge we want:\n\tif (!aEdge || !bEdge) return null\n\n\t// just so we get to handle less edge cases, flip the boxes if A is below B:\n\tif (aEdge.crossTarget > bEdge.crossTarget) {\n\t\tinfo.apply(ElbowArrowTransform.FlipY)\n\t}\n\n\tif (info.gapX > 0 && info.midX !== null) {\n\t\t// Arrow 1:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, bEdge.crossTarget)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (aEdge.expanded === null || bEdge.expanded === null) return null\n\n\tif (info.midY !== null) {\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 2')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(bEdge.expanded, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tconst arrow3Distance =\n\t\tMath.abs(aEdge.value - info.common.expanded.right) +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.bottom) +\n\t\tMath.abs(info.common.expanded.right - bEdge.expanded) +\n\t\tMath.abs(info.common.expanded.bottom - bEdge.crossTarget) +\n\t\tinfo.options.expandElbowLegLength +\n\t\t6 // 6 points in this arrow\n\n\tconst arrow4Distance =\n\t\tinfo.options.expandElbowLegLength +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.top) +\n\t\tMath.abs(aEdge.expanded - info.common.expanded.left) +\n\t\tMath.abs(info.common.expanded.top - bEdge.crossTarget) +\n\t\tMath.abs(info.common.expanded.left - bEdge.value) +\n\t\t// 6 points in this arrow, plus bias towards down/right:\n\t\t6 +\n\t\tinfo.bias.y\n\n\tconst arrow5Distance =\n\t\tinfo.gapX < 0 && info.midX !== null\n\t\t\t? info.options.expandElbowLegLength +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\t\tinfo.common.expanded.width +\n\t\t\t\tMath.abs(info.A.expanded.bottom - info.B.expanded.top) +\n\t\t\t\tMath.abs(info.B.expanded.top - bEdge.crossTarget) +\n\t\t\t\tinfo.options.expandElbowLegLength +\n\t\t\t\t// 8 points in this arrow\n\t\t\t\t8\n\t\t\t: Infinity\n\n\tif (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 3')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, info.common.expanded.bottom)\n\t\t\t.add(bEdge.expanded, info.common.expanded.bottom)\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (arrow4Distance < arrow5Distance) {\n\t\t// Arrow 4:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 4')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.common.expanded.top)\n\t\t\t.add(info.common.expanded.left, info.common.expanded.top)\n\t\t\t.add(info.common.expanded.left, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (info.midX !== null) {\n\t\t// Arrow 5:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 5')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.B.expanded.top)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.expanded, info.B.expanded.top)\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\n/**\n * Draw one of these arrows:\n * ```\n * 1:              2:              3:\n * \u250C\u2500\u2500\u2500\u2510                 \u250C\u2500\u2500\u2500\u2510     \u250C\u2500\u2500\u2500\u2510\n * \u2502 A \u251C\u2500\u2500\u2500\u2500\u2500\u2510     \u250C\u2500\u2500\u2500\u2510 \u2502 \u250C\u2500\u25BC\u2500\u2510   \u2502 A \u251C\u2500\u2510\n * \u2514\u2500\u2500\u2500\u2518     \u2502     \u2502 A \u251C\u2500\u2518 \u2502 B \u2502   \u2514\u2500\u2500\u2500\u2518 \u2502\n *         \u250C\u2500\u25BC\u2500\u2510   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518     \u250C\u2500\u2500\u2500\u2518\n *         \u2502 B \u2502                   \u250C\u2500\u25BC\u2500\u2510\n *         \u2514\u2500\u2500\u2500\u2518                   \u2502 B \u2502\n *                                 \u2514\u2500\u2500\u2500\u2518\n * 4:        5:          6:\n *   \u250C\u2500\u2500\u2500\u2510     \u250C\u2500\u2500\u2500\u2510       \u250C\u2500\u2500\u2500\u2510 \u250C\u2500\u2500\u2500\u2510\n * \u250C\u2500\u25BC\u2500\u2510 \u2502     \u2502 \u250C\u2500\u25BC\u2500\u2510   \u250C\u2500\u25BC\u2500\u2510 \u2502 \u2502 A \u251C\u2500\u2510\n * \u2502 B \u2502 \u2502     \u2502 \u2502 B \u2502   \u2502 B \u2502 \u2502 \u2514\u2500\u2500\u2500\u2518 \u2502\n * \u2514\u2500\u2500\u2500\u2518 \u2502     \u2502 \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * \u250C\u2500\u2500\u2500\u2510 \u2502     \u2514\u2500\u2500\u2500\u2510\n * \u2502 A \u251C\u2500\u2518   \u250C\u2500\u2500\u2500\u2510 \u2502\n * \u2514\u2500\u2500\u2500\u2518     \u2502 A \u251C\u2500\u2518\n *           \u2514\u2500\u2500\u2500\u2518\n * ```\n */\nexport function routeRightToTop(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.top\n\n\tif (!aEdge || !bEdge) return null\n\n\tif (\n\t\t(aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) &&\n\t\t\tbEdge.crossTarget > (aEdge.expanded ?? aEdge.value)) ||\n\t\t(info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center))\n\t) {\n\t\t// Arrow 1:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(bEdge.crossTarget, aEdge.crossTarget)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 2')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, bEdge.expanded)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (\n\t\tinfo.gapY > 0 &&\n\t\taEdge.expanded !== null &&\n\t\tbEdge.crossTarget < aEdge.expanded &&\n\t\tinfo.midY !== null\n\t) {\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 3')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(bEdge.crossTarget, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tconst arrow4Length =\n\t\tMath.abs(aEdge.value - info.common.expanded.right) +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.top) +\n\t\tMath.abs(bEdge.crossTarget - info.common.expanded.right) +\n\t\tMath.abs(bEdge.value - info.common.expanded.top)\n\n\tconst arrow5Length =\n\t\taEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null\n\t\t\t? Math.abs(aEdge.value - aEdge.expanded) +\n\t\t\t\tMath.abs(info.B.expanded.left - aEdge.expanded) +\n\t\t\t\tMath.abs(info.B.expanded.left - bEdge.crossTarget) +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.top) +\n\t\t\t\tMath.abs(bEdge.value - bEdge.expanded)\n\t\t\t: Infinity\n\n\tconst arrow6Length =\n\t\taEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null\n\t\t\t? Math.abs(aEdge.value - info.common.expanded.right) +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\t\tMath.abs(aEdge.expanded - bEdge.crossTarget) +\n\t\t\t\tMath.abs(info.A.expanded.bottom - bEdge.expanded) +\n\t\t\t\tMath.abs(bEdge.expanded - bEdge.value)\n\t\t\t: Infinity\n\n\tif (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {\n\t\t// Arrow 4:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 4')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, info.common.expanded.top)\n\t\t\t.add(bEdge.crossTarget, info.common.expanded.top)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (\n\t\tbEdge.expanded !== null &&\n\t\taEdge.expanded !== null &&\n\t\tinfo.midY !== null &&\n\t\tarrow5Length < arrow6Length\n\t) {\n\t\t// Arrow 5:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 5')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(info.B.expanded.left, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(info.B.expanded.left, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {\n\t\t// Arrow 6:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 6')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.A.expanded.bottom)\n\t\t\t.add(info.midX, bEdge.expanded)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\n/**\n * See `routeRightToTop`.\n */\nexport function routeRightToBottom(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tinfo.apply(ElbowArrowTransform.FlipY)\n\treturn routeRightToTop(info)\n}\n\n/**\n * Arrows may be mirrored - Y flipped\n * ```\n * 1:        2:                3:\n * \u250C\u2500\u2500\u2500\u2510     \u250C\u2500\u2500\u2500\u2510 \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250C\u2500\u2500\u2500\u2510\n * \u2502 A \u251C\u2500\u2510   \u2502 A \u251C\u2500\u2518 \u250C\u2500\u2500\u2500\u2510 \u2502   \u250C\u2500\u2500\u2500\u2510   \u2502 A \u251C\u2500\u2510\n * \u2514\u2500\u2500\u2500\u2518 \u2502   \u2514\u2500\u2500\u2500\u2518   \u2502 B \u25C4\u2500\u2518   \u2502 B \u25C4\u2500\u2510 \u2514\u2500\u2500\u2500\u2518 \u2502\n * \u250C\u2500\u2500\u2500\u2510 \u2502           \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * \u2502 B \u25C4\u2500\u2518\n * \u2514\u2500\u2500\u2500\u2518\n * ```\n */\nexport function routeRightToRight(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.right\n\n\tif (!aEdge || !bEdge) return null\n\n\tif (\n\t\t(info.gapX <= 0 ||\n\t\t\taEdge.crossTarget > info.B.expanded.bottom ||\n\t\t\taEdge.crossTarget < info.B.expanded.top) &&\n\t\t(bEdge.value > info.A.original.left ||\n\t\t\tbEdge.crossTarget > info.A.expanded.bottom ||\n\t\t\tbEdge.crossTarget < info.A.expanded.top)\n\t) {\n\t\t// Arrow 1\n\t\treturn new ElbowArrowRouteBuilder(info, 'to right 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (info.midX === null) return null\n\n\tif (bEdge.expanded !== null && info.gapX >= 0) {\n\t\tconst viaBottomLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.B.expanded.bottom) +\n\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.bottom)\n\t\tconst viaTopLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.B.expanded.top) +\n\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.top)\n\n\t\tconst topOrBottom = viaBottomLength < viaTopLength ? 'bottom' : 'top'\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`)\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, info.B.expanded[topOrBottom])\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.expanded, info.B.expanded[topOrBottom])\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (aEdge.expanded !== null && info.gapX <= 0) {\n\t\tconst viaBottomLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom)\n\t\tconst viaTopLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.A.expanded.top) +\n\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.top)\n\n\t\tconst topOrBottom = viaBottomLength < viaTopLength ? 'bottom' : 'top'\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`)\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded[topOrBottom])\n\t\t\t.add(info.midX, info.A.expanded[topOrBottom])\n\t\t\t.add(info.midX, bEdge.crossTarget)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\nconst routes = {\n\ttop: {\n\t\ttop: [ElbowArrowTransform.Rotate270, routeRightToRight],\n\t\tleft: [ElbowArrowTransform.Rotate270, routeRightToTop],\n\t\tbottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],\n\t\tright: [ElbowArrowTransform.Rotate270, routeRightToBottom],\n\t},\n\tright: {\n\t\ttop: [ElbowArrowTransform.Identity, routeRightToTop],\n\t\tright: [ElbowArrowTransform.Identity, routeRightToRight],\n\t\tbottom: [ElbowArrowTransform.Identity, routeRightToBottom],\n\t\tleft: [ElbowArrowTransform.Identity, routeRightToLeft],\n\t},\n\tbottom: {\n\t\ttop: [ElbowArrowTransform.Rotate90, routeRightToLeft],\n\t\tleft: [ElbowArrowTransform.Rotate90, routeRightToBottom],\n\t\tbottom: [ElbowArrowTransform.Rotate90, routeRightToRight],\n\t\tright: [ElbowArrowTransform.Rotate90, routeRightToTop],\n\t},\n\tleft: {\n\t\ttop: [ElbowArrowTransform.Rotate180, routeRightToBottom],\n\t\tleft: [ElbowArrowTransform.Rotate180, routeRightToRight],\n\t\tbottom: [ElbowArrowTransform.Rotate180, routeRightToTop],\n\t\tright: [ElbowArrowTransform.Rotate180, routeRightToLeft],\n\t},\n} satisfies Record<\n\tElbowArrowSide,\n\tRecord<\n\t\tElbowArrowSide,\n\t\t[ElbowArrowTransform, (info: ElbowArrowWorkingInfo) => ElbowArrowRoute | null]\n\t>\n>\n\nexport function tryRouteArrow(\n\tinfo: ElbowArrowWorkingInfo,\n\taEdge: ElbowArrowSide,\n\tbEdge: ElbowArrowSide\n): ElbowArrowRoute | null {\n\tconst [transform, routeFn] = routes[aEdge][bEdge]\n\tinfo.apply(transform)\n\tconst route = routeFn(info)\n\tinfo.reset()\n\treturn route\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1096, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/routeArrowWithAutoEdgePicking.tsx"],"sourcesContent":["import { exhaustiveSwitchError } from '@tldraw/editor'\nimport {\n\tElbowArrowRoute,\n\tElbowArrowSide,\n\tElbowArrowSideOpposites,\n\tElbowArrowSideReason,\n\tElbowArrowSides,\n} from '../definitions'\nimport { ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\nimport { tryRouteArrow } from './elbowArrowRoutes'\n\nexport function routeArrowWithAutoEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\treason: ElbowArrowSideReason\n): ElbowArrowRoute | null {\n\tlet idealRoute = null\n\tif (\n\t\t// +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket\n\t\t// to 45 deg (as gapx/gapy are almost equal and the result depends on floating point\n\t\t// precision)\n\t\tMath.abs(info.gapX) + 1 > Math.abs(info.gapY) &&\n\t\tinfo.midX !== null\n\t) {\n\t\tif (info.gapX > 0) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'left')\n\t\t} else {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'right')\n\t\t}\n\t} else {\n\t\tconst aRight = info.A.edges.right\n\t\tconst aLeft = info.A.edges.left\n\t\tconst bTop = info.B.edges.top\n\t\tconst bBottom = info.B.edges.bottom\n\n\t\tif (info.A.isPoint && info.B.isPoint) {\n\t\t\tif (info.gapY > 0) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'bottom', 'top')\n\t\t\t} else {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'top', 'bottom')\n\t\t\t}\n\t\t} else if (\n\t\t\taRight &&\n\t\t\tbTop &&\n\t\t\t(aRight.expanded ?? aRight.value) <= bTop.crossTarget &&\n\t\t\taRight.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'top')\n\t\t} else if (\n\t\t\taRight &&\n\t\t\tbBottom &&\n\t\t\t(aRight.expanded ?? aRight.value) <= bBottom.crossTarget &&\n\t\t\taRight.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'bottom')\n\t\t} else if (\n\t\t\taLeft &&\n\t\t\tbTop &&\n\t\t\t(aLeft.expanded ?? aLeft.value) >= bTop.crossTarget &&\n\t\t\taLeft.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'top')\n\t\t} else if (\n\t\t\taLeft &&\n\t\t\tbBottom &&\n\t\t\t(aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget &&\n\t\t\taLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'bottom')\n\t\t} else if (info.gapY > 0 && info.midY !== null) {\n\t\t\tidealRoute = tryRouteArrow(info, 'bottom', 'top')\n\t\t} else if (info.gapY < 0 && info.midY !== null) {\n\t\t\tidealRoute = tryRouteArrow(info, 'top', 'bottom')\n\t\t}\n\t}\n\n\tif (idealRoute) {\n\t\tidealRoute.aEdgePicking = reason\n\t\tidealRoute.bEdgePicking = reason\n\t\treturn idealRoute\n\t}\n\n\tconst aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side])\n\tconst bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side])\n\n\tconst nonPartialRouteCandidates = aAvailableSide.flatMap((aSide) =>\n\t\tbAvailableSides.map((bSide) => [aSide, bSide, reason, reason] as const)\n\t)\n\n\treturn pickBest(info, nonPartialRouteCandidates)\n}\n\nexport function routeArrowWithPartialEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\taSide: ElbowArrowSide\n) {\n\tlet idealRoute = null\n\n\tconst aRight = info.A.edges.right\n\tconst aLeft = info.A.edges.left\n\tconst bTop = info.B.edges.top\n\tconst bBottom = info.B.edges.bottom\n\n\tswitch (aSide) {\n\t\tcase 'right':\n\t\t\tif (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'left')\n\t\t\t} else if (\n\t\t\t\taRight &&\n\t\t\t\tbTop &&\n\t\t\t\t(aRight.expanded ?? aRight.value) <= bTop.crossTarget &&\n\t\t\t\taRight.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'top')\n\t\t\t} else if (\n\t\t\t\taRight &&\n\t\t\t\tbBottom &&\n\t\t\t\t(aRight.expanded ?? aRight.value) <= bBottom.crossTarget &&\n\t\t\t\taRight.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'bottom')\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'left':\n\t\t\tif (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'right')\n\t\t\t} else if (\n\t\t\t\taLeft &&\n\t\t\t\tbTop &&\n\t\t\t\t(aLeft.expanded ?? aLeft.value) >= bTop.crossTarget &&\n\t\t\t\taLeft.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'top')\n\t\t\t} else if (\n\t\t\t\taLeft &&\n\t\t\t\tbBottom &&\n\t\t\t\t(aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget &&\n\t\t\t\taLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'bottom')\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'top':\n\t\tcase 'bottom':\n\t\t\t// top and bottom are handled by the pickShortest approach below - it automatically\n\t\t\t// picks the path we would pick with heuristics anyway.\n\t\t\tbreak\n\t\tdefault:\n\t\t\texhaustiveSwitchError(aSide)\n\t}\n\n\tif (idealRoute) {\n\t\tidealRoute.aEdgePicking = 'manual'\n\t\tidealRoute.bEdgePicking = 'auto'\n\t\treturn idealRoute\n\t}\n\n\tswitch (aSide) {\n\t\tcase 'top':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['top', 'bottom', 'manual', 'auto'],\n\t\t\t\t['top', 'right', 'manual', 'auto'],\n\t\t\t\t['top', 'left', 'manual', 'auto'],\n\t\t\t\t['top', 'top', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'bottom':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['bottom', 'top', 'manual', 'auto'],\n\t\t\t\t['bottom', 'right', 'manual', 'auto'],\n\t\t\t\t['bottom', 'left', 'manual', 'auto'],\n\t\t\t\t['bottom', 'bottom', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'left':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['left', 'right', 'manual', 'auto'],\n\t\t\t\t['left', 'bottom', 'manual', 'auto'],\n\t\t\t\t['left', 'left', 'manual', 'auto'],\n\t\t\t\t['left', 'top', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'right':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['right', 'left', 'manual', 'auto'],\n\t\t\t\t['right', 'bottom', 'manual', 'auto'],\n\t\t\t\t['right', 'right', 'manual', 'auto'],\n\t\t\t\t['right', 'top', 'manual', 'auto'],\n\t\t\t])\n\t}\n}\n\nexport function routeArrowWithManualEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\taSide: ElbowArrowSide,\n\tbSide: ElbowArrowSide\n) {\n\tconst route = tryRouteArrow(info, aSide, bSide)\n\tif (route) return route\n\n\tif (info.A.isPoint && info.B.isPoint) {\n\t\treturn pickBest(info, [\n\t\t\t[ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], 'manual', 'manual'],\n\t\t\t[aSide, ElbowArrowSideOpposites[bSide], 'manual', 'auto'],\n\t\t\t[ElbowArrowSideOpposites[aSide], bSide, 'auto', 'manual'],\n\t\t])\n\t} else if (info.A.isPoint) {\n\t\treturn tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide)\n\t} else if (info.B.isPoint) {\n\t\treturn tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide])\n\t}\n\n\treturn null\n}\nfunction pickBest(\n\tinfo: ElbowArrowWorkingInfo,\n\tedges: ReadonlyArray<\n\t\treadonly [ElbowArrowSide, ElbowArrowSide, ElbowArrowSideReason, ElbowArrowSideReason]\n\t>\n) {\n\tlet bestRoute: ElbowArrowRoute | null = null\n\tlet bestCornerCount = Infinity\n\tlet bestDistance = Infinity\n\tlet distanceBias = 0\n\tfor (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {\n\t\tdistanceBias += 1\n\t\tconst route = tryRouteArrow(info, aSide, bSide)\n\t\tif (route) {\n\t\t\troute.aEdgePicking = aEdgePicking\n\t\t\troute.bEdgePicking = bEdgePicking\n\t\t\tif (route.points.length < bestCornerCount) {\n\t\t\t\tbestCornerCount = route.points.length\n\t\t\t\tbestDistance = route.distance\n\t\t\t\tbestRoute = route\n\t\t\t} else if (\n\t\t\t\troute.points.length === bestCornerCount &&\n\t\t\t\troute.distance + distanceBias < bestDistance\n\t\t\t) {\n\t\t\t\tbestDistance = route.distance\n\t\t\t\tbestRoute = route\n\t\t\t}\n\t\t}\n\t}\n\treturn bestRoute\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1369, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/getElbowArrowInfo.tsx"],"sourcesContent":["import {\n\tapproximately,\n\tassert,\n\tBox,\n\tEditor,\n\texhaustiveSwitchError,\n\tGeometry2dFilters,\n\tlerp,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tVecModel,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { BOUND_ARROW_OFFSET, STROKE_SIZES, TLArrowBindings } from '../shared'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowBox,\n\tElbowArrowBoxEdges,\n\tElbowArrowEdge,\n\tElbowArrowInfo,\n\tElbowArrowInfoWithoutRoute,\n\tElbowArrowOptions,\n\tElbowArrowRoute,\n\tElbowArrowSide,\n\tElbowArrowSideWithAxis,\n\tElbowArrowTargetBox,\n\tElbowArrowTerminal,\n} from './definitions'\nimport { createRange, expandRange, isWithinRange, rangeSize, subtractRange } from './range'\nimport { ElbowArrowWorkingInfo } from './routes/ElbowArrowWorkingInfo'\nimport {\n\trouteArrowWithAutoEdgePicking,\n\trouteArrowWithManualEdgePicking,\n\trouteArrowWithPartialEdgePicking,\n} from './routes/routeArrowWithAutoEdgePicking'\n\nexport function getElbowArrowInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbindings: TLArrowBindings\n): ElbowArrowInfo {\n\tconst shapeOptions = editor.getShapeUtil<ArrowShapeUtil>(arrow.type).options\n\tconst options: ElbowArrowOptions = {\n\t\telbowMidpoint: arrow.props.elbowMidPoint,\n\t\texpandElbowLegLength: shapeOptions.expandElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t\tminElbowLegLength: shapeOptions.minElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t}\n\n\t// Before we can do anything else, we need to find the start and end terminals of the arrow.\n\t// These contain the binding info, geometry, bounds, etc.\n\tlet startTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.start, arrow.props.start)\n\tlet endTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.end, arrow.props.end)\n\t// unclosed paths are weird - we handle them outside of the initial terminal info.\n\tstartTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options)\n\tendTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options)\n\n\t// Ther terminal might include a \"side\" if the user has explicitly indicated what side the arrow\n\t// should come from. There are two terminals, and two cases for each terminal (explicit side or\n\t// not), for a total for 4 cases to handle. In order to keep things a bit simpler though, we\n\t// only handle 3 cases: if start no side and end has a side, we flip them around. From here on\n\t// out, we use A and B to refer to the terminals as they may be swapped.\n\tconst swapOrder = !!(!startTerminal.side && endTerminal.side)\n\n\tlet { aTerminal, bTerminal } = swapOrder\n\t\t? { aTerminal: endTerminal, bTerminal: startTerminal }\n\t\t: { aTerminal: startTerminal, bTerminal: endTerminal }\n\n\t// We model each edge that an arrow might enter/exit from separately. If an edge is blocked,\n\t// `getUsableEdge` might return null.\n\tlet edgesA = {\n\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t}\n\n\tlet edgesB = {\n\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t}\n\n\t// We we don't have a usable edge because it's blocked, we can convert some of the terminals to\n\t// points. Point terminals have less strict edge routing rules, but don't look as good\n\t// generally. For example, the arrow might go through the shape instead of around.\n\tconst aIsUsable = hasUsableEdge(edgesA, aTerminal.side)\n\tconst bIsUsable = hasUsableEdge(edgesB, bTerminal.side)\n\tlet needsNewEdges = false\n\tif (!aIsUsable || !bIsUsable) {\n\t\tneedsNewEdges = true\n\t\tif (!aIsUsable) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (!bIsUsable) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\n\t\tif (bTerminal.bounds.containsPoint(aTerminal.target, options.expandElbowLegLength)) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (aTerminal.bounds.containsPoint(bTerminal.target, options.expandElbowLegLength)) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\t}\n\n\tif (needsNewEdges) {\n\t\tedgesA = {\n\t\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t\t}\n\n\t\tedgesB = {\n\t\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t\t}\n\t}\n\n\t// We expand the bounds of the terminals so we can route arrows around them without the arrows\n\t// being too close to the shapes.\n\tconst expandedA = aTerminal.isPoint\n\t\t? aTerminal.bounds\n\t\t: aTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\tconst expandedB = bTerminal.isPoint\n\t\t? bTerminal.bounds\n\t\t: bTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\n\tconst common: ElbowArrowBox = {\n\t\toriginal: Box.Common([aTerminal.bounds, bTerminal.bounds]),\n\t\texpanded: Box.Common([expandedA, expandedB]),\n\t}\n\n\t// Calculate the gaps between the two terminals. If gap is positive, B is to the right of A. If\n\t// it's negative, the opposite is true. If it's 0, there's no gap between the shapes in that\n\t// dimension.\n\tlet gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX\n\tif (gapX < 0) {\n\t\tgapX = aTerminal.bounds.minX - bTerminal.bounds.maxX\n\t\tif (gapX < 0) {\n\t\t\tgapX = 0\n\t\t}\n\t\tgapX = -gapX\n\t}\n\tlet gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY\n\tif (gapY < 0) {\n\t\tgapY = aTerminal.bounds.minY - bTerminal.bounds.maxY\n\t\tif (gapY < 0) {\n\t\t\tgapY = 0\n\t\t}\n\t\tgapY = -gapY\n\t}\n\n\t// The midpoint of the gap is a useful point to route arrows through, but the user can also drag\n\t// it to choose a new midpoint. First, we calculate some constraints we'll need to keep in mind\n\t// when figuring out the midpoint...\n\tconst aMinLength = aTerminal.minEndSegmentLength * 3\n\tconst bMinLength = bTerminal.minEndSegmentLength * 3\n\tconst minLegDistanceNeeded =\n\t\t(aTerminal.isPoint ? aMinLength : options.minElbowLegLength) +\n\t\t(bTerminal.isPoint ? bMinLength : options.minElbowLegLength)\n\n\t// ...then, the possible range of the midpoint. This is also used when dragging the midpoint.\n\tlet mxRange: null | { a: number; b: number } = null\n\tif (gapX > minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX,\n\t\t}\n\t} else if (gapX < -minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX,\n\t\t}\n\t}\n\n\tlet myRange: null | { a: number; b: number } = null\n\tif (gapY > minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY,\n\t\t}\n\t} else if (gapY < -minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY,\n\t\t}\n\t}\n\n\t// and finally we take the range and the midpoint prop and calculate the actual position of the\n\t// midpoint. Note that the midpoint and midpoint range can be null if the gap is too small for a\n\t// midpoint line.\n\tconst midpoint = swapOrder ? 1 - options.elbowMidpoint : options.elbowMidpoint\n\tconst mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null\n\tconst my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null\n\n\t// The info without route is given to the route-finding functions to route between the two\n\t// terminals.\n\tconst info: ElbowArrowInfoWithoutRoute = {\n\t\toptions,\n\t\tswapOrder,\n\t\tA: {\n\t\t\tisPoint: aTerminal.isPoint,\n\t\t\ttarget: aTerminal.target,\n\t\t\tisExact: aTerminal.isExact,\n\t\t\tarrowheadOffset: aTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: aTerminal.minEndSegmentLength,\n\t\t\toriginal: aTerminal.bounds,\n\t\t\texpanded: expandedA,\n\t\t\tedges: edgesA,\n\t\t\tgeometry: aTerminal.geometry,\n\t\t},\n\t\tB: {\n\t\t\tisPoint: bTerminal.isPoint,\n\t\t\ttarget: bTerminal.target,\n\t\t\tisExact: bTerminal.isExact,\n\t\t\tarrowheadOffset: bTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: bTerminal.minEndSegmentLength,\n\t\t\toriginal: bTerminal.bounds,\n\t\t\texpanded: expandedB,\n\t\t\tedges: edgesB,\n\t\t\tgeometry: bTerminal.geometry,\n\t\t},\n\t\tcommon,\n\t\tgapX,\n\t\tgapY,\n\t\tmidX: mx,\n\t\tmidY: my,\n\t}\n\n\t// We wrap the info in a working info object that lets us mutate and reset it as needed.\n\tconst workingInfo = new ElbowArrowWorkingInfo(info)\n\n\t// Figure out the final sides to use for each terminal.\n\tconst aSide = getSideToUse(aTerminal, bTerminal, info.A.edges)\n\tconst bSide = getSideToUse(bTerminal, aTerminal, info.B.edges)\n\n\t// try to find a route with the specification we have:\n\tlet route\n\tif (aSide && bSide) {\n\t\troute = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide)\n\t} else if (aSide && !bSide) {\n\t\troute = routeArrowWithPartialEdgePicking(workingInfo, aSide)\n\t}\n\tif (!route) {\n\t\troute = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? 'fallback' : 'auto')\n\t}\n\n\tif (route) {\n\t\t// If we found a route, we need to fix it up. The route will only go to the bounding box of\n\t\t// the shape, so we need to cast the final segments into the actual geometry of the shape.\n\t\tcastPathSegmentIntoGeometry('first', info.A, info.B, route)\n\t\tcastPathSegmentIntoGeometry('last', info.B, info.A, route)\n\t\t// If we have tiny L-shaped arrows, the arrowheads look super janky. We fix those up by just\n\t\t// drawing a straight line instead.\n\t\tfixTinyEndNubs(route, aTerminal, bTerminal)\n\n\t\t// If we swapped the order way back of the start of things, we need to reverse the route so\n\t\t// it flows start -> end instead of A -> B.\n\t\tif (swapOrder) route.points.reverse()\n\t}\n\n\treturn {\n\t\t...info,\n\t\troute,\n\t\tmidXRange: mxRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: mxRange.b, hi: mxRange.a }\n\t\t\t\t: { lo: mxRange.a, hi: mxRange.b }\n\t\t\t: null,\n\t\tmidYRange: myRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: myRange.b, hi: myRange.a }\n\t\t\t\t: { lo: myRange.a, hi: myRange.b }\n\t\t\t: null,\n\t}\n}\n\n/**\n * Take the route from `getElbowArrowInfo` (which represents the visible body of the arrow) and\n * convert it into a path we can use to show that paths to the handles, which may extend further\n * into the target shape geometries.\n * @returns\n */\nexport function getRouteHandlePath(info: ElbowArrowInfo, route: ElbowArrowRoute): ElbowArrowRoute {\n\tconst startTarget = info.swapOrder ? info.B.target : info.A.target\n\tconst endTarget = info.swapOrder ? info.A.target : info.B.target\n\n\tconst firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1])\n\tconst lastSegmentLength = Vec.ManhattanDist(\n\t\troute.points[route.points.length - 2],\n\t\troute.points[route.points.length - 1]\n\t)\n\n\tconst newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1])\n\tconst newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget)\n\n\tconst firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength\n\tconst lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength\n\n\tconst newPoints = [startTarget, ...route.points, endTarget]\n\n\treturn {\n\t\tname: route.name,\n\t\tdistance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,\n\t\tpoints: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),\n\t\taEdgePicking: route.aEdgePicking,\n\t\tbEdgePicking: route.bEdgePicking,\n\t\tskipPointsWhenDrawing: route.skipPointsWhenDrawing,\n\t\tmidpointHandle: route.midpointHandle,\n\t}\n}\n\n/**\n * Take a normalizes anchor and return the side we think it's closest to.\n */\nexport function getEdgeFromNormalizedAnchor(normalizedAnchor: VecLike) {\n\tif (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {\n\t\treturn null\n\t}\n\n\tif (\n\t\tMath.abs(normalizedAnchor.x - 0.5) >\n\t\t// slightly bias towards x arrows to prevent flickering when the anchor is right on the line\n\t\t// between the two directions\n\t\tMath.abs(normalizedAnchor.y - 0.5) - 0.0001\n\t) {\n\t\treturn normalizedAnchor.x < 0.5 ? 'left' : 'right'\n\t}\n\n\treturn normalizedAnchor.y < 0.5 ? 'top' : 'bottom'\n}\n\nfunction getElbowArrowTerminalInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbinding: TLArrowBinding | undefined,\n\tpoint: VecModel\n): ElbowArrowTerminal {\n\tconst arrowStrokeSize = (STROKE_SIZES[arrow.props.size] * arrow.props.scale) / 2\n\tconst minEndSegmentLength = arrowStrokeSize * 3\n\n\tif (binding) {\n\t\tconst target = editor.getShape(binding.toId)\n\t\tconst geometry = getBindingGeometryInArrowSpace(editor, arrow, binding.toId, binding.props)\n\t\tif (geometry && target) {\n\t\t\tlet arrowheadOffset = 0\n\t\t\tconst arrowheadProp = binding.props.terminal === 'start' ? 'arrowheadStart' : 'arrowheadEnd'\n\t\t\tif (arrow.props[arrowheadProp] !== 'none') {\n\t\t\t\tconst targetScale = 'scale' in target.props ? target.props.scale : 1\n\t\t\t\tconst targetStrokeSize =\n\t\t\t\t\t'size' in target.props ? ((STROKE_SIZES[target.props.size] ?? 0) * targetScale) / 2 : 0\n\n\t\t\t\tarrowheadOffset =\n\t\t\t\t\tarrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow.props.scale\n\t\t\t}\n\n\t\t\tlet side: ElbowArrowSideWithAxis | null = null\n\t\t\tconst targetPoint = geometry.target\n\t\t\tif (binding.props.isPrecise) {\n\t\t\t\tside = getEdgeFromNormalizedAnchor(\n\t\t\t\t\tVec.RotWith(\n\t\t\t\t\t\tbinding.props.normalizedAnchor,\n\t\t\t\t\t\t{ x: 0.5, y: 0.5 },\n\t\t\t\t\t\tgeometry.shapeToArrowTransform.rotation()\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttargetShapeId: binding.toId,\n\t\t\t\tisPoint: false,\n\t\t\t\tisExact: binding.props.isExact,\n\t\t\t\tbounds: geometry.bounds,\n\t\t\t\tgeometry: geometry.geometry,\n\t\t\t\ttarget: targetPoint,\n\t\t\t\tarrowheadOffset,\n\t\t\t\tminEndSegmentLength,\n\t\t\t\tside,\n\t\t\t\tsnap: binding.props.snap,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: null,\n\t\tbounds: Box.FromCenter(point, { x: 0, y: 0 }),\n\t\tgeometry: null,\n\t\tisExact: false,\n\t\tisPoint: true,\n\t\ttarget: Vec.From(point),\n\t\tarrowheadOffset: 0,\n\t\tminEndSegmentLength,\n\t\tside: null,\n\t\tsnap: 'none',\n\t}\n}\n\nfunction getBindingGeometryInArrowSpace(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\ttargetId: TLShapeId,\n\tbindingProps: TLArrowBindingProps\n) {\n\tconst hasArrowhead =\n\t\tbindingProps.terminal === 'start'\n\t\t\t? arrow.props.arrowheadStart !== 'none'\n\t\t\t: arrow.props.arrowheadEnd !== 'none'\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(\n\t\ttargetId,\n\t\thasArrowhead ? undefined : { context: '@tldraw/arrow-without-arrowhead' }\n\t)\n\n\tif (!targetGeometryInTargetSpace) {\n\t\treturn null\n\t}\n\n\tconst arrowTransform = editor.getShapePageTransform(arrow.id)\n\tconst shapeTransform = editor.getShapePageTransform(targetId)\n\tconst shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform)\n\n\tconst targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform)\n\n\tconst center = { x: 0.5, y: 0.5 }\n\tconst normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center\n\n\tconst targetInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tnormalizedAnchor.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tnormalizedAnchor.y\n\t\t),\n\t}\n\tconst centerInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tcenter.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tcenter.y\n\t\t),\n\t}\n\n\tconst targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace)\n\tconst centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace)\n\n\treturn {\n\t\tbounds: targetGeometryInArrowSpace.bounds,\n\t\tgeometry: targetGeometryInArrowSpace,\n\t\ttarget: targetInArrowSpace,\n\t\tcenter: centerInArrowSpace,\n\t\tshapeToArrowTransform,\n\t}\n}\n\nconst sideProps = {\n\ttop: {\n\t\texpand: -1,\n\t\tmain: 'minY',\n\t\topposite: 'maxY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'x',\n\t},\n\tbottom: {\n\t\texpand: 1,\n\t\tmain: 'maxY',\n\t\topposite: 'minY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'x',\n\t},\n\tleft: {\n\t\texpand: -1,\n\t\tmain: 'minX',\n\t\topposite: 'maxX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'y',\n\t},\n\tright: {\n\t\texpand: 1,\n\t\tmain: 'maxX',\n\t\topposite: 'minX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'y',\n\t},\n} as const\n\nexport function getUsableEdge(\n\ta: ElbowArrowTerminal,\n\tb: ElbowArrowTerminal,\n\tside: 'top' | 'right' | 'bottom' | 'left',\n\toptions: ElbowArrowOptions\n): ElbowArrowEdge | null {\n\tconst props = sideProps[side]\n\n\t// if a shape is bound to itself, by default we'd end up routing the arrow _within_ the shape -\n\t// as if it were a point-to-point arrow. if one of the bindings is specifically to the edge\n\t// though, we route it externally instead.\n\tconst isSelfBoundAndShouldRouteExternal =\n\t\ta.targetShapeId === b.targetShapeId &&\n\t\ta.targetShapeId !== null &&\n\t\t(a.snap === 'edge' || a.snap === 'edge-point') &&\n\t\t(b.snap === 'edge' || b.snap === 'edge-point')\n\n\tconst aValue = a.bounds[props.main]\n\tconst aExpanded = a.isPoint ? null : aValue + props.expand * options.expandElbowLegLength\n\n\tconst originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax])\n\tlet aCrossRange = originalACrossRange\n\n\t// this edge is too small to be useful:\n\tif (!aCrossRange) {\n\t\treturn null\n\t}\n\n\tassert(originalACrossRange)\n\tconst bRange = createRange(b.bounds[props.main], b.bounds[props.opposite])\n\tif (!b.isPoint) {\n\t\tbRange[props.bRangeExpand] -= options.minElbowLegLength * 2 * props.expand\n\t}\n\n\tconst bCrossRange = expandRange(\n\t\tcreateRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),\n\t\toptions.expandElbowLegLength\n\t)\n\tassert(bRange && bCrossRange)\n\n\tlet isPartial = false\n\tif (\n\t\tisWithinRange(aValue, bRange) &&\n\t\t!a.isPoint &&\n\t\t!b.isPoint &&\n\t\t!isSelfBoundAndShouldRouteExternal\n\t) {\n\t\tconst subtracted = subtractRange(aCrossRange, bCrossRange)\n\t\tswitch (subtracted.length) {\n\t\t\tcase 0:\n\t\t\t\treturn null\n\t\t\tcase 1:\n\t\t\t\tisPartial = subtracted[0] !== aCrossRange\n\t\t\t\taCrossRange = subtracted[0]\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\tisPartial = true\n\t\t\t\taCrossRange =\n\t\t\t\t\trangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(subtracted)\n\t\t}\n\t}\n\n\tif (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {\n\t\treturn null\n\t}\n\tconst crossTarget = a.target[props.crossAxis]\n\n\treturn {\n\t\tvalue: aValue,\n\t\texpanded: aExpanded,\n\t\tcross: aCrossRange,\n\t\tcrossTarget,\n\t\tisPartial,\n\t}\n}\n\nfunction hasUsableEdge(edges: ElbowArrowBoxEdges, side: ElbowArrowSideWithAxis | null) {\n\tif (side === null) {\n\t\treturn !!(edges.bottom || edges.left || edges.right || edges.top)\n\t}\n\n\tif (side === 'x') {\n\t\treturn !!edges.left || !!edges.right\n\t}\n\n\tif (side === 'y') {\n\t\treturn !!edges.top || !!edges.bottom\n\t}\n\n\treturn !!edges[side]\n}\n\nfunction getSideToUse(\n\tbinding: ElbowArrowTerminal,\n\tother: ElbowArrowTerminal,\n\tedges: ElbowArrowBoxEdges | null\n): ElbowArrowSide | null {\n\tswitch (binding.side) {\n\t\tcase null:\n\t\t\treturn null\n\t\tcase 'x':\n\t\t\tif (binding.bounds.center.x > other.bounds.center.x && edges?.left) {\n\t\t\t\treturn 'left'\n\t\t\t} else if (edges?.right) {\n\t\t\t\treturn 'right'\n\t\t\t}\n\t\t\treturn null\n\t\tcase 'y':\n\t\t\tif (binding.bounds.center.y > other.bounds.center.y && edges?.top) {\n\t\t\t\treturn 'top'\n\t\t\t} else if (edges?.bottom) {\n\t\t\t\treturn 'bottom'\n\t\t\t}\n\t\t\treturn null\n\t\tdefault:\n\t\t\treturn binding.side\n\t}\n}\n\nfunction convertTerminalToPoint(terminal: ElbowArrowTerminal): ElbowArrowTerminal {\n\tif (terminal.isPoint) return terminal\n\n\tlet side: ElbowArrowSideWithAxis | null = null\n\tlet arrowheadOffset = 0\n\tif (terminal.snap === 'edge' || terminal.snap === 'edge-point') {\n\t\tarrowheadOffset = terminal.arrowheadOffset\n\t\tif (terminal.side === 'x' || terminal.side === 'left' || terminal.side === 'right') {\n\t\t\tside = 'x'\n\t\t}\n\t\tif (terminal.side === 'y' || terminal.side === 'top' || terminal.side === 'bottom') {\n\t\t\tside = 'y'\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: terminal.targetShapeId,\n\t\tside,\n\t\tbounds: new Box(terminal.target.x, terminal.target.y, 0, 0),\n\t\tgeometry: terminal.geometry,\n\t\ttarget: terminal.target,\n\t\tarrowheadOffset,\n\t\tminEndSegmentLength: terminal.minEndSegmentLength,\n\t\tisExact: terminal.isExact,\n\t\tisPoint: true,\n\t\tsnap: terminal.snap,\n\t}\n}\n\n/**\n * Make sure the first path segments goes fully into the target, and doesn't just point to its\n * bounding box. This modifies the route in-place.\n */\nfunction castPathSegmentIntoGeometry(\n\tsegment: 'first' | 'last',\n\ttarget: ElbowArrowTargetBox,\n\tother: ElbowArrowTargetBox,\n\troute: ElbowArrowRoute\n) {\n\tif (!target.geometry) return\n\n\tconst point1 = segment === 'first' ? route.points[0] : route.points[route.points.length - 1]\n\tconst point2 = segment === 'first' ? route.points[1] : route.points[route.points.length - 2]\n\n\tconst pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target\n\n\tconst initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo)\n\n\tlet nearestIntersectionToPoint2: VecLike | null = null\n\tlet nearestDistanceToPoint2 = Infinity\n\n\tif (target.isExact) {\n\t\tnearestIntersectionToPoint2 = target.target\n\t} else if (target.geometry) {\n\t\tconst intersections = target.geometry.intersectLineSegment(point2, target.target, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\t\tif (\n\t\t\ttarget.geometry.hitTestPoint(\n\t\t\t\ttarget.target,\n\t\t\t\tMath.max(1, target.arrowheadOffset),\n\t\t\t\ttrue,\n\t\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t\t)\n\t\t) {\n\t\t\tintersections.push(target.target)\n\t\t}\n\t\tfor (const intersection of intersections) {\n\t\t\tconst point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection)\n\t\t\tif (point2Distance < nearestDistanceToPoint2) {\n\t\t\t\tnearestDistanceToPoint2 = point2Distance\n\t\t\t\tnearestIntersectionToPoint2 = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nearestIntersectionToPoint2) {\n\t\tlet offset = target.arrowheadOffset\n\n\t\tconst currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2)\n\t\tconst minLength = target.arrowheadOffset * 2\n\t\tif (currentFinalSegmentLength < minLength) {\n\t\t\tconst targetLength = minLength - target.arrowheadOffset\n\t\t\toffset = currentFinalSegmentLength - targetLength\n\t\t}\n\t\tif (offset < target.minEndSegmentLength) {\n\t\t\tif (target.geometry.bounds.containsPoint(other.target)) {\n\t\t\t\toffset = Math.max(0, offset)\n\t\t\t} else {\n\t\t\t\toffset = -target.arrowheadOffset\n\t\t\t}\n\t\t}\n\n\t\tlet nudgedPoint = nearestIntersectionToPoint2\n\t\tlet shouldAddExtraPointForNudge = false\n\t\tif (!target.isExact && offset !== 0) {\n\t\t\tconst nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset)\n\t\t\tnudgedPoint = nudged\n\t\t\tif (\n\t\t\t\toffset < 0 &&\n\t\t\t\t!target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)\n\t\t\t) {\n\t\t\t\t// point has been nudged _out_ of the shape so lets not actually apply the nudge\n\t\t\t\tnudgedPoint = nearestIntersectionToPoint2\n\t\t\t} else {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tshouldAddExtraPointForNudge = true\n\t\t\t\t}\n\t\t\t\tnudgedPoint = nudged\n\t\t\t}\n\t\t}\n\n\t\tconst newDistance = Vec.ManhattanDist(point2, nudgedPoint)\n\t\troute.distance += newDistance - initialDistance\n\t\tpoint1.x = nudgedPoint.x\n\t\tpoint1.y = nudgedPoint.y\n\n\t\tif (shouldAddExtraPointForNudge) {\n\t\t\tconst midPoint = Vec.Lrp(point2, point1, 0.5)\n\t\t\troute.skipPointsWhenDrawing.add(midPoint)\n\t\t\troute.points.splice(segment === 'first' ? 1 : route.points.length - 1, 0, midPoint)\n\t\t}\n\t}\n}\n\nfunction fixTinyEndNubs(\n\troute: ElbowArrowRoute,\n\taTerminal: ElbowArrowTerminal,\n\tbTerminal: ElbowArrowTerminal\n) {\n\tif (!route) return\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[0]\n\t\tconst b = route.points[1]\n\t\tconst firstSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (firstSegmentLength < aTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(1, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[1][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[route.points.length - 1]\n\t\tconst b = route.points[route.points.length - 2]\n\t\tconst lastSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (lastSegmentLength < bTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(route.points.length - 2, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[route.points.length - 2][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction adjustTerminalForUnclosedPathIfNeeded(\n\tterminal: ElbowArrowTerminal,\n\totherTerminal: ElbowArrowTerminal,\n\toptions: ElbowArrowOptions\n): ElbowArrowTerminal {\n\tif (!terminal.geometry || terminal.geometry.isClosed) return terminal\n\tconst normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(\n\t\tterminal.target,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)\n\n\tconst prev = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath - 0.01 / terminal.geometry.length\n\t)\n\tconst next = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath + 0.01 / terminal.geometry.length\n\t)\n\n\tconst normal = next.sub(prev).per().uni()\n\tconst axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y\n\n\tif (terminal.geometry.bounds.containsPoint(otherTerminal.target, options.expandElbowLegLength)) {\n\t\tterminal.side = axis.self\n\t\treturn convertTerminalToPoint(terminal)\n\t}\n\n\tconst min = axis.v(\n\t\tterminal.target[axis.self] - terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\tconst max = axis.v(\n\t\tterminal.target[axis.self] + terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\n\tlet furthestIntersectionTowardsMin: VecLike | null = null\n\tlet furthestIntersectionTowardsMinDistance = 0\n\tlet furthestIntersectionTowardsMax: VecLike | null = null\n\tlet furthestIntersectionTowardsMaxDistance = 0\n\tlet side: ElbowArrowSideWithAxis = axis.self\n\n\tfor (const intersection of terminal.geometry.intersectLineSegment(\n\t\tmin,\n\t\tmax,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)) {\n\t\tif (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {\n\t\t\tcontinue\n\t\t}\n\t\tif (intersection[axis.self] < terminal.target[axis.self]) {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMin = intersection\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMax = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tif (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {\n\t\t\tside = axis.hiEdge\n\t\t} else {\n\t\t\tside = axis.loEdge\n\t\t}\n\t} else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {\n\t\tside = axis.hiEdge\n\t} else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tside = axis.loEdge\n\t}\n\n\tterminal.side = side\n\treturn terminal\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2004, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/shared.ts"],"sourcesContent":["import {\n\tEditor,\n\tGeometry2d,\n\tisEqualAllowingForFloatingPointErrors,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n} from '@tldraw/editor'\nimport { createComputedCache } from '@tldraw/store'\nimport { TLArrowInfo } from './arrow-types'\nimport { getCurvedArrowInfo } from './curved-arrow'\nimport { getElbowArrowInfo } from './elbow/getElbowArrowInfo'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nconst MIN_ARROW_BEND = 8\n\nexport function getIsArrowStraight(shape: TLArrowShape) {\n\tif (shape.props.kind !== 'arc') return false\n\treturn Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale // snap to +-8px\n}\n\nexport interface BoundShapeInfo<T extends TLShape = TLShape> {\n\tshape: T\n\tdidIntersect: boolean\n\tisExact: boolean\n\tisClosed: boolean\n\ttransform: Mat\n\tgeometry: Geometry2d\n}\n\nexport function getBoundShapeInfoForTerminal(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tterminalName: 'start' | 'end'\n): BoundShapeInfo | undefined {\n\tconst binding = editor\n\t\t.getBindingsFromShape(arrow, 'arrow')\n\t\t.find((b) => b.props.terminal === terminalName)\n\tif (!binding) return\n\n\tconst boundShape = editor.getShape(binding.toId)!\n\tif (!boundShape) return\n\tconst transform = editor.getShapePageTransform(boundShape)!\n\tconst hasArrowhead =\n\t\tterminalName === 'start'\n\t\t\t? arrow.props.arrowheadStart !== 'none'\n\t\t\t: arrow.props.arrowheadEnd !== 'none'\n\tconst geometry = editor.getShapeGeometry(\n\t\tboundShape,\n\t\thasArrowhead ? undefined : { context: '@tldraw/arrow-without-arrowhead' }\n\t)\n\n\treturn {\n\t\tshape: boundShape,\n\t\ttransform,\n\t\tisClosed: geometry.isClosed,\n\t\tisExact: binding.props.isExact,\n\t\tdidIntersect: false,\n\t\tgeometry,\n\t}\n}\n\nexport function getArrowTerminalInArrowSpace(\n\teditor: Editor,\n\tarrowPageTransform: Mat,\n\tbinding: TLArrowBinding,\n\tforceImprecise: boolean\n) {\n\tconst boundShape = editor.getShape(binding.toId)\n\n\tif (!boundShape) {\n\t\t// this can happen in multiplayer contexts where the shape is being deleted\n\t\treturn new Vec(0, 0)\n\t} else {\n\t\t// Find the actual local point of the normalized terminal on\n\t\t// the bound shape and transform it to page space, then transform\n\t\t// it to arrow space\n\t\tconst { point, size } = editor.getShapeGeometry(boundShape).bounds\n\t\tconst shapePoint = Vec.Add(\n\t\t\tpoint,\n\t\t\tVec.MulV(\n\t\t\t\t// if the parent is the bound shape, then it's ALWAYS precise\n\t\t\t\tbinding.props.isPrecise || forceImprecise\n\t\t\t\t\t? binding.props.normalizedAnchor\n\t\t\t\t\t: { x: 0.5, y: 0.5 },\n\t\t\t\tsize\n\t\t\t)\n\t\t)\n\t\tconst pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape)!, shapePoint)\n\t\tconst arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint)\n\t\treturn arrowPoint\n\t}\n}\n\n/** @public */\nexport interface TLArrowBindings {\n\tstart: TLArrowBinding | undefined\n\tend: TLArrowBinding | undefined\n}\n\nconst arrowBindingsCache = createComputedCache(\n\t'arrow bindings',\n\t(editor: Editor, arrow: TLArrowShape) => {\n\t\tconst bindings = editor.getBindingsFromShape(arrow.id, 'arrow')\n\t\treturn {\n\t\t\tstart: bindings.find((b) => b.props.terminal === 'start'),\n\t\t\tend: bindings.find((b) => b.props.terminal === 'end'),\n\t\t}\n\t},\n\t{\n\t\t// we only look at the arrow IDs:\n\t\tareRecordsEqual: (a, b) => a.id === b.id,\n\t\t// the records should stay the same:\n\t\tareResultsEqual: (a, b) => a.start === b.start && a.end === b.end,\n\t}\n)\n\n/** @public */\nexport function getArrowBindings(editor: Editor, shape: TLArrowShape): TLArrowBindings {\n\treturn arrowBindingsCache.get(editor, shape.id)!\n}\n\nconst arrowInfoCache = createComputedCache<Editor, TLArrowInfo, TLArrowShape>(\n\t'arrow info',\n\t(editor: Editor, shape: TLArrowShape): TLArrowInfo => {\n\t\tconst bindings = getArrowBindings(editor, shape)\n\t\tif (shape.props.kind === 'elbow') {\n\t\t\tconst elbowInfo = getElbowArrowInfo(editor, shape, bindings)\n\t\t\tif (!elbowInfo?.route) return getStraightArrowInfo(editor, shape, bindings)\n\n\t\t\tconst start = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A\n\t\t\tconst end = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B\n\n\t\t\treturn {\n\t\t\t\ttype: 'elbow',\n\t\t\t\tbindings,\n\t\t\t\tstart: {\n\t\t\t\t\thandle: start.target,\n\t\t\t\t\tpoint: elbowInfo.route.points[0],\n\t\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t\t},\n\t\t\t\tend: {\n\t\t\t\t\thandle: end.target,\n\t\t\t\t\tpoint: elbowInfo.route.points[elbowInfo.route.points.length - 1],\n\t\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t\t},\n\t\t\t\telbow: elbowInfo,\n\t\t\t\troute: elbowInfo.route,\n\t\t\t\tisValid: true,\n\t\t\t}\n\t\t}\n\n\t\tif (getIsArrowStraight(shape)) {\n\t\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t\t} else {\n\t\t\treturn getCurvedArrowInfo(editor, shape, bindings)\n\t\t}\n\t},\n\t{\n\t\tareRecordsEqual: (a, b) => a.props === b.props,\n\t\tareResultsEqual: isEqualAllowingForFloatingPointErrors,\n\t}\n)\n\n/** @public */\nexport function getArrowInfo(editor: Editor, shape: TLArrowShape | TLShapeId) {\n\tconst id = typeof shape === 'string' ? shape : shape.id\n\treturn arrowInfoCache.get(editor, id)\n}\n\n/** @public */\nexport function getArrowTerminalsInArrowSpace(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n) {\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tconst boundShapeRelationships = getBoundShapeRelationships(\n\t\teditor,\n\t\tbindings.start?.toId,\n\t\tbindings.end?.toId\n\t)\n\n\tconst start = bindings.start\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.start,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'start-contains-end'\n\t\t\t)\n\t\t: Vec.From(shape.props.start)\n\n\tconst end = bindings.end\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.end,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'end-contains-start'\n\t\t\t)\n\t\t: Vec.From(shape.props.end)\n\n\treturn { start, end }\n}\n\n/**\n * Create or update the arrow binding for a particular arrow terminal. Will clear up if needed.\n * @internal\n */\nexport function createOrUpdateArrowBinding(\n\teditor: Editor,\n\tarrow: TLArrowShape | TLShapeId,\n\ttarget: TLShape | TLShapeId,\n\tprops: TLArrowBindingProps\n) {\n\tconst arrowId = typeof arrow === 'string' ? arrow : arrow.id\n\tconst targetId = typeof target === 'string' ? target : target.id\n\n\tconst existingMany = editor\n\t\t.getBindingsFromShape(arrowId, 'arrow')\n\t\t.filter((b) => b.props.terminal === props.terminal)\n\n\t// if we've somehow ended up with too many bindings, delete the extras\n\tif (existingMany.length > 1) {\n\t\teditor.deleteBindings(existingMany.slice(1))\n\t}\n\n\tconst existing = existingMany[0]\n\tif (existing) {\n\t\teditor.updateBinding({\n\t\t\t...existing,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t} else {\n\t\teditor.createBinding({\n\t\t\ttype: 'arrow',\n\t\t\tfromId: arrowId,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t}\n}\n\n/**\n * Remove any arrow bindings for a particular terminal.\n * @internal\n */\nexport function removeArrowBinding(editor: Editor, arrow: TLArrowShape, terminal: 'start' | 'end') {\n\tconst existing = editor\n\t\t.getBindingsFromShape(arrow, 'arrow')\n\t\t.filter((b) => b.props.terminal === terminal)\n\n\teditor.deleteBindings(existing)\n}\n\n/** @internal */\nexport const MIN_ARROW_LENGTH = 10\n/** @internal */\nexport const BOUND_ARROW_OFFSET = 10\n/** @internal */\nexport const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10\n\n/** @public */\nexport const STROKE_SIZES: Record<string, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/**\n * Get the relationships for an arrow that has two bound shape terminals.\n * If the arrow has only one bound shape, then it is always \"safe\" to apply\n * standard offsets and precision behavior. If the shape is bound to the same\n * shape on both ends, then that is an exception. If one of the shape's\n * terminals is bound to a shape that contains / is contained by the shape that\n * is bound to the other terminal, then that is also an exception.\n *\n * @param editor - the editor instance\n * @param startShapeId - the bound shape from the arrow's start\n * @param endShapeId - the bound shape from the arrow's end\n *\n *  @internal */\nexport function getBoundShapeRelationships(\n\teditor: Editor,\n\tstartShapeId?: TLShapeId,\n\tendShapeId?: TLShapeId\n) {\n\tif (!startShapeId || !endShapeId) return 'safe'\n\tif (startShapeId === endShapeId) return 'double-bound'\n\tconst startBounds = editor.getShapePageBounds(startShapeId)\n\tconst endBounds = editor.getShapePageBounds(endShapeId)\n\tif (startBounds && endBounds) {\n\t\tif (startBounds.contains(endBounds)) return 'start-contains-end'\n\t\tif (endBounds.contains(startBounds)) return 'end-contains-start'\n\t}\n\treturn 'safe'\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2202, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/arrowTargetState.ts"],"sourcesContent":["import {\n\tArrowShapeKindStyle,\n\tatom,\n\tAtom,\n\tBox,\n\tclamp,\n\tEditor,\n\tElbowArrowSnap,\n\tGeometry2dFilters,\n\tinvLerp,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tTLArrowBinding,\n\tTLArrowShape,\n\tTLArrowShapeKind,\n\tTLShape,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from './ArrowShapeUtil'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowSide,\n\tElbowArrowSideAxes,\n\tElbowArrowSideDeltas,\n} from './elbow/definitions'\n\n/**\n * Options passed to {@link updateArrowTargetState}.\n *\n * @public\n */\nexport interface UpdateArrowTargetStateOpts {\n\teditor: Editor\n\tpointInPageSpace: VecLike\n\tarrow: TLArrowShape | undefined\n\tisPrecise: boolean\n\tcurrentBinding: TLArrowBinding | undefined\n\t/** The binding from the opposite end of the arrow, if one exists. */\n\toppositeBinding: TLArrowBinding | undefined\n}\n\n/**\n * State representing what we're pointing to when drawing or updating an arrow. You can get this\n * state using {@link getArrowTargetState}, and update it as part of an arrow interaction with\n * {@link updateArrowTargetState} or {@link clearArrowTargetState}.\n *\n * @public\n */\nexport interface ArrowTargetState {\n\ttarget: TLShape\n\tarrowKind: TLArrowShapeKind\n\n\thandlesInPageSpace: {\n\t\ttop: { point: VecLike; isEnabled: boolean }\n\t\tbottom: { point: VecLike; isEnabled: boolean }\n\t\tleft: { point: VecLike; isEnabled: boolean }\n\t\tright: { point: VecLike; isEnabled: boolean }\n\t}\n\n\tisExact: boolean\n\tisPrecise: boolean\n\n\tcenterInPageSpace: VecLike\n\tanchorInPageSpace: VecLike\n\tsnap: ElbowArrowSnap\n\tnormalizedAnchor: VecLike\n}\n\nconst arrowTargetStore = new WeakCache<Editor, Atom<ArrowTargetState | null>>()\n\nfunction getArrowTargetAtom(editor: Editor) {\n\treturn arrowTargetStore.get(editor, () => atom('arrowTarget', null))\n}\n\n/**\n * Get the current arrow target state for an editor. See {@link ArrowTargetState} for more\n * information.\n *\n * @public\n */\nexport function getArrowTargetState(editor: Editor) {\n\treturn getArrowTargetAtom(editor).get()\n}\n\n/**\n * Clear the current arrow target state for an editor. See {@link ArrowTargetState} for more\n * information.\n *\n * @public\n */\nexport function clearArrowTargetState(editor: Editor) {\n\tgetArrowTargetAtom(editor).set(null)\n}\n\n/**\n * Update the current arrow target state for an editor. See {@link ArrowTargetState} for more\n * information.\n *\n * @public\n */\nexport function updateArrowTargetState({\n\teditor,\n\tpointInPageSpace,\n\tarrow,\n\tisPrecise,\n\tcurrentBinding,\n\toppositeBinding,\n}: UpdateArrowTargetStateOpts): ArrowTargetState | null {\n\tconst util = editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t// no target picking when ctrl is held:\n\tif (util.options.shouldIgnoreTargets(editor)) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst arrowKind = arrow ? arrow.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle)\n\n\tconst target = editor.getShapeAtPoint(pointInPageSpace, {\n\t\thitInside: true,\n\t\thitFrameInside: true,\n\t\tmargin: arrowKind === 'elbow' ? 8 : [8, 0],\n\t\tfilter: (targetShape) => {\n\t\t\treturn (\n\t\t\t\t!targetShape.isLocked &&\n\t\t\t\teditor.canBindShapes({\n\t\t\t\t\tfromShape: arrow ?? targetFilterFallback,\n\t\t\t\t\ttoShape: targetShape,\n\t\t\t\t\tbinding: 'arrow',\n\t\t\t\t})\n\t\t\t)\n\t\t},\n\t})\n\n\tif (!target) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(target)\n\tconst targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds)\n\tconst targetCenterInTargetSpace = targetGeometryInTargetSpace.center\n\tconst targetTransform = editor.getShapePageTransform(target)\n\tconst pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace)\n\n\tconst castDistance = Math.max(\n\t\ttargetGeometryInTargetSpace.bounds.width,\n\t\ttargetGeometryInTargetSpace.bounds.height\n\t)\n\n\tconst handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {\n\t\tconst axis = ElbowArrowAxes[ElbowArrowSideAxes[side]]\n\n\t\tconst farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace)\n\n\t\tlet isEnabled = false\n\t\tlet handlePointInTargetSpace: VecLike = axis.v(\n\t\t\ttargetBoundsInTargetSpace[side],\n\t\t\ttargetBoundsInTargetSpace[axis.crossMid]\n\t\t)\n\t\tlet furthestDistance = 0\n\n\t\tconst intersections = targetGeometryInTargetSpace.intersectLineSegment(\n\t\t\ttargetCenterInTargetSpace,\n\t\t\tfarPoint,\n\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t)\n\t\tfor (const intersection of intersections) {\n\t\t\tconst distance = Vec.Dist2(intersection, targetCenterInTargetSpace)\n\t\t\tif (distance > furthestDistance) {\n\t\t\t\tfurthestDistance = distance\n\t\t\t\thandlePointInTargetSpace = intersection\n\t\t\t\tisEnabled = targetGeometryInTargetSpace.isClosed\n\t\t\t}\n\t\t}\n\n\t\tconst handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace)\n\n\t\treturn { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) }\n\t})\n\n\tconst zoomLevel = editor.getZoomLevel()\n\tconst minDistScaled = util.options.minElbowHandleDistance / zoomLevel\n\n\tconst targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace)\n\tfor (const side of objectMapKeys(handlesInPageSpace)) {\n\t\tconst handle = handlesInPageSpace[side]\n\t\tif (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {\n\t\t\thandle.isEnabled = false\n\t\t}\n\t}\n\n\tlet precise = isPrecise\n\n\tif (!precise) {\n\t\t// If we're switching to a new bound shape, then precise only if moving slowly\n\t\tif (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {\n\t\t\tprecise = editor.inputs.getPointerVelocity().len() < 0.5\n\t\t}\n\t}\n\n\tif (!isPrecise) {\n\t\tif (!targetGeometryInTargetSpace.isClosed) {\n\t\t\tprecise = true\n\t\t}\n\n\t\t// Double check that we're not going to be doing an imprecise snap on\n\t\t// the same shape twice, as this would result in a zero length line\n\t\tif (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {\n\t\t\tprecise = true\n\t\t}\n\t}\n\n\tconst isExact = util.options.shouldBeExact(editor, precise)\n\tif (isExact) precise = true\n\n\tconst shouldSnapCenter = !isExact && precise && targetGeometryInTargetSpace.isClosed\n\t// const shouldSnapEdges = !isExact && (precise || !targetGeometryInTargetSpace.isClosed)\n\tconst shouldSnapEdges =\n\t\t!isExact && ((precise && arrowKind === 'elbow') || !targetGeometryInTargetSpace.isClosed)\n\tconst shouldSnapEdgePoints =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\tconst shouldSnapNone = precise && (targetGeometryInTargetSpace.isClosed || isExact)\n\tconst shouldSnapCenterAxis =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\n\t// we run through all the snapping options from least to most specific:\n\tlet snap: ElbowArrowSnap = 'none'\n\tlet anchorInPageSpace: VecLike = pointInPageSpace\n\n\tif (!shouldSnapNone) {\n\t\tsnap = 'center'\n\t\tanchorInPageSpace = targetCenterInPageSpace\n\t}\n\n\tif (shouldSnapEdges) {\n\t\tconst snapDistance = shouldSnapNone\n\t\t\t? calculateSnapDistance(\n\t\t\t\t\teditor,\n\t\t\t\t\ttargetBoundsInTargetSpace,\n\t\t\t\t\tutil.options.elbowArrowEdgeSnapDistance\n\t\t\t\t)\n\t\t\t: Infinity\n\n\t\tconst nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(\n\t\t\tpointInTargetSpace,\n\t\t\t{\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t}\n\t\t)\n\n\t\tconst nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(\n\t\t\tnearestPointOnEdgeInTargetSpace\n\t\t)\n\n\t\tconst distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace)\n\n\t\tif (distance < snapDistance) {\n\t\t\tsnap = 'edge'\n\t\t\tanchorInPageSpace = nearestPointOnEdgeInPageSpace\n\t\t}\n\t}\n\n\tif (shouldSnapCenterAxis) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowAxisSnapDistance\n\t\t)\n\n\t\tconst distanceFromXAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.left.far,\n\t\t\thandlesInPageSpace.right.far,\n\t\t\tpointInPageSpace\n\t\t)\n\t\tconst distanceFromYAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.top.far,\n\t\t\thandlesInPageSpace.bottom.far,\n\t\t\tpointInPageSpace\n\t\t)\n\n\t\tconst snapAxis =\n\t\t\tdistanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance\n\t\t\t\t? 'x'\n\t\t\t\t: distanceFromYAxis < snapDistance\n\t\t\t\t\t? 'y'\n\t\t\t\t\t: null\n\n\t\tif (snapAxis) {\n\t\t\tconst axis = ElbowArrowAxes[snapAxis]\n\n\t\t\tconst loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace)\n\t\t\tconst hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace)\n\n\t\t\tconst side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge\n\n\t\t\tif (handlesInPageSpace[side].isEnabled) {\n\t\t\t\tsnap = 'edge-point'\n\t\t\t\tanchorInPageSpace = handlesInPageSpace[side].point\n\t\t\t}\n\t\t}\n\t}\n\n\tif (shouldSnapEdgePoints) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowPointSnapDistance\n\t\t)\n\n\t\tlet closestSide: ElbowArrowSide | null = null\n\t\tlet closestDistance = Infinity\n\n\t\tfor (const [side, handle] of objectMapEntries(handlesInPageSpace)) {\n\t\t\tif (!handle.isEnabled) continue\n\t\t\tconst distance = Vec.Dist(handle.point, pointInPageSpace)\n\t\t\tif (distance < snapDistance && distance < closestDistance) {\n\t\t\t\tclosestDistance = distance\n\t\t\t\tclosestSide = side\n\t\t\t}\n\t\t}\n\n\t\tif (closestSide) {\n\t\t\tsnap = 'edge-point'\n\t\t\tanchorInPageSpace = handlesInPageSpace[closestSide].point\n\t\t}\n\t}\n\n\tif (shouldSnapCenter) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tarrowKind === 'elbow'\n\t\t\t\t? util.options.elbowArrowCenterSnapDistance\n\t\t\t\t: util.options.arcArrowCenterSnapDistance\n\t\t)\n\n\t\tif (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {\n\t\t\tsnap = 'center'\n\t\t\tanchorInPageSpace = targetCenterInPageSpace\n\t\t}\n\t}\n\n\tconst snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace)\n\n\tconst normalizedAnchor = {\n\t\tx: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minX,\n\t\t\ttargetBoundsInTargetSpace.maxX,\n\t\t\tsnapPointInTargetSpace.x\n\t\t),\n\t\ty: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minY,\n\t\t\ttargetBoundsInTargetSpace.maxY,\n\t\t\tsnapPointInTargetSpace.y\n\t\t),\n\t}\n\n\tconst result: ArrowTargetState = {\n\t\ttarget,\n\t\tarrowKind,\n\t\thandlesInPageSpace,\n\t\tcenterInPageSpace: targetCenterInPageSpace,\n\t\tanchorInPageSpace,\n\t\tisExact,\n\t\tisPrecise: precise,\n\t\tsnap,\n\t\tnormalizedAnchor,\n\t}\n\n\tgetArrowTargetAtom(editor).set(result)\n\n\treturn result\n}\n\nconst targetFilterFallback = { type: 'arrow' as const }\n\n/**\n * Funky math but we want the snap distance to be 4 at the minimum and either 16 or 15% of the\n * smaller dimension of the target shape, whichever is smaller\n */\nfunction calculateSnapDistance(\n\teditor: Editor,\n\ttargetBoundsInTargetSpace: Box,\n\tidealSnapDistance: number\n) {\n\treturn (\n\t\tclamp(\n\t\t\tMath.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,\n\t\t\t4,\n\t\t\tidealSnapDistance\n\t\t) / editor.getZoomLevel()\n\t)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2405, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/toolStates/Idle.tsx"],"sourcesContent":["import { StateNode, TLKeyboardEventInfo, TLPointerEventInfo, TLShapeId } from '@tldraw/editor'\nimport { startEditingShapeWithRichText } from '../../../tools/SelectTool/selectHelpers'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { clearArrowTargetState, updateArrowTargetState } from '../arrowTargetState'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tisPrecise = false\n\tisPreciseTimerId: number | null = null\n\tpreciseTargetId: TLShapeId | null = null\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', { ...info, isPrecise: this.isPrecise })\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t\tthis.update()\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n\n\toverride onExit() {\n\t\tclearArrowTargetState(this.editor)\n\t\tif (this.isPreciseTimerId !== null) {\n\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t}\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tthis.update()\n\t\tif (info.key === 'Enter') {\n\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\tif (this.editor.canEditShape(onlySelectedShape)) {\n\t\t\t\tstartEditingShapeWithRichText(this.editor, onlySelectedShape, { selectAll: true })\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate() {\n\t\tconst arrowUtil = this.editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t\tconst targetState = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.inputs.getCurrentPagePoint(),\n\t\t\tarrow: undefined,\n\t\t\tisPrecise: this.isPrecise,\n\t\t\tcurrentBinding: undefined,\n\t\t\toppositeBinding: undefined,\n\t\t})\n\n\t\tif (targetState && targetState.target.id !== this.preciseTargetId) {\n\t\t\tif (this.isPreciseTimerId !== null) {\n\t\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t\t}\n\n\t\t\tthis.preciseTargetId = targetState.target.id\n\t\t\tthis.isPreciseTimerId = this.editor.timers.setTimeout(() => {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.update()\n\t\t\t}, arrowUtil.options.hoverPreciseTimeout)\n\t\t} else if (!targetState && this.preciseTargetId) {\n\t\t\tthis.isPrecise = false\n\t\t\tthis.preciseTargetId = null\n\t\t\tif (this.isPreciseTimerId !== null) {\n\t\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAqE;AAC9E,SAAS,qCAAqC;AAE9C,SAAS,uBAAuB,8BAA8B;;;;AAEvD,MAAM,aAAa,wPAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAErB,YAAY,MAAA;IACZ,mBAAkC,KAAA;IAClC,kBAAoC,KAAA;IAE3B,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY;YAAE,GAAG,IAAA;YAAM,WAAW,IAAA,CAAK,SAAA;QAAU,CAAC;IAC1E;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;QACpD,IAAA,CAAK,MAAA,CAAO;IACb;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;IAES,SAAS;QACjB,IAAA,+PAAA,EAAsB,IAAA,CAAK,MAAM;QACjC,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;YACnC,aAAa,IAAA,CAAK,gBAAgB;QACnC;IACD;IAES,YAAY;QACpB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,QAAQ,IAAA,EAA2B;QAC3C,IAAA,CAAK,MAAA,CAAO;QACZ,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,MAAM,oBAAoB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;YAC3D,IAAI,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,iBAAiB,GAAG;gBAChD,IAAA,wQAAA,EAA8B,IAAA,CAAK,MAAA,EAAQ,mBAAmB;oBAAE,WAAW;gBAAK,CAAC;YAClF;QACD;IACD;IAEA,SAAS;QACR,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAA6B,OAAO;QAElE,MAAM,kBAAc,gQAAA,EAAuB;YAC1C,QAAQ,IAAA,CAAK,MAAA;YACb,kBAAkB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,mBAAA,CAAoB;YACzD,OAAO,KAAA;YACP,WAAW,IAAA,CAAK,SAAA;YAChB,gBAAgB,KAAA;YAChB,iBAAiB,KAAA;QAClB,CAAC;QAED,IAAI,eAAe,YAAY,MAAA,CAAO,EAAA,KAAO,IAAA,CAAK,eAAA,EAAiB;YAClE,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;gBACnC,aAAa,IAAA,CAAK,gBAAgB;YACnC;YAEA,IAAA,CAAK,eAAA,GAAkB,YAAY,MAAA,CAAO,EAAA;YAC1C,IAAA,CAAK,gBAAA,GAAmB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,CAAW,MAAM;gBAC3D,IAAA,CAAK,SAAA,GAAY;gBACjB,IAAA,CAAK,MAAA,CAAO;YACb,GAAG,UAAU,OAAA,CAAQ,mBAAmB;QACzC,OAAA,IAAW,CAAC,eAAe,IAAA,CAAK,eAAA,EAAiB;YAChD,IAAA,CAAK,SAAA,GAAY;YACjB,IAAA,CAAK,eAAA,GAAkB;YACvB,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;gBACnC,aAAa,IAAA,CAAK,gBAAgB;YACnC;QACD;IACD;AACD"}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/toolStates/Pointing.tsx"],"sourcesContent":["import { StateNode, TLArrowShape, createShapeId, maybeSnapToGrid } from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { clearArrowTargetState, updateArrowTargetState } from '../arrowTargetState'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tshape?: TLArrowShape\n\n\tisPrecise = false\n\tisPreciseTimerId: number | null = null\n\n\tmarkId = ''\n\n\toverride onEnter(info: { isPrecise?: boolean }) {\n\t\tthis.markId = ''\n\t\tthis.isPrecise = !!info.isPrecise\n\n\t\tconst targetState = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.inputs.getCurrentPagePoint(),\n\t\t\tarrow: undefined,\n\t\t\tisPrecise: this.isPrecise,\n\t\t\tcurrentBinding: undefined,\n\t\t\toppositeBinding: undefined,\n\t\t})\n\n\t\tif (!targetState) {\n\t\t\tthis.createArrowShape()\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.startPreciseTimeout()\n\t}\n\n\toverride onExit() {\n\t\tthis.shape = undefined\n\t\tclearArrowTargetState(this.editor)\n\t\tthis.clearPreciseTimeout()\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.getIsDragging()) {\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.createArrowShape()\n\t\t\t}\n\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.updateArrowShapeEndHandle()\n\n\t\t\tthis.editor.setCurrentTool('select.dragging_handle', {\n\t\t\t\tshape: this.shape,\n\t\t\t\thandle: { id: 'end', type: 'vertex', index: 'a3', x: 0, y: 0 },\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId: this.markId || undefined,\n\t\t\t\tonInteractionEnd: 'arrow',\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.cancel()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tcancel() {\n\t\tif (this.shape) {\n\t\t\t// the arrow might not have been created yet!\n\t\t\tthis.editor.bailToMark(this.markId)\n\t\t}\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcreateArrowShape() {\n\t\tconst originPagePoint = this.editor.inputs.getOriginPagePoint()\n\n\t\tconst id = createShapeId()\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${id}`)\n\t\tconst newPoint = maybeSnapToGrid(originPagePoint, this.editor)\n\t\tthis.editor.createShape({\n\t\t\tid,\n\t\t\ttype: 'arrow',\n\t\t\tx: newPoint.x,\n\t\t\ty: newPoint.y,\n\t\t\tprops: {\n\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t},\n\t\t})\n\n\t\tconst shape = this.editor.getShape<TLArrowShape>(id)\n\t\tif (!shape) return\n\n\t\tconst handles = this.editor.getShapeHandles(shape)\n\t\tif (!handles) throw Error(`expected handles for arrow`)\n\n\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\tconst initial = this.shape\n\t\tconst startHandle = handles.find((h) => h.id === 'start')!\n\t\tconst change = util.onHandleDrag?.(shape, {\n\t\t\thandle: { ...startHandle, x: 0, y: 0 },\n\t\t\tisPrecise: true,\n\t\t\tisCreatingShape: true,\n\t\t\tinitial: initial,\n\t\t})\n\n\t\tif (change) {\n\t\t\tthis.editor.updateShapes([change])\n\t\t}\n\n\t\t// Cache the current shape after those changes\n\t\tthis.shape = this.editor.getShape(id)\n\t\tthis.editor.select(id)\n\t}\n\n\tupdateArrowShapeEndHandle() {\n\t\tconst shape = this.shape\n\t\tif (!shape) throw Error(`expected shape`)\n\n\t\tconst handles = this.editor.getShapeHandles(shape)\n\t\tif (!handles) throw Error(`expected handles for arrow`)\n\n\t\t// start update\n\t\t{\n\t\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\t\tconst initial = this.shape\n\t\t\tconst startHandle = handles.find((h) => h.id === 'start')!\n\t\t\tconst change = util.onHandleDrag?.(shape, {\n\t\t\t\thandle: { ...startHandle, x: 0, y: 0 },\n\t\t\t\tisPrecise: this.isPrecise,\n\t\t\t\tisCreatingShape: true,\n\t\t\t\tinitial: initial,\n\t\t\t})\n\n\t\t\tif (change) {\n\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t}\n\t\t}\n\n\t\t// end update\n\t\t{\n\t\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\t\tconst initial = this.shape\n\t\t\tconst point = this.editor.getPointInShapeSpace(\n\t\t\t\tshape,\n\t\t\t\tthis.editor.inputs.getCurrentPagePoint()\n\t\t\t)\n\t\t\tconst endHandle = handles.find((h) => h.id === 'end')!\n\t\t\tconst change = util.onHandleDrag?.(this.editor.getShape(shape)!, {\n\t\t\t\thandle: { ...endHandle, x: point.x, y: point.y },\n\t\t\t\tisPrecise: this.isPrecise,\n\t\t\t\tisCreatingShape: true,\n\t\t\t\tinitial: initial,\n\t\t\t})\n\n\t\t\tif (change) {\n\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t}\n\t\t}\n\n\t\t// Cache the current shape after those changes\n\t\tthis.shape = this.editor.getShape(shape.id)\n\t}\n\n\tprivate startPreciseTimeout() {\n\t\tconst arrowUtil = this.editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t\tthis.isPreciseTimerId = this.editor.timers.setTimeout(() => {\n\t\t\tif (!this.getIsActive()) return\n\t\t\tthis.isPrecise = true\n\t\t}, arrowUtil.options.pointingPreciseTimeout)\n\t}\n\n\tprivate clearPreciseTimeout() {\n\t\tif (this.isPreciseTimerId !== null) {\n\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2685, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/ArrowShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class ArrowShapeTool extends StateNode {\n\tstatic override id = 'arrow'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\n\toverride shapeType = 'arrow'\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,uBAAuB,wPAAA,CAAU;IAC7C,OAAgB,KAAK,QAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;YAAC,gPAAA;YAAM,wPAAQ;SAAA;IACvB;IAES,YAAY,QAAA;AACtB"}},
    {"offset": {"line": 2713, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/ArrowPath.tsx"],"sourcesContent":["import { exhaustiveSwitchError, TLArrowShape } from '@tldraw/editor'\nimport { PathBuilder, PathBuilderOpts } from '../shared/PathBuilder'\nimport { TLArrowInfo } from './arrow-types'\nimport { getRouteHandlePath } from './elbow/getElbowArrowInfo'\n\nexport function getArrowBodyPathBuilder(info: TLArrowInfo): PathBuilder {\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 })\n\t\t\t\t.lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 })\n\t\tcase 'arc':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 })\n\t\t\t\t.circularArcTo(\n\t\t\t\t\tinfo.bodyArc.radius,\n\t\t\t\t\t!!info.bodyArc.largeArcFlag,\n\t\t\t\t\t!!info.bodyArc.sweepFlag,\n\t\t\t\t\tinfo.end.point.x,\n\t\t\t\t\tinfo.end.point.y,\n\t\t\t\t\t{ offset: 0, roundness: 0 }\n\t\t\t\t)\n\t\tcase 'elbow': {\n\t\t\tconst path = new PathBuilder()\n\t\t\tpath.moveTo(info.start.point.x, info.start.point.y, {\n\t\t\t\toffset: 0,\n\t\t\t})\n\t\t\tfor (let i = 1; i < info.route.points.length; i++) {\n\t\t\t\tconst point = info.route.points[i]\n\t\t\t\tif (info.route.skipPointsWhenDrawing.has(point)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpath.lineTo(point.x, point.y, {\n\t\t\t\t\toffset: i === info.route.points.length - 1 ? 0 : undefined,\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn path\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n\nexport function getArrowBodyPath(shape: TLArrowShape, info: TLArrowInfo, opts: PathBuilderOpts) {\n\treturn getArrowBodyPathBuilder(info).toSvg(opts)\n}\n\nexport function getArrowHandlePath(info: TLArrowInfo, opts: PathBuilderOpts) {\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.handle.x, info.start.handle.y)\n\t\t\t\t.lineTo(info.end.handle.x, info.end.handle.y)\n\t\t\t\t.toSvg(opts)\n\t\tcase 'arc':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.handle.x, info.start.handle.y)\n\t\t\t\t.circularArcTo(\n\t\t\t\t\tinfo.handleArc.radius,\n\t\t\t\t\t!!info.handleArc.largeArcFlag,\n\t\t\t\t\t!!info.handleArc.sweepFlag,\n\t\t\t\t\tinfo.end.handle.x,\n\t\t\t\t\tinfo.end.handle.y\n\t\t\t\t)\n\t\t\t\t.toSvg(opts)\n\t\tcase 'elbow': {\n\t\t\tconst handleRoute = getRouteHandlePath(info.elbow, info.route)\n\t\t\treturn PathBuilder.lineThroughPoints(handleRoute.points).toSvg(opts)\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2791, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/arrowLabel.ts"],"sourcesContent":["import {\n\tArc2d,\n\tBox,\n\tCircle2d,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tGroup2d,\n\tPolygon2d,\n\tPolyline2d,\n\tTLArrowShape,\n\tTLShape,\n\tVec,\n\tVecLike,\n\tclamp,\n\tcreateComputedCache,\n\texhaustiveSwitchError,\n\tgetChangedKeys,\n\tpointInPolygon,\n\ttoRichText,\n} from '@tldraw/editor'\nimport { isEmptyRichText, renderHtmlFromRichTextForMeasurement } from '../../utils/text/richText'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tARROW_LABEL_PADDING,\n\tFONT_FAMILIES,\n\tLABEL_TO_ARROW_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { TLArrowInfo } from './arrow-types'\nimport { getArrowInfo } from './shared'\n\nexport function getArrowBodyGeometry(editor: Editor, shape: TLArrowShape) {\n\tconst info = getArrowInfo(editor, shape)!\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new Edge2d({\n\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t})\n\t\tcase 'arc':\n\t\t\treturn new Arc2d({\n\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t})\n\t\tcase 'elbow':\n\t\t\treturn new Polyline2d({ points: info.route.points })\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n\nconst labelSizeCache = createComputedCache(\n\t'arrow label size',\n\t(editor: Editor, shape: TLArrowShape) => {\n\t\teditor.fonts.trackFontsForShape(shape)\n\t\tlet width = 0\n\t\tlet height = 0\n\n\t\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\t\t// We use 'i' as a default label to measure against as a minimum width.\n\t\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\t\tconst html = renderHtmlFromRichTextForMeasurement(\n\t\t\teditor,\n\t\t\tisEmpty ? toRichText('i') : shape.props.richText\n\t\t)\n\n\t\tconst bodyBounds = bodyGeom.bounds\n\n\t\tconst fontSize = getArrowLabelFontSize(shape)\n\n\t\t// First we measure the text with no constraints\n\t\tconst { w, h } = editor.textMeasure.measureHtml(html, {\n\t\t\t...TEXT_PROPS,\n\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\tfontSize,\n\t\t\tmaxWidth: null,\n\t\t})\n\n\t\twidth = w\n\t\theight = h\n\n\t\tlet shouldSquish = false\n\n\t\t// If the text is wider than the body, we need to squish it\n\t\tconst info = getArrowInfo(editor, shape)!\n\t\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\t\tconst margin =\n\t\t\tinfo.type === 'elbow'\n\t\t\t\t? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) +\n\t\t\t\t\tMath.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32)\n\t\t\t\t: 64\n\n\t\tif (bodyBounds.width > bodyBounds.height) {\n\t\t\twidth = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w))\n\t\t\tshouldSquish = true\n\t\t} else if (width > 16 * fontSize) {\n\t\t\twidth = 16 * fontSize\n\t\t\tshouldSquish = true\n\t\t}\n\n\t\tif (shouldSquish) {\n\t\t\tconst { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureHtml(html, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\tfontSize,\n\t\t\t\tmaxWidth: width,\n\t\t\t})\n\n\t\t\twidth = squishedWidth\n\t\t\theight = squishedHeight\n\t\t}\n\n\t\treturn new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale)\n\t},\n\t{\n\t\tareRecordsEqual: (a, b) => {\n\t\t\tif (a.props === b.props) return true\n\n\t\t\t// If the only thing that has changed is the label position, we can skip recalculating the size\n\t\t\tconst changedKeys = getChangedKeys(a.props, b.props)\n\t\t\treturn changedKeys.length === 1 && changedKeys[0] === 'labelPosition'\n\t\t},\n\t}\n)\n\nfunction getArrowLabelSize(editor: Editor, shape: TLArrowShape) {\n\treturn labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0)\n}\n\nfunction getLabelToArrowPadding(shape: TLArrowShape) {\n\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\tconst labelToArrowPadding =\n\t\t(LABEL_TO_ARROW_PADDING +\n\t\t\t(strokeWidth - STROKE_SIZES.s) * 2 +\n\t\t\t(strokeWidth === STROKE_SIZES.xl ? 20 : 0)) *\n\t\tshape.props.scale\n\n\treturn labelToArrowPadding\n}\n\n/**\n * Return the range of possible label positions for an arrow. The full possible range is 0 to 1, but\n * as the label itself takes up space the usable range is smaller.\n */\nfunction getArrowLabelRange(editor: Editor, shape: TLArrowShape, info: TLArrowInfo) {\n\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\tconst dbgPoints: VecLike[] = []\n\tconst dbg: Geometry2d[] = [new Group2d({ children: [bodyGeom], debugColor: 'lime' })]\n\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\tconst paddingRelative = labelToArrowPadding / bodyGeom.length\n\n\t// we can calculate the range by sticking the center of the label at the very start/end of the\n\t// arrow, and seeing where the label intersects with the arrow. Then, if we move the label's\n\t// center to that point, that'll be the start/end of the range.\n\n\tlet startBox, endBox\n\tif (info.type === 'elbow') {\n\t\t// for elbow arrows, because they have multiple segments but are always axis-aligned, we can use\n\t\t// an expanded box. This helps keep the box from partially covering the first segment when it's\n\t\t// very small.\n\t\tdbgPoints.push(info.start.point, info.end.point)\n\t\tstartBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding)\n\t\tendBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding)\n\t} else {\n\t\t// for other arrows, we move along the arrow by the padding amount to find the start/end points\n\t\tconst startPoint = bodyGeom.interpolateAlongEdge(paddingRelative)\n\t\tconst endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative)\n\t\tdbgPoints.push(startPoint, endPoint)\n\t\tstartBox = Box.FromCenter(startPoint, labelSize)\n\t\tendBox = Box.FromCenter(endPoint, labelSize)\n\t}\n\tconst startIntersections = bodyGeom.intersectPolygon(startBox.corners)\n\tconst endIntersections = bodyGeom.intersectPolygon(endBox.corners)\n\n\tconst startConstrained = furthest(info.start.point, startIntersections)\n\tconst endConstrained = furthest(info.end.point, endIntersections)\n\n\tlet startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5\n\tlet endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5\n\n\tif (startRelative > endRelative) {\n\t\tstartRelative = 0.5\n\t\tendRelative = 0.5\n\t}\n\n\tfor (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {\n\t\tdbg.push(\n\t\t\tnew Circle2d({\n\t\t\t\tx: pt.x - 3,\n\t\t\t\ty: pt.y - 3,\n\t\t\t\tradius: 3,\n\t\t\t\tisFilled: false,\n\t\t\t\tdebugColor: 'magenta',\n\t\t\t\tignore: true,\n\t\t\t})\n\t\t)\n\t}\n\tdbg.push(\n\t\tnew Polygon2d({\n\t\t\tpoints: startBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t}),\n\t\tnew Polygon2d({\n\t\t\tpoints: endBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t})\n\t)\n\n\treturn { start: startRelative, end: endRelative, dbg }\n}\n\ninterface ArrowheadInfo {\n\thasStartBinding: boolean\n\thasEndBinding: boolean\n\thasStartArrowhead: boolean\n\thasEndArrowhead: boolean\n}\nexport function getArrowLabelPosition(editor: Editor, shape: TLArrowShape) {\n\tconst isEditing = editor.getEditingShapeId() === shape.id\n\tif (!isEditing && isEmptyRichText(shape.props.richText)) {\n\t\t// Short-circuit for empty labels.\n\t\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\t\tconst labelCenter = bodyGeom.interpolateAlongEdge(0.5)\n\t\treturn { box: Box.FromCenter(labelCenter, new Vec(0, 0)), debugGeom: [] }\n\t}\n\n\tconst debugGeom: Geometry2d[] = []\n\tconst info = getArrowInfo(editor, shape)!\n\n\tconst arrowheadInfo: ArrowheadInfo = {\n\t\thasStartBinding: !!info.bindings.start,\n\t\thasEndBinding: !!info.bindings.end,\n\t\thasStartArrowhead: info.start.arrowhead !== 'none',\n\t\thasEndArrowhead: info.end.arrowhead !== 'none',\n\t}\n\n\tconst range = getArrowLabelRange(editor, shape, info)\n\tif (range.dbg) debugGeom.push(...range.dbg)\n\n\tconst clampedPosition = getClampedPosition(shape, range, arrowheadInfo)\n\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\tconst labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition)\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\n\treturn { box: Box.FromCenter(labelCenter, labelSize), debugGeom }\n}\n\nfunction getClampedPosition(\n\tshape: TLArrowShape,\n\trange: { start: number; end: number },\n\tarrowheadInfo: ArrowheadInfo\n) {\n\tconst { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo\n\tconst clampedPosition = clamp(\n\t\tshape.props.labelPosition,\n\t\thasStartArrowhead || hasStartBinding ? range.start : 0,\n\t\thasEndArrowhead || hasEndBinding ? range.end : 1\n\t)\n\n\treturn clampedPosition\n}\n\nfunction furthest(from: VecLike, candidates: VecLike[]): VecLike | null {\n\tlet furthest: VecLike | null = null\n\tlet furthestDist = -Infinity\n\n\tfor (const candidate of candidates) {\n\t\tconst dist = Vec.Dist2(from, candidate)\n\t\tif (dist > furthestDist) {\n\t\t\tfurthest = candidate\n\t\t\tfurthestDist = dist\n\t\t}\n\t}\n\n\treturn furthest\n}\n\nexport function getArrowLabelFontSize(shape: TLArrowShape) {\n\treturn ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale\n}\n\nexport function getArrowLabelDefaultPosition(editor: Editor, shape: TLArrowShape) {\n\tconst info = getArrowInfo(editor, shape)!\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\tcase 'arc':\n\t\t\treturn 0.5\n\t\tcase 'elbow': {\n\t\t\tconst midpointHandle = info.route.midpointHandle\n\t\t\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\t\t\tif (midpointHandle && bodyGeom) {\n\t\t\t\treturn bodyGeom.uninterpolateAlongEdge(midpointHandle.point)\n\t\t\t}\n\t\t\treturn 0.5\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n\n/** @internal */\nexport function isOverArrowLabel(editor: Editor, shape: TLShape) {\n\tif (!editor.isShapeOfType(shape, 'arrow')) return false\n\n\tconst pointInShapeSpace = editor.getPointInShapeSpace(shape, editor.inputs.getCurrentPagePoint())\n\t// How should we handle multiple labels? Do shapes ever have multiple labels?\n\tconst labelGeometry = editor.getShapeGeometry<Group2d>(shape).children[1]\n\t// Knowing what we know about arrows... if the shape has no text in its label,\n\t// then the label geometry should not be there.\n\treturn labelGeometry && pointInPolygon(pointInShapeSpace, labelGeometry.vertices)\n}\n"],"names":["bodyGeom", "labelCenter", "furthest"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAqBA,SAAS,iBAAiB,4CAA4C;AACtE;AASA,SAAS,oBAAoB;;;;;AAEtB,SAAS,qBAAqB,MAAA,EAAgB,KAAA,EAAqB;IACzE,MAAM,WAAO,4OAAA,EAAa,QAAQ,KAAK;IACvC,OAAQ,KAAK,IAAA,EAAM;QAClB,KAAK;YACJ,OAAO,IAAI,yPAAA,CAAO;gBACjB,OAAO,uOAAA,CAAI,IAAA,CAAK,KAAK,KAAA,CAAM,KAAK;gBAChC,KAAK,uOAAA,CAAI,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK;YAC7B,CAAC;QACF,KAAK;YACJ,OAAO,IAAI,uPAAA,CAAM;gBAChB,QAAQ,uOAAA,CAAI,IAAA,CAAK,KAAK,SAAA,CAAU,MAAM;gBACtC,OAAO,uOAAA,CAAI,IAAA,CAAK,KAAK,KAAA,CAAM,KAAK;gBAChC,KAAK,uOAAA,CAAI,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK;gBAC5B,WAAW,KAAK,OAAA,CAAQ,SAAA;gBACxB,cAAc,KAAK,OAAA,CAAQ,YAAA;YAC5B,CAAC;QACF,KAAK;YACJ,OAAO,IAAI,iQAAA,CAAW;gBAAE,QAAQ,KAAK,KAAA,CAAM,MAAA;YAAO,CAAC;QACpD;YACC,IAAA,qOAAA,EAAsB,MAAM,MAAM;IACpC;AACD;AAEA,MAAM,qBAAiB,mOAAA,EACtB,oBACA,CAAC,QAAgB,UAAwB;IACxC,OAAO,KAAA,CAAM,kBAAA,CAAmB,KAAK;IACrC,IAAI,QAAQ;IACZ,IAAI,SAAS;IAEb,MAAM,WAAW,qBAAqB,QAAQ,KAAK;IAEnD,MAAM,cAAU,+OAAA,EAAgB,MAAM,KAAA,CAAM,QAAQ;IACpD,MAAM,WAAO,oQAAA,EACZ,QACA,cAAU,6NAAA,EAAW,GAAG,IAAI,MAAM,KAAA,CAAM,QAAA;IAGzC,MAAM,aAAa,SAAS,MAAA;IAE5B,MAAM,WAAW,sBAAsB,KAAK;IAG5C,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,OAAO,WAAA,CAAY,WAAA,CAAY,MAAM;QACrD,GAAG,kQAAA;QACH,YAAY,qQAAA,CAAc,MAAM,KAAA,CAAM,IAAI,CAAA;QAC1C;QACA,UAAU;IACX,CAAC;IAED,QAAQ;IACR,SAAS;IAET,IAAI,eAAe;IAGnB,MAAM,WAAO,4OAAA,EAAa,QAAQ,KAAK;IACvC,MAAM,sBAAsB,uBAAuB,KAAK;IACxD,MAAM,SACL,KAAK,IAAA,KAAS,UACX,KAAK,GAAA,CAAI,KAAK,KAAA,CAAM,CAAA,CAAE,eAAA,GAAkB,qBAAqB,EAAE,IAChE,KAAK,GAAA,CAAI,KAAK,KAAA,CAAM,CAAA,CAAE,eAAA,GAAkB,qBAAqB,EAAE,IAC9D;IAEJ,IAAI,WAAW,KAAA,GAAQ,WAAW,MAAA,EAAQ;QACzC,QAAQ,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,GAAG,MAAM,GAAG,KAAK,GAAA,CAAI,WAAW,KAAA,GAAQ,QAAQ,CAAC,CAAC;QAC5E,eAAe;IAChB,OAAA,IAAW,QAAQ,KAAK,UAAU;QACjC,QAAQ,KAAK;QACb,eAAe;IAChB;IAEA,IAAI,cAAc;QACjB,MAAM,EAAE,GAAG,aAAA,EAAe,GAAG,cAAA,CAAe,CAAA,GAAI,OAAO,WAAA,CAAY,WAAA,CAAY,MAAM;YACpF,GAAG,kQAAA;YACH,YAAY,qQAAA,CAAc,MAAM,KAAA,CAAM,IAAI,CAAA;YAC1C;YACA,UAAU;QACX,CAAC;QAED,QAAQ;QACR,SAAS;IACV;IAEA,OAAO,IAAI,uOAAA,CAAI,OAAO,MAAM,EAAE,SAAA,CAAU,2QAAA,GAAsB,IAAI,MAAM,KAAA,CAAM,KAAK;AACpF,GACA;IACC,iBAAiB,CAAC,GAAG,MAAM;QAC1B,IAAI,EAAE,KAAA,KAAU,EAAE,KAAA,CAAO,CAAA,OAAO;QAGhC,MAAM,kBAAc,8NAAA,EAAe,EAAE,KAAA,EAAO,EAAE,KAAK;QACnD,OAAO,YAAY,MAAA,KAAW,KAAK,WAAA,CAAY,CAAC,CAAA,KAAM;IACvD;AACD;AAGD,SAAS,kBAAkB,MAAA,EAAgB,KAAA,EAAqB;IAC/D,OAAO,eAAe,GAAA,CAAI,QAAQ,MAAM,EAAE,KAAK,IAAI,uOAAA,CAAI,GAAG,CAAC;AAC5D;AAEA,SAAS,uBAAuB,KAAA,EAAqB;IACpD,MAAM,cAAc,oQAAA,CAAa,MAAM,KAAA,CAAM,IAAI,CAAA;IACjD,MAAM,sBAAA,CACJ,8QAAA,GAAA,CACC,cAAc,oQAAA,CAAa,CAAA,IAAK,IAAA,CAChC,gBAAgB,oQAAA,CAAa,EAAA,GAAK,KAAK,CAAA,CAAA,IACzC,MAAM,KAAA,CAAM,KAAA;IAEb,OAAO;AACR;AAMA,SAAS,mBAAmB,MAAA,EAAgB,KAAA,EAAqB,IAAA,EAAmB;IACnF,MAAM,WAAW,qBAAqB,QAAQ,KAAK;IACnD,MAAM,YAAuB,CAAC,CAAA;IAC9B,MAAM,MAAoB;QAAC,IAAI,2PAAA,CAAQ;YAAE,UAAU;gBAAC,QAAQ;aAAA;YAAG,YAAY;QAAO,CAAC,CAAC;KAAA;IAEpF,MAAM,YAAY,kBAAkB,QAAQ,KAAK;IACjD,MAAM,sBAAsB,uBAAuB,KAAK;IACxD,MAAM,kBAAkB,sBAAsB,SAAS,MAAA;IAMvD,IAAI,UAAU;IACd,IAAI,KAAK,IAAA,KAAS,SAAS;QAI1B,UAAU,IAAA,CAAK,KAAK,KAAA,CAAM,KAAA,EAAO,KAAK,GAAA,CAAI,KAAK;QAC/C,WAAW,uOAAA,CAAI,UAAA,CAAW,KAAK,KAAA,CAAM,KAAA,EAAO,SAAS,EAAE,QAAA,CAAS,mBAAmB;QACnF,SAAS,uOAAA,CAAI,UAAA,CAAW,KAAK,GAAA,CAAI,KAAA,EAAO,SAAS,EAAE,QAAA,CAAS,mBAAmB;IAChF,OAAO;QAEN,MAAM,aAAa,SAAS,oBAAA,CAAqB,eAAe;QAChE,MAAM,WAAW,SAAS,oBAAA,CAAqB,IAAI,eAAe;QAClE,UAAU,IAAA,CAAK,YAAY,QAAQ;QACnC,WAAW,uOAAA,CAAI,UAAA,CAAW,YAAY,SAAS;QAC/C,SAAS,uOAAA,CAAI,UAAA,CAAW,UAAU,SAAS;IAC5C;IACA,MAAM,qBAAqB,SAAS,gBAAA,CAAiB,SAAS,OAAO;IACrE,MAAM,mBAAmB,SAAS,gBAAA,CAAiB,OAAO,OAAO;IAEjE,MAAM,mBAAmB,SAAS,KAAK,KAAA,CAAM,KAAA,EAAO,kBAAkB;IACtE,MAAM,iBAAiB,SAAS,KAAK,GAAA,CAAI,KAAA,EAAO,gBAAgB;IAEhE,IAAI,gBAAgB,mBAAmB,SAAS,sBAAA,CAAuB,gBAAgB,IAAI;IAC3F,IAAI,cAAc,iBAAiB,SAAS,sBAAA,CAAuB,cAAc,IAAI;IAErF,IAAI,gBAAgB,aAAa;QAChC,gBAAgB;QAChB,cAAc;IACf;IAEA,KAAA,MAAW,MAAM,CAAC;WAAG,oBAAoB;WAAG,kBAAkB;WAAG,SAAS;KAAA,CAAG;QAC5E,IAAI,IAAA,CACH,IAAI,6PAAA,CAAS;YACZ,GAAG,GAAG,CAAA,GAAI;YACV,GAAG,GAAG,CAAA,GAAI;YACV,QAAQ;YACR,UAAU;YACV,YAAY;YACZ,QAAQ;QACT,CAAC;IAEH;IACA,IAAI,IAAA,CACH,IAAI,+PAAA,CAAU;QACb,QAAQ,SAAS,OAAA;QACjB,YAAY;QACZ,UAAU;QACV,QAAQ;IACT,CAAC,GACD,IAAI,+PAAA,CAAU;QACb,QAAQ,OAAO,OAAA;QACf,YAAY;QACZ,UAAU;QACV,QAAQ;IACT,CAAC;IAGF,OAAO;QAAE,OAAO;QAAe,KAAK;QAAa;IAAI;AACtD;AAQO,SAAS,sBAAsB,MAAA,EAAgB,KAAA,EAAqB;IAC1E,MAAM,YAAY,OAAO,iBAAA,CAAkB,MAAM,MAAM,EAAA;IACvD,IAAI,CAAC,iBAAa,+OAAA,EAAgB,MAAM,KAAA,CAAM,QAAQ,GAAG;QAExD,MAAMA,YAAW,qBAAqB,QAAQ,KAAK;QACnD,MAAMC,eAAcD,UAAS,oBAAA,CAAqB,GAAG;QACrD,OAAO;YAAE,KAAK,uOAAA,CAAI,UAAA,CAAWC,cAAa,IAAI,uOAAA,CAAI,GAAG,CAAC,CAAC;YAAG,WAAW,CAAC,CAAA;QAAE;IACzE;IAEA,MAAM,YAA0B,CAAC,CAAA;IACjC,MAAM,WAAO,4OAAA,EAAa,QAAQ,KAAK;IAEvC,MAAM,gBAA+B;QACpC,iBAAiB,CAAC,CAAC,KAAK,QAAA,CAAS,KAAA;QACjC,eAAe,CAAC,CAAC,KAAK,QAAA,CAAS,GAAA;QAC/B,mBAAmB,KAAK,KAAA,CAAM,SAAA,KAAc;QAC5C,iBAAiB,KAAK,GAAA,CAAI,SAAA,KAAc;IACzC;IAEA,MAAM,QAAQ,mBAAmB,QAAQ,OAAO,IAAI;IACpD,IAAI,MAAM,GAAA,CAAK,CAAA,UAAU,IAAA,CAAK,GAAG,MAAM,GAAG;IAE1C,MAAM,kBAAkB,mBAAmB,OAAO,OAAO,aAAa;IACtE,MAAM,WAAW,qBAAqB,QAAQ,KAAK;IACnD,MAAM,cAAc,SAAS,oBAAA,CAAqB,eAAe;IACjE,MAAM,YAAY,kBAAkB,QAAQ,KAAK;IAEjD,OAAO;QAAE,KAAK,uOAAA,CAAI,UAAA,CAAW,aAAa,SAAS;QAAG;IAAU;AACjE;AAEA,SAAS,mBACR,KAAA,EACA,KAAA,EACA,aAAA,EACC;IACD,MAAM,EAAE,eAAA,EAAiB,aAAA,EAAe,eAAA,EAAiB,iBAAA,CAAkB,CAAA,GAAI;IAC/E,MAAM,sBAAkB,2OAAA,EACvB,MAAM,KAAA,CAAM,aAAA,EACZ,qBAAqB,kBAAkB,MAAM,KAAA,GAAQ,GACrD,mBAAmB,gBAAgB,MAAM,GAAA,GAAM;IAGhD,OAAO;AACR;AAEA,SAAS,SAAS,IAAA,EAAe,UAAA,EAAuC;IACvE,IAAIC,YAA2B;IAC/B,IAAI,eAAe,CAAA;IAEnB,KAAA,MAAW,aAAa,WAAY;QACnC,MAAM,OAAO,uOAAA,CAAI,KAAA,CAAM,MAAM,SAAS;QACtC,IAAI,OAAO,cAAc;YACxBA,YAAW;YACX,eAAe;QAChB;IACD;IAEA,OAAOA;AACR;AAEO,SAAS,sBAAsB,KAAA,EAAqB;IAC1D,OAAO,8QAAA,CAAuB,MAAM,KAAA,CAAM,IAAI,CAAA,GAAI,MAAM,KAAA,CAAM,KAAA;AAC/D;AAEO,SAAS,6BAA6B,MAAA,EAAgB,KAAA,EAAqB;IACjF,MAAM,WAAO,4OAAA,EAAa,QAAQ,KAAK;IACvC,OAAQ,KAAK,IAAA,EAAM;QAClB,KAAK;QACL,KAAK;YACJ,OAAO;QACR,KAAK;YAAS;gBACb,MAAM,iBAAiB,KAAK,KAAA,CAAM,cAAA;gBAClC,MAAM,WAAW,qBAAqB,QAAQ,KAAK;gBACnD,IAAI,kBAAkB,UAAU;oBAC/B,OAAO,SAAS,sBAAA,CAAuB,eAAe,KAAK;gBAC5D;gBACA,OAAO;YACR;QACA;YACC,IAAA,qOAAA,EAAsB,MAAM,MAAM;IACpC;AACD;AAGO,SAAS,iBAAiB,MAAA,EAAgB,KAAA,EAAgB;IAChE,IAAI,CAAC,OAAO,aAAA,CAAc,OAAO,OAAO,EAAG,CAAA,OAAO;IAElD,MAAM,oBAAoB,OAAO,oBAAA,CAAqB,OAAO,OAAO,MAAA,CAAO,mBAAA,CAAoB,CAAC;IAEhG,MAAM,gBAAgB,OAAO,gBAAA,CAA0B,KAAK,EAAE,QAAA,CAAS,CAAC,CAAA;IAGxE,OAAO,qBAAiB,oPAAA,EAAe,mBAAmB,cAAc,QAAQ;AACjF"}},
    {"offset": {"line": 3048, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/arrowheads.ts"],"sourcesContent":["import {\n\tHALF_PI,\n\tPI,\n\tVec,\n\tVecLike,\n\tclamp,\n\texhaustiveSwitchError,\n\tintersectCircleCircle,\n} from '@tldraw/editor'\nimport { TLArrowInfo } from './arrow-types'\n\ninterface TLArrowPointsInfo {\n\tpoint: VecLike\n\tint: VecLike\n}\n\nfunction getArrowPoints(\n\tinfo: TLArrowInfo,\n\tside: 'start' | 'end',\n\tstrokeWidth: number\n): TLArrowPointsInfo {\n\tconst point = side === 'end' ? info.end.point : info.start.point\n\tlet int: VecLike\n\n\tswitch (info.type) {\n\t\tcase 'straight': {\n\t\t\tconst opposite = side === 'end' ? info.start.point : info.end.point\n\t\t\tconst compareLength = Vec.Dist(opposite, point)\n\t\t\tconst length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3)\n\t\t\tint = Vec.Nudge(point, opposite, length)\n\t\t\tbreak\n\t\t}\n\t\tcase 'arc': {\n\t\t\tconst compareLength = Math.abs(info.bodyArc.length)\n\t\t\tconst length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3)\n\t\t\tconst intersections = intersectCircleCircle(\n\t\t\t\tpoint,\n\t\t\t\tlength,\n\t\t\t\tinfo.handleArc.center,\n\t\t\t\tinfo.handleArc.radius\n\t\t\t)\n\t\t\tint =\n\t\t\t\tside === 'end'\n\t\t\t\t\t? info.handleArc.sweepFlag\n\t\t\t\t\t\t? intersections[0]\n\t\t\t\t\t\t: intersections[1]\n\t\t\t\t\t: info.handleArc.sweepFlag\n\t\t\t\t\t\t? intersections[1]\n\t\t\t\t\t\t: intersections[0]\n\t\t\tbreak\n\t\t}\n\t\tcase 'elbow': {\n\t\t\tconst previousPoint =\n\t\t\t\tside === 'end' ? info.route.points[info.route.points.length - 2] : info.route.points[1]\n\t\t\tconst previousSegmentLength = Vec.ManhattanDist(previousPoint, point)\n\t\t\tconst length = clamp(previousSegmentLength / 2, strokeWidth, strokeWidth * 3)\n\t\t\tint = previousPoint ? Vec.Nudge(point, previousPoint, length) : point\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n\n\tif (Vec.IsNaN(int)) {\n\t\tint = point\n\t}\n\n\treturn { point, int }\n}\n\nfunction getArrowhead({ point, int }: TLArrowPointsInfo) {\n\tconst PL = Vec.RotWith(int, point, PI / 6)\n\tconst PR = Vec.RotWith(int, point, -PI / 6)\n\n\treturn `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`\n}\n\nfunction getTriangleHead({ point, int }: TLArrowPointsInfo) {\n\tconst PL = Vec.RotWith(int, point, PI / 6)\n\tconst PR = Vec.RotWith(int, point, -PI / 6)\n\n\treturn `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`\n}\n\nfunction getInvertedTriangleHead({ point, int }: TLArrowPointsInfo) {\n\tconst d = Vec.Sub(int, point).div(2)\n\tconst PL = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`\n}\n\nfunction getDotHead({ point, int }: TLArrowPointsInfo) {\n\tconst A = Vec.Lrp(point, int, 0.45)\n\tconst r = Vec.Dist(A, point)\n\n\treturn `M ${A.x - r},${A.y}\n  a ${r},${r} 0 1,0 ${r * 2},0\n  a ${r},${r} 0 1,0 -${r * 2},0 `\n}\n\nfunction getDiamondHead({ point, int }: TLArrowPointsInfo) {\n\tconst PB = Vec.Lrp(point, int, 0.75)\n\tconst PL = Vec.RotWith(PB, point, PI / 4)\n\tconst PR = Vec.RotWith(PB, point, -PI / 4)\n\n\tconst PQ = Vec.Lrp(PL, PR, 0.5)\n\tPQ.add(Vec.Sub(PQ, point))\n\n\treturn `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`\n}\n\nfunction getSquareHead({ int, point }: TLArrowPointsInfo) {\n\tconst PB = Vec.Lrp(point, int, 0.85)\n\tconst d = Vec.Sub(PB, point).div(2)\n\tconst PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\tconst PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI))\n\tconst PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`\n}\n\nfunction getBarHead({ int, point }: TLArrowPointsInfo) {\n\tconst d = Vec.Sub(int, point).div(2)\n\n\tconst PL = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`\n}\n\n/** @public */\nexport function getArrowheadPathForType(\n\tinfo: TLArrowInfo,\n\tside: 'start' | 'end',\n\tstrokeWidth: number\n): string | undefined {\n\tconst type = side === 'end' ? info.end.arrowhead : info.start.arrowhead\n\tif (type === 'none') return\n\n\tconst points = getArrowPoints(info, side, strokeWidth)\n\tif (!points) return\n\n\tswitch (type) {\n\t\tcase 'bar':\n\t\t\treturn getBarHead(points)\n\t\tcase 'square':\n\t\t\treturn getSquareHead(points)\n\t\tcase 'diamond':\n\t\t\treturn getDiamondHead(points)\n\t\tcase 'dot':\n\t\t\treturn getDotHead(points)\n\t\tcase 'inverted':\n\t\t\treturn getInvertedTriangleHead(points)\n\t\tcase 'arrow':\n\t\t\treturn getArrowhead(points)\n\t\tcase 'triangle':\n\t\t\treturn getTriangleHead(points)\n\t}\n\n\treturn ''\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3173, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/ElbowArrowDebug.tsx"],"sourcesContent":["import { Box, TLArrowShape, useEditor, useValue, VecLike } from '@tldraw/editor'\nimport { SVGProps } from 'react'\nimport { getArrowBindings } from '../shared'\nimport { ElbowArrowEdge } from './definitions'\nimport { getElbowArrowInfo } from './getElbowArrowInfo'\n\nexport function ElbowArrowDebug({ arrow }: { arrow: TLArrowShape }) {\n\tconst editor = useEditor()\n\tconst info = useValue(\n\t\t'elbow arrow grid',\n\t\t() => {\n\t\t\ttry {\n\t\t\t\tconst info = getElbowArrowInfo(\n\t\t\t\t\teditor,\n\t\t\t\t\teditor.getShape(arrow.id)!,\n\t\t\t\t\tgetArrowBindings(editor, arrow)\n\t\t\t\t)\n\t\t\t\treturn info\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(err)\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t},\n\t\t[editor, arrow.id]\n\t)\n\n\tif (!info) return null\n\n\tconst fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50)\n\n\tconst label = info.route?.name ?? ''\n\n\tconst midPoint = info.route?.midpointHandle\n\n\treturn (\n\t\t<>\n\t\t\t{info.midX !== null && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: info.midX, y: fullBox.minY }}\n\t\t\t\t\tb={{ x: info.midX, y: fullBox.maxY }}\n\t\t\t\t\tstroke=\"red\"\n\t\t\t\t/>\n\t\t\t)}\n\t\t\t{info.midY !== null && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: fullBox.minX, y: info.midY }}\n\t\t\t\t\tb={{ x: fullBox.maxX, y: info.midY }}\n\t\t\t\t\tstroke=\"blue\"\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{midPoint?.axis === 'x' && info.midXRange && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: info.midXRange.lo, y: midPoint.point.y }}\n\t\t\t\t\tb={{ x: info.midXRange.hi, y: midPoint.point.y }}\n\t\t\t\t\tstroke=\"red\"\n\t\t\t\t\tstrokeDasharray={'0 2'}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{midPoint?.axis === 'y' && info.midYRange && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: midPoint.point.x, y: info.midYRange.lo }}\n\t\t\t\t\tb={{ x: midPoint.point.x, y: info.midYRange.hi }}\n\t\t\t\t\tstroke=\"blue\"\n\t\t\t\t\tstrokeDasharray={'0 2'}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t<DebugBox box={info.A.original} stroke=\"orange\" />\n\t\t\t<DebugBox box={info.A.expanded} stroke=\"orange\" strokeWidth={0.5} />\n\t\t\t<DebugBox\n\t\t\t\tbox={info.A.original.clone().expandBy(info.options.minElbowLegLength)}\n\t\t\t\tstroke=\"orange\"\n\t\t\t\tstrokeWidth={0.5}\n\t\t\t/>\n\t\t\t<DebugBox box={info.B.original} stroke=\"lightskyblue\" />\n\t\t\t<DebugBox box={info.B.expanded} stroke=\"lightskyblue\" strokeWidth={0.5} />\n\t\t\t<DebugBox\n\t\t\t\tbox={info.B.original.clone().expandBy(info.options.minElbowLegLength)}\n\t\t\t\tstroke=\"lightskyblue\"\n\t\t\t\tstrokeWidth={0.5}\n\t\t\t/>\n\n\t\t\t<DebugEdge edge={info.A.edges.top} axis=\"x\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.top} axis=\"x\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.right} axis=\"y\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.right} axis=\"y\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.bottom} axis=\"x\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.bottom} axis=\"x\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.left} axis=\"y\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.left} axis=\"y\" stroke=\"lightskyblue\" />\n\n\t\t\t{info.route && <DebugRoute route={info.route.points} strokeWidth={10} />}\n\n\t\t\t<text\n\t\t\t\tx={fullBox.minX + 5}\n\t\t\t\ty={fullBox.minY - 3}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--tl-color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\t{label}\n\t\t\t</text>\n\t\t\t<text\n\t\t\t\tx={info.A.expanded.x}\n\t\t\t\ty={info.A.expanded.y}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--tl-color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\tA{info.route && `, ${info.route.aEdgePicking}`}\n\t\t\t\t{info.A.isPoint && `, point`}\n\t\t\t</text>\n\t\t\t<text\n\t\t\t\tx={info.B.expanded.x}\n\t\t\t\ty={info.B.expanded.y}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--tl-color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\tB{info.route && `, ${info.route.bEdgePicking}`}\n\t\t\t\t{info.B.isPoint && `, point`}\n\t\t\t</text>\n\t\t</>\n\t)\n}\n\nfunction DebugLine({ a, b, ...props }: { a: VecLike; b: VecLike } & SVGProps<SVGLineElement>) {\n\treturn (\n\t\t<line\n\t\t\tfill=\"none\"\n\t\t\tstrokeWidth={1}\n\t\t\tstrokeDasharray=\"4,4\"\n\t\t\tstroke=\"green\"\n\t\t\tx1={a.x}\n\t\t\ty1={a.y}\n\t\t\tx2={b.x}\n\t\t\ty2={b.y}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction DebugRoute({ route, ...props }: { route: VecLike[] } & SVGProps<SVGPolylineElement>) {\n\treturn (\n\t\t<polyline\n\t\t\tfill=\"none\"\n\t\t\tstroke=\"darkorchid\"\n\t\t\tstrokeWidth={3}\n\t\t\topacity={0.5}\n\t\t\tpoints={route.map((r) => `${r.x},${r.y}`).join(' ')}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction DebugEdge({\n\tedge,\n\taxis,\n\t...props\n}: {\n\tedge: ElbowArrowEdge | null\n\taxis: 'x' | 'y'\n} & Omit<SVGProps<SVGLineElement>, 'scale'>) {\n\tif (!edge || edge.expanded === null) return null\n\tconst vec = (vec: VecLike) => (axis === 'x' ? { x: vec.y, y: vec.x } : vec)\n\n\treturn (\n\t\t<g>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded, y: edge.cross.min })}\n\t\t\t\tb={vec({ x: edge.expanded, y: edge.cross.max })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded - 4, y: edge.cross.min })}\n\t\t\t\tb={vec({ x: edge.expanded + 4, y: edge.cross.min })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded - 4, y: edge.cross.max })}\n\t\t\t\tb={vec({ x: edge.expanded + 4, y: edge.cross.max })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</g>\n\t)\n}\n\nfunction DebugBox({ box, ...props }: { box: Box } & SVGProps<SVGRectElement>) {\n\treturn (\n\t\t<rect\n\t\t\tx={box.minX}\n\t\t\ty={box.minY}\n\t\t\twidth={box.width}\n\t\t\theight={box.height}\n\t\t\tstrokeDasharray=\"4,4\"\n\t\t\tstrokeWidth={1}\n\t\t\tfill=\"none\"\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n"],"names":["info", "vec"],"mappings":"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"}},
    {"offset": {"line": 3461, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/elbow/elbowArrowSnapLines.tsx"],"sourcesContent":["import {\n\tcomputed,\n\tComputed,\n\tEditor,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { getArrowBindings } from '../shared'\n\n/**\n * A snap line for an elbow arrow segment.\n *\n * This should already belong to ElbowArrowSnapLines establishing an angle of the line.\n */\ninterface ElbowArrowSnapLine {\n\t/** The id of the shape that the snap line starts from. */\n\tstartBoundShapeId: TLShapeId | undefined\n\t/** The id of the shape that the snap line ends at. */\n\tendBoundShapeId: TLShapeId | undefined\n\t/** The perpendicular distance from the snap line to the origin. */\n\tperpDistance: number\n}\n\n/**\n * A map from an angle (0-\u03C0) to a set of snap lines. Snap lines are stored in page space. They're\n * modelled as an angle (the angle of the line itself) and a perpendicular signed distance from the\n * page origin. Each line is effectively infinite in length, but modelling them in this way makes it\n * pretty efficient for us to query for relevant snap lines.\n */\ntype ElbowArrowSnapLines = Map<number, Set<ElbowArrowSnapLine>>\n\nconst snapLinesStore = new WeakCache<Editor, Computed<ElbowArrowSnapLines>>()\n\nexport function getElbowArrowSnapLines(editor: Editor) {\n\treturn snapLinesStore\n\t\t.get(editor, (editor) => {\n\t\t\tconst currentSelectedArrowShape = computed('current selected arrow shape', () => {\n\t\t\t\tconst shape = editor.getOnlySelectedShape()\n\t\t\t\tif (!shape || !editor.isShapeOfType(shape, 'arrow')) return null\n\t\t\t\treturn shape.id\n\t\t\t})\n\n\t\t\tconst unselectedArrowShapeIds = editor.store.query.ids('shape', () => {\n\t\t\t\tconst activeArrowShapeId = currentSelectedArrowShape.get()\n\t\t\t\tif (!activeArrowShapeId) return { type: { eq: 'arrow' } } as const\n\t\t\t\treturn {\n\t\t\t\t\ttype: { eq: 'arrow' },\n\t\t\t\t\tid: { neq: activeArrowShapeId },\n\t\t\t\t} as const\n\t\t\t})\n\n\t\t\treturn computed('elbow arrow snap lines', () => {\n\t\t\t\t// the result is a map from angle (0-\u03C0), to a set of single-axis co-ordinates. For\n\t\t\t\t// example, if a line from (0, 1) to (1, 1) is found (ie a horizontal line at y-coord 1),\n\t\t\t\t// we'll add an entry to the map with the key 0 (horizontal), and the set containing 1.\n\t\t\t\tconst result = new Map<number, Set<ElbowArrowSnapLine>>()\n\n\t\t\t\tconst currentPageShapeIds = editor.getCurrentPageShapeIds()\n\t\t\t\tconst viewportBounds = editor.getViewportPageBounds()\n\n\t\t\t\tfor (const id of unselectedArrowShapeIds.get()) {\n\t\t\t\t\tif (!currentPageShapeIds.has(id)) continue\n\n\t\t\t\t\tconst shape = editor.getShape<TLArrowShape>(id)\n\t\t\t\t\tif (shape?.type !== 'arrow') continue\n\n\t\t\t\t\tconst shapeBounds = editor.getShapePageBounds(id)\n\t\t\t\t\tif (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue\n\n\t\t\t\t\tconst bindings = getArrowBindings(editor, shape)\n\t\t\t\t\tconst pageTransform = editor.getShapePageTransform(id)\n\t\t\t\t\tif (!pageTransform) continue\n\n\t\t\t\t\tconst geometry = editor.getShapeGeometry(id)\n\n\t\t\t\t\tconst pageVertices = pageTransform.applyToPoints(geometry.vertices)\n\n\t\t\t\t\tfor (let i = 1; i < pageVertices.length; i++) {\n\t\t\t\t\t\tconst prev = pageVertices[i - 1]\n\t\t\t\t\t\tconst curr = pageVertices[i]\n\n\t\t\t\t\t\tlet angle = Vec.Angle(prev, curr)\n\n\t\t\t\t\t\t// we don't care if the angle is going \"up\" or \"down\" - so we only care\n\t\t\t\t\t\t// about the 0-\u03C0 range\n\t\t\t\t\t\tif (angle < 0) angle += Math.PI\n\n\t\t\t\t\t\tlet set = result.get(angle)\n\t\t\t\t\t\tif (!set) {\n\t\t\t\t\t\t\tset = new Set()\n\t\t\t\t\t\t\tresult.set(angle, set)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst perpDistance = perpDistanceToLineAngle(prev, angle)\n\n\t\t\t\t\t\tset.add({\n\t\t\t\t\t\t\tperpDistance,\n\t\t\t\t\t\t\tstartBoundShapeId: bindings.start?.toId,\n\t\t\t\t\t\t\tendBoundShapeId: bindings.end?.toId,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t})\n\t\t})\n\t\t.get()\n}\n\n/**\n * Return the signed distance from the origin to a point on a line of angle `lineAngle` that passes\n * through the point `pointOnLine`.\n */\nexport function perpDistanceToLineAngle(pointOnLine: VecLike, lineAngle: number): number {\n\t// The perpendicular unit vector to the line direction\n\tconst perpDir = Vec.FromAngle(lineAngle).per()\n\t// Project the point onto the perpendicular vector\n\treturn Vec.Dpr(pointOnLine, perpDir)\n}\n\n/**\n * Return the signed distance from the origin to the line segment defined by `A` and `B`.\n */\nexport function perpDistanceToLine(A: VecLike, B: VecLike): number {\n\treturn perpDistanceToLineAngle(A, Vec.Angle(A, B))\n}\n"],"names":["editor"],"mappings":";;;;;;;;;;;AAAA;AAUA,SAAS,wBAAwB;;;AAwBjC,MAAM,iBAAiB,IAAI,yNAAA,CAAiD;AAErE,SAAS,uBAAuB,MAAA,EAAgB;IACtD,OAAO,eACL,GAAA,CAAI,QAAQ,CAACA,YAAW;QACxB,MAAM,gCAA4B,wNAAA,EAAS,gCAAgC,MAAM;YAChF,MAAM,QAAQA,QAAO,oBAAA,CAAqB;YAC1C,IAAI,CAAC,SAAS,CAACA,QAAO,aAAA,CAAc,OAAO,OAAO,EAAG,CAAA,OAAO;YAC5D,OAAO,MAAM,EAAA;QACd,CAAC;QAED,MAAM,0BAA0BA,QAAO,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,SAAS,MAAM;YACrE,MAAM,qBAAqB,0BAA0B,GAAA,CAAI;YACzD,IAAI,CAAC,mBAAoB,CAAA,OAAO;gBAAE,MAAM;oBAAE,IAAI;gBAAQ;YAAE;YACxD,OAAO;gBACN,MAAM;oBAAE,IAAI;gBAAQ;gBACpB,IAAI;oBAAE,KAAK;gBAAmB;YAC/B;QACD,CAAC;QAED,WAAO,wNAAA,EAAS,0BAA0B,MAAM;YAI/C,MAAM,SAAS,aAAA,GAAA,IAAI,IAAqC;YAExD,MAAM,sBAAsBA,QAAO,sBAAA,CAAuB;YAC1D,MAAM,iBAAiBA,QAAO,qBAAA,CAAsB;YAEpD,KAAA,MAAW,MAAM,wBAAwB,GAAA,CAAI,EAAG;gBAC/C,IAAI,CAAC,oBAAoB,GAAA,CAAI,EAAE,EAAG,CAAA;gBAElC,MAAM,QAAQA,QAAO,QAAA,CAAuB,EAAE;gBAC9C,IAAI,OAAO,SAAS,QAAS,CAAA;gBAE7B,MAAM,cAAcA,QAAO,kBAAA,CAAmB,EAAE;gBAChD,IAAI,CAAC,eAAe,CAAC,eAAe,QAAA,CAAS,WAAW,EAAG,CAAA;gBAE3D,MAAM,eAAW,gPAAA,EAAiBA,SAAQ,KAAK;gBAC/C,MAAM,gBAAgBA,QAAO,qBAAA,CAAsB,EAAE;gBACrD,IAAI,CAAC,cAAe,CAAA;gBAEpB,MAAM,WAAWA,QAAO,gBAAA,CAAiB,EAAE;gBAE3C,MAAM,eAAe,cAAc,aAAA,CAAc,SAAS,QAAQ;gBAElE,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,IAAK;oBAC7C,MAAM,OAAO,YAAA,CAAa,IAAI,CAAC,CAAA;oBAC/B,MAAM,OAAO,YAAA,CAAa,CAAC,CAAA;oBAE3B,IAAI,QAAQ,uOAAA,CAAI,KAAA,CAAM,MAAM,IAAI;oBAIhC,IAAI,QAAQ,EAAG,CAAA,SAAS,KAAK,EAAA;oBAE7B,IAAI,MAAM,OAAO,GAAA,CAAI,KAAK;oBAC1B,IAAI,CAAC,KAAK;wBACT,MAAM,aAAA,GAAA,IAAI,IAAI;wBACd,OAAO,GAAA,CAAI,OAAO,GAAG;oBACtB;oBAEA,MAAM,eAAe,wBAAwB,MAAM,KAAK;oBAExD,IAAI,GAAA,CAAI;wBACP;wBACA,mBAAmB,SAAS,KAAA,EAAO;wBACnC,iBAAiB,SAAS,GAAA,EAAK;oBAChC,CAAC;gBACF;YACD;YAEA,OAAO;QACR,CAAC;IACF,CAAC,EACA,GAAA,CAAI;AACP;AAMO,SAAS,wBAAwB,WAAA,EAAsB,SAAA,EAA2B;IAExF,MAAM,UAAU,uOAAA,CAAI,SAAA,CAAU,SAAS,EAAE,GAAA,CAAI;IAE7C,OAAO,uOAAA,CAAI,GAAA,CAAI,aAAa,OAAO;AACpC;AAKO,SAAS,mBAAmB,CAAA,EAAY,CAAA,EAAoB;IAClE,OAAO,wBAAwB,GAAG,uOAAA,CAAI,KAAA,CAAM,GAAG,CAAC,CAAC;AAClD"}},
    {"offset": {"line": 3550, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx"],"sourcesContent":["import {\n\tArc2d,\n\tBox,\n\tEMPTY_ARRAY,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tGroup2d,\n\tIndexKey,\n\tPI2,\n\tPolyline2d,\n\tRectangle2d,\n\tSVGContainer,\n\tShapeUtil,\n\tSvgExportContext,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLArrowShapeProps,\n\tTLHandle,\n\tTLHandleDragInfo,\n\tTLResizeInfo,\n\tTLShapePartial,\n\tTLShapeUtilCanBeLaidOutOpts,\n\tTLShapeUtilCanBindOpts,\n\tTLShapeUtilCanvasSvgDef,\n\tVec,\n\tWeakCache,\n\tarrowShapeMigrations,\n\tarrowShapeProps,\n\tclamp,\n\tdebugFlags,\n\texhaustiveSwitchError,\n\tgetColorValue,\n\tgetDefaultColorTheme,\n\tgetFontsFromRichText,\n\tinvLerp,\n\tlerp,\n\tmapObjectMapValues,\n\tmaybeSnapToGrid,\n\tstructuredClone,\n\ttoDomPrecision,\n\ttoRichText,\n\ttrack,\n\tuseEditor,\n\tuseIsEditing,\n\tuseSharedSafeId,\n} from '@tldraw/editor'\nimport React, { useMemo } from 'react'\nimport { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'\nimport { isEmptyRichText, renderPlaintextFromRichText } from '../../utils/text/richText'\nimport { PathBuilder } from '../shared/PathBuilder'\nimport { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'\nimport { ShapeFill } from '../shared/ShapeFill'\nimport { ARROW_LABEL_PADDING, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'\nimport { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { useEfficientZoomThreshold } from '../shared/useEfficientZoomThreshold'\nimport { getArrowBodyPath, getArrowBodyPathBuilder, getArrowHandlePath } from './ArrowPath'\nimport { ArrowShapeOptions } from './arrow-types'\nimport {\n\tgetArrowLabelDefaultPosition,\n\tgetArrowLabelFontSize,\n\tgetArrowLabelPosition,\n} from './arrowLabel'\nimport { updateArrowTargetState } from './arrowTargetState'\nimport { getArrowheadPathForType } from './arrowheads'\nimport { ElbowArrowDebug } from './elbow/ElbowArrowDebug'\nimport { ElbowArrowAxes } from './elbow/definitions'\nimport { getElbowArrowSnapLines, perpDistanceToLineAngle } from './elbow/elbowArrowSnapLines'\nimport {\n\tTLArrowBindings,\n\tcreateOrUpdateArrowBinding,\n\tgetArrowBindings,\n\tgetArrowInfo,\n\tgetArrowTerminalsInArrowSpace,\n\tremoveArrowBinding,\n} from './shared'\n\nenum ArrowHandles {\n\tStart = 'start',\n\tMiddle = 'middle',\n\tEnd = 'end',\n}\n\n/** @public */\nexport class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {\n\tstatic override type = 'arrow' as const\n\tstatic override props = arrowShapeProps\n\tstatic override migrations = arrowShapeMigrations\n\n\toverride options: ArrowShapeOptions = {\n\t\texpandElbowLegLength: {\n\t\t\ts: 28,\n\t\t\tm: 36,\n\t\t\tl: 44,\n\t\t\txl: 66,\n\t\t},\n\t\tminElbowLegLength: {\n\t\t\ts: STROKE_SIZES.s * 3,\n\t\t\tm: STROKE_SIZES.m * 3,\n\t\t\tl: STROKE_SIZES.l * 3,\n\t\t\txl: STROKE_SIZES.xl * 3,\n\t\t},\n\t\tminElbowHandleDistance: 16,\n\n\t\tarcArrowCenterSnapDistance: 16,\n\t\telbowArrowCenterSnapDistance: 24,\n\t\telbowArrowEdgeSnapDistance: 20,\n\t\telbowArrowPointSnapDistance: 24,\n\t\telbowArrowAxisSnapDistance: 16,\n\n\t\tlabelCenterSnapDistance: 10,\n\n\t\telbowMidpointSnapDistance: 10,\n\t\telbowMinSegmentLengthToShowMidpointHandle: 20,\n\n\t\thoverPreciseTimeout: 600,\n\t\tpointingPreciseTimeout: 320,\n\t\tshouldBeExact(editor: Editor) {\n\t\t\treturn editor.inputs.getAltKey()\n\t\t},\n\t\tshouldIgnoreTargets(editor: Editor) {\n\t\t\treturn editor.inputs.getCtrlKey()\n\t\t},\n\t\tshowTextOutline: true,\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\toverride canBind({ toShape }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {\n\t\t// bindings can go from arrows to shapes, but not from shapes to arrows\n\t\treturn toShape.type !== 'arrow'\n\t}\n\toverride canSnap() {\n\t\treturn false\n\t}\n\toverride hideResizeHandles() {\n\t\treturn true\n\t}\n\toverride hideRotateHandle() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsBg() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\toverride hideInMinimap() {\n\t\treturn true\n\t}\n\n\toverride canBeLaidOut(shape: TLArrowShape, info: TLShapeUtilCanBeLaidOutOpts) {\n\t\tif (info.type === 'flip') {\n\t\t\t// If we don't have this then the flip will be non-idempotent; that is, the flip will be multipotent, varipotent, or perhaps even omni-potent... and we can't have that\n\t\t\tconst bindings = getArrowBindings(this.editor, shape)\n\t\t\tconst { start, end } = bindings\n\t\t\tconst { shapes = [] } = info\n\t\t\tif (start && !shapes.find((s) => s.id === start.toId)) return false\n\t\t\tif (end && !shapes.find((s) => s.id === end.toId)) return false\n\t\t}\n\t\treturn true\n\t}\n\n\toverride getFontFaces(shape: TLArrowShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) return EMPTY_ARRAY\n\n\t\treturn getFontsFromRichText(this.editor, shape.props.richText, {\n\t\t\tfamily: `tldraw_${shape.props.font}`,\n\t\t\tweight: 'normal',\n\t\t\tstyle: 'normal',\n\t\t})\n\t}\n\n\toverride getDefaultProps(): TLArrowShape['props'] {\n\t\treturn {\n\t\t\tkind: 'arc',\n\t\t\telbowMidPoint: 0.5,\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tfill: 'none',\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tbend: 0,\n\t\t\tstart: { x: 0, y: 0 },\n\t\t\tend: { x: 2, y: 0 },\n\t\t\tarrowheadStart: 'none',\n\t\t\tarrowheadEnd: 'arrow',\n\t\t\trichText: toRichText(''),\n\t\t\tlabelPosition: 0.5,\n\t\t\tfont: 'draw',\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLArrowShape) {\n\t\tconst isEditing = this.editor.getEditingShapeId() === shape.id\n\t\tconst info = getArrowInfo(this.editor, shape)!\n\n\t\tconst debugGeom: Geometry2d[] = []\n\n\t\tconst bodyGeom =\n\t\t\tinfo.type === 'straight'\n\t\t\t\t? new Edge2d({\n\t\t\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t\t\t})\n\t\t\t\t: info.type === 'arc'\n\t\t\t\t\t? new Arc2d({\n\t\t\t\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t\t\t\t})\n\t\t\t\t\t: new Polyline2d({ points: info.route.points })\n\n\t\tlet labelGeom\n\t\tif (isEditing || !isEmptyRichText(shape.props.richText)) {\n\t\t\tconst labelPosition = getArrowLabelPosition(this.editor, shape)\n\t\t\tif (debugFlags.debugGeometry.get()) {\n\t\t\t\tdebugGeom.push(...labelPosition.debugGeom)\n\t\t\t}\n\t\t\tlabelGeom = new Rectangle2d({\n\t\t\t\tx: labelPosition.box.x,\n\t\t\t\ty: labelPosition.box.y,\n\t\t\t\twidth: labelPosition.box.w,\n\t\t\t\theight: labelPosition.box.h,\n\t\t\t\tisFilled: true,\n\t\t\t\tisLabel: true,\n\t\t\t})\n\t\t}\n\n\t\treturn new Group2d({\n\t\t\tchildren: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],\n\t\t})\n\t}\n\n\toverride getHandles(shape: TLArrowShape): TLHandle[] {\n\t\tconst info = getArrowInfo(this.editor, shape)!\n\n\t\tconst handles: TLHandle[] = [\n\t\t\t{\n\t\t\t\tid: ArrowHandles.Start,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a1' as IndexKey,\n\t\t\t\tx: info.start.handle.x,\n\t\t\t\ty: info.start.handle.y,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: ArrowHandles.End,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a3' as IndexKey,\n\t\t\t\tx: info.end.handle.x,\n\t\t\t\ty: info.end.handle.y,\n\t\t\t},\n\t\t]\n\n\t\tif (shape.props.kind === 'arc' && (info.type === 'straight' || info.type === 'arc')) {\n\t\t\thandles.push({\n\t\t\t\tid: ArrowHandles.Middle,\n\t\t\t\ttype: 'virtual',\n\t\t\t\tindex: 'a2' as IndexKey,\n\t\t\t\tx: info.middle.x,\n\t\t\t\ty: info.middle.y,\n\t\t\t})\n\t\t}\n\n\t\tif (shape.props.kind === 'elbow' && info.type === 'elbow' && info.route.midpointHandle) {\n\t\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\n\t\t\tconst segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart)\n\t\t\tconst segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd)\n\t\t\tconst segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getEfficientZoomLevel()\n\n\t\t\tif (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {\n\t\t\t\thandles.push({\n\t\t\t\t\tid: ArrowHandles.Middle,\n\t\t\t\t\ttype: 'vertex',\n\t\t\t\t\tindex: 'a2' as IndexKey,\n\t\t\t\t\tx: info.route.midpointHandle.point.x,\n\t\t\t\t\ty: info.route.midpointHandle.point.y,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn handles\n\t}\n\n\toverride getText(shape: TLArrowShape) {\n\t\treturn renderPlaintextFromRichText(this.editor, shape.props.richText)\n\t}\n\n\toverride onHandleDrag(shape: TLArrowShape, info: TLHandleDragInfo<TLArrowShape>) {\n\t\tconst handleId = info.handle.id as ArrowHandles\n\t\tswitch (handleId) {\n\t\t\tcase ArrowHandles.Middle:\n\t\t\t\tswitch (shape.props.kind) {\n\t\t\t\t\tcase 'arc':\n\t\t\t\t\t\treturn this.onArcMidpointHandleDrag(shape, info)\n\t\t\t\t\tcase 'elbow':\n\t\t\t\t\t\treturn this.onElbowMidpointHandleDrag(shape, info)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\texhaustiveSwitchError(shape.props.kind)\n\t\t\t\t}\n\t\t\tcase ArrowHandles.Start:\n\t\t\tcase ArrowHandles.End:\n\t\t\t\treturn this.onTerminalHandleDrag(shape, info, handleId)\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(handleId)\n\t\t}\n\t}\n\n\tprivate onArcMidpointHandleDrag(shape: TLArrowShape, { handle }: TLHandleDragInfo<TLArrowShape>) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\t// Bending the arrow...\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\n\t\tconst delta = Vec.Sub(end, start)\n\t\tconst v = Vec.Per(delta)\n\n\t\tconst med = Vec.Med(end, start)\n\t\tconst A = Vec.Sub(med, v)\n\t\tconst B = Vec.Add(med, v)\n\n\t\tconst point = Vec.NearestPointOnLineSegment(A, B, handle, false)\n\t\tlet bend = Vec.Dist(point, med)\n\t\tif (Vec.Clockwise(point, end, med)) bend *= -1\n\t\treturn { id: shape.id, type: shape.type, props: { bend } }\n\t}\n\n\tprivate onElbowMidpointHandleDrag(\n\t\tshape: TLArrowShape,\n\t\t{ handle }: TLHandleDragInfo<TLArrowShape>\n\t) {\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (info?.type !== 'elbow') return\n\n\t\tconst shapeToPageTransform = this.editor.getShapePageTransform(shape.id)!\n\t\tconst handlePagePoint = shapeToPageTransform.applyToPoint(handle)\n\t\tconst axisName = info.route.midpointHandle?.axis\n\t\tif (!axisName) return\n\t\tconst axis = ElbowArrowAxes[axisName]\n\n\t\tconst midRange = info.elbow[axis.midRange]\n\t\tif (!midRange) return\n\n\t\t// We're snapping against a list of parallel lines. The way we do this is to calculate the\n\t\t// angle of the line we're snapping to...\n\t\tlet angle = Vec.Angle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(0, 0)),\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(0, 1))\n\t\t)\n\t\tif (angle < 0) angle += Math.PI\n\n\t\t// ...then calculate the perpendicular distance from the origin to the (infinite) line in\n\t\t// question. This returns a signed distance - lines \"behind\" the origin are negative.\n\t\tconst handlePoint = perpDistanceToLineAngle(handlePagePoint, angle)\n\n\t\t// As we're only ever moving along one dimension, we can use this perpendicular distance for\n\t\t// all of our snapping calculations.\n\t\tconst loPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),\n\t\t\tangle\n\t\t)\n\t\tconst hiPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),\n\t\t\tangle\n\t\t)\n\n\t\t// we want to snap to certain points. the maximum distance at which a snap will occur is\n\t\t// relative to the zoom level:\n\t\tconst maxSnapDistance =\n\t\t\tthis.options.elbowMidpointSnapDistance / this.editor.getEfficientZoomLevel()\n\n\t\t// we snap to the midpoint of the range by default\n\t\tconst midPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),\n\t\t\tangle\n\t\t)\n\n\t\tlet snapPoint = midPoint\n\t\tlet snapDistance = Math.abs(midPoint - handlePoint)\n\n\t\t// then we check all the other arrows that are on-screen.\n\t\tfor (const [snapAngle, snapLines] of getElbowArrowSnapLines(this.editor)) {\n\t\t\tconst { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle)\n\t\t\tif (isParallel || isFlippedParallel) {\n\t\t\t\tfor (const snapLine of snapLines) {\n\t\t\t\t\tconst doesShareStartIntersection =\n\t\t\t\t\t\tsnapLine.startBoundShapeId &&\n\t\t\t\t\t\t(snapLine.startBoundShapeId === info.bindings.start?.toId ||\n\t\t\t\t\t\t\tsnapLine.startBoundShapeId === info.bindings.end?.toId)\n\n\t\t\t\t\tconst doesShareEndIntersection =\n\t\t\t\t\t\tsnapLine.endBoundShapeId &&\n\t\t\t\t\t\t(snapLine.endBoundShapeId === info.bindings.start?.toId ||\n\t\t\t\t\t\t\tsnapLine.endBoundShapeId === info.bindings.end?.toId)\n\n\t\t\t\t\tif (!doesShareStartIntersection && !doesShareEndIntersection) continue\n\n\t\t\t\t\tconst point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance\n\t\t\t\t\tconst distance = Math.abs(point - handlePoint)\n\t\t\t\t\tif (distance < snapDistance) {\n\t\t\t\t\t\tsnapPoint = point\n\t\t\t\t\t\tsnapDistance = distance\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (snapDistance > maxSnapDistance) {\n\t\t\tsnapPoint = handlePoint\n\t\t}\n\n\t\tconst newMid = clamp(invLerp(loPoint, hiPoint, snapPoint), 0, 1)\n\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: {\n\t\t\t\telbowMidPoint: newMid,\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate onTerminalHandleDrag(\n\t\tshape: TLArrowShape,\n\t\t{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>,\n\t\thandleId: ArrowHandles.Start | ArrowHandles.End\n\t) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\tconst update: TLShapePartial<TLArrowShape> = { id: shape.id, type: 'arrow', props: {} }\n\n\t\tconst currentBinding = bindings[handleId]\n\n\t\tconst oppositeHandleId = handleId === ArrowHandles.Start ? ArrowHandles.End : ArrowHandles.Start\n\t\tconst oppositeBinding = bindings[oppositeHandleId]\n\n\t\tconst targetInfo = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle),\n\t\t\tarrow: shape,\n\t\t\tisPrecise: isPrecise,\n\t\t\tcurrentBinding,\n\t\t\toppositeBinding,\n\t\t})\n\n\t\tif (!targetInfo) {\n\t\t\t// todo: maybe double check that this isn't equal to the other handle too?\n\t\t\tremoveArrowBinding(this.editor, shape, handleId)\n\t\t\tconst newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)\n\t\t\tupdate.props![handleId] = {\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t}\n\t\t\treturn update\n\t\t}\n\n\t\t// we've got a target! the handle is being dragged over a shape, bind to it\n\t\tconst bindingProps: TLArrowBindingProps = {\n\t\t\tterminal: handleId,\n\t\t\tnormalizedAnchor: targetInfo.normalizedAnchor,\n\t\t\tisPrecise: targetInfo.isPrecise,\n\t\t\tisExact: targetInfo.isExact,\n\t\t\tsnap: targetInfo.snap,\n\t\t}\n\n\t\tcreateOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps)\n\n\t\tconst newBindings = getArrowBindings(this.editor, shape)\n\t\tif (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {\n\t\t\tif (\n\t\t\t\tVec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)\n\t\t\t) {\n\t\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {\n\t\t\t\t\t...newBindings.end.props,\n\t\t\t\t\tnormalizedAnchor: {\n\t\t\t\t\t\tx: newBindings.end.props.normalizedAnchor.x + 0.05,\n\t\t\t\t\t\ty: newBindings.end.props.normalizedAnchor.y,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn update\n\t}\n\n\toverride onTranslateStart(shape: TLArrowShape) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\t// ...if the user is dragging ONLY this arrow, for elbow shapes, we can't maintain the bindings well just yet so we remove them entirely\n\t\tif (shape.props.kind === 'elbow' && this.editor.getOnlySelectedShapeId() === shape.id) {\n\t\t\tconst info = getArrowInfo(this.editor, shape)\n\t\t\tif (!info) return\n\t\t\tconst update: TLShapePartial<TLArrowShape> = { id: shape.id, type: 'arrow', props: {} }\n\t\t\tif (bindings.start) {\n\t\t\t\tupdate.props!.start = { x: info.start.point.x, y: info.start.point.y }\n\t\t\t\tremoveArrowBinding(this.editor, shape, 'start')\n\t\t\t}\n\t\t\tif (bindings.end) {\n\t\t\t\tupdate.props!.end = { x: info.end.point.x, y: info.end.point.y }\n\t\t\t\tremoveArrowBinding(this.editor, shape, 'end')\n\t\t\t}\n\t\t\treturn update\n\t\t}\n\n\t\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\n\t\t// If at least one bound shape is in the selection, do nothing;\n\t\t// If no bound shapes are in the selection, unbind any bound shapes\n\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\n\t\tif (\n\t\t\t(bindings.start &&\n\t\t\t\t(selectedShapeIds.includes(bindings.start.toId) ||\n\t\t\t\t\tthis.editor.isAncestorSelected(bindings.start.toId))) ||\n\t\t\t(bindings.end &&\n\t\t\t\t(selectedShapeIds.includes(bindings.end.toId) ||\n\t\t\t\t\tthis.editor.isAncestorSelected(bindings.end.toId)))\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\t// When we start translating shapes, record where their bindings were in page space so we\n\t\t// can maintain them as we translate the arrow\n\t\tshapeAtTranslationStart.set(shape, {\n\t\t\tpagePosition: shapePageTransform.applyToPoint(shape),\n\t\t\tterminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {\n\t\t\t\tconst binding = bindings[terminalName]\n\t\t\t\tif (!binding) return null\n\t\t\t\treturn {\n\t\t\t\t\tbinding,\n\t\t\t\t\tshapePosition: point,\n\t\t\t\t\tpagePosition: shapePageTransform.applyToPoint(point),\n\t\t\t\t}\n\t\t\t}),\n\t\t})\n\n\t\t// update arrow terminal bindings eagerly to make sure the arrows unbind nicely when translating\n\t\tif (bindings.start) {\n\t\t\tupdateArrowTerminal({\n\t\t\t\teditor: this.editor,\n\t\t\t\tarrow: shape,\n\t\t\t\tterminal: 'start',\n\t\t\t\tuseHandle: true,\n\t\t\t})\n\t\t\tshape = this.editor.getShape(shape.id) as TLArrowShape\n\t\t}\n\t\tif (bindings.end) {\n\t\t\tupdateArrowTerminal({\n\t\t\t\teditor: this.editor,\n\t\t\t\tarrow: shape,\n\t\t\t\tterminal: 'end',\n\t\t\t\tuseHandle: true,\n\t\t\t})\n\t\t}\n\n\t\tfor (const handleName of [ArrowHandles.Start, ArrowHandles.End] as const) {\n\t\t\tconst binding = bindings[handleName]\n\t\t\tif (!binding) continue\n\n\t\t\tthis.editor.updateBinding({\n\t\t\t\t...binding,\n\t\t\t\tprops: { ...binding.props, isPrecise: true },\n\t\t\t})\n\t\t}\n\n\t\treturn\n\t}\n\n\toverride onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {\n\t\tconst atTranslationStart = shapeAtTranslationStart.get(initialShape)\n\t\tif (!atTranslationStart) return\n\n\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\t\tconst pageDelta = Vec.Sub(\n\t\t\tshapePageTransform.applyToPoint(shape),\n\t\t\tatTranslationStart.pagePosition\n\t\t)\n\n\t\tfor (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {\n\t\t\tif (!terminalBinding) continue\n\n\t\t\tconst newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5))\n\t\t\tconst newTarget = this.editor.getShapeAtPoint(newPagePoint, {\n\t\t\t\thitInside: true,\n\t\t\t\thitFrameInside: true,\n\t\t\t\tmargin: 0,\n\t\t\t\tfilter: (targetShape) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t!targetShape.isLocked &&\n\t\t\t\t\t\tthis.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tif (newTarget?.id === terminalBinding.binding.toId) {\n\t\t\t\tconst targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds)\n\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint)\n\t\t\t\tconst normalizedAnchor = {\n\t\t\t\t\tx: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,\n\t\t\t\t\ty: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,\n\t\t\t\t}\n\t\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, newTarget.id, {\n\t\t\t\t\t...terminalBinding.binding.props,\n\t\t\t\t\tnormalizedAnchor,\n\t\t\t\t\tisPrecise: true,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tremoveArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()\n\n\toverride onResize(shape: TLArrowShape, info: TLResizeInfo<TLArrowShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst bindings = this._resizeInitialBindings.get(shape, () =>\n\t\t\tgetArrowBindings(this.editor, shape)\n\t\t)\n\t\tconst terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\n\t\tconst { start, end } = structuredClone<TLArrowShape['props']>(shape.props)\n\t\tlet { bend } = shape.props\n\n\t\t// Rescale start handle if it's not bound to a shape\n\t\tif (!bindings.start) {\n\t\t\tstart.x = terminals.start.x * scaleX\n\t\t\tstart.y = terminals.start.y * scaleY\n\t\t}\n\n\t\t// Rescale end handle if it's not bound to a shape\n\t\tif (!bindings.end) {\n\t\t\tend.x = terminals.end.x * scaleX\n\t\t\tend.y = terminals.end.y * scaleY\n\t\t}\n\n\t\t// todo: we should only change the normalized anchor positions\n\t\t// of the shape's handles if the bound shape is also being resized\n\n\t\tconst mx = Math.abs(scaleX)\n\t\tconst my = Math.abs(scaleY)\n\n\t\tconst startNormalizedAnchor = bindings?.start\n\t\t\t? Vec.From(bindings.start.props.normalizedAnchor)\n\t\t\t: null\n\t\tconst endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null\n\n\t\tif (scaleX < 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.x = 1 - startNormalizedAnchor.x\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.x = 1 - endNormalizedAnchor.x\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.y = 1 - startNormalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.y = 1 - endNormalizedAnchor.y\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\t\t} else if (scaleX < 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.x = 1 - startNormalizedAnchor.x\n\t\t\t\tstartNormalizedAnchor.y = 1 - startNormalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.x = 1 - endNormalizedAnchor.x\n\t\t\t\tendNormalizedAnchor.y = 1 - endNormalizedAnchor.y\n\t\t\t}\n\t\t}\n\n\t\tif (bindings.start && startNormalizedAnchor) {\n\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {\n\t\t\t\t...bindings.start.props,\n\t\t\t\tnormalizedAnchor: startNormalizedAnchor.toJson(),\n\t\t\t})\n\t\t}\n\t\tif (bindings.end && endNormalizedAnchor) {\n\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {\n\t\t\t\t...bindings.end.props,\n\t\t\t\tnormalizedAnchor: endNormalizedAnchor.toJson(),\n\t\t\t})\n\t\t}\n\n\t\tconst next = {\n\t\t\tprops: {\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tbend,\n\t\t\t},\n\t\t}\n\n\t\treturn next\n\t}\n\n\toverride onDoubleClickHandle(\n\t\tshape: TLArrowShape,\n\t\thandle: TLHandle\n\t): TLShapePartial<TLArrowShape> | void {\n\t\tswitch (handle.id) {\n\t\t\tcase ArrowHandles.Start: {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase ArrowHandles.End: {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcomponent(shape: TLArrowShape) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\tconst shouldDisplayHandles =\n\t\t\tthis.editor.isInAny(\n\t\t\t\t'select.idle',\n\t\t\t\t'select.pointing_handle',\n\t\t\t\t'select.dragging_handle',\n\t\t\t\t'select.translating',\n\t\t\t\t'arrow.dragging'\n\t\t\t) && !this.editor.getIsReadonly()\n\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (!info?.isValid) return null\n\n\t\tconst labelPosition = getArrowLabelPosition(this.editor, shape)\n\t\tconst isSelected = shape.id === this.editor.getOnlySelectedShapeId()\n\t\tconst isEditing = this.editor.getEditingShapeId() === shape.id\n\t\tconst showArrowLabel = isEditing || !isEmptyRichText(shape.props.richText)\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>\n\t\t\t\t\t<ArrowSvg\n\t\t\t\t\t\tshape={shape}\n\t\t\t\t\t\tshouldDisplayHandles={shouldDisplayHandles && onlySelectedShape?.id === shape.id}\n\t\t\t\t\t/>\n\t\t\t\t\t{shape.props.kind === 'elbow' && debugFlags.debugElbowArrows.get() && (\n\t\t\t\t\t\t<ElbowArrowDebug arrow={shape} />\n\t\t\t\t\t)}\n\t\t\t\t</SVGContainer>\n\t\t\t\t{showArrowLabel && (\n\t\t\t\t\t<RichTextLabel\n\t\t\t\t\t\tshapeId={shape.id}\n\t\t\t\t\t\ttype=\"arrow\"\n\t\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\t\tfontSize={getArrowLabelFontSize(shape)}\n\t\t\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\t\t\talign=\"middle\"\n\t\t\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\t\t\tlabelColor={getColorValue(theme, shape.props.labelColor, 'solid')}\n\t\t\t\t\t\trichText={shape.props.richText}\n\t\t\t\t\t\ttextWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}\n\t\t\t\t\t\tisSelected={isSelected}\n\t\t\t\t\t\tpadding={0}\n\t\t\t\t\t\tshowTextOutline={this.options.showTextOutline}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\ttransform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLArrowShape) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst isEditing = useIsEditing(shape.id)\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst clipPathId = useSharedSafeId(shape.id + '_clip')\n\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (!info) return null\n\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)\n\t\tconst geometry = this.editor.getShapeGeometry<Group2d>(shape)\n\t\tconst bounds = geometry.bounds\n\t\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\n\t\tconst labelGeometry = isEditing || !isEmpty ? (geometry.children[1] as Rectangle2d) : null\n\n\t\tif (Vec.Equals(start, end)) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst includeClipPath =\n\t\t\t(as && info.start.arrowhead !== 'arrow') ||\n\t\t\t(ae && info.end.arrowhead !== 'arrow') ||\n\t\t\t!!labelGeometry\n\n\t\tconst labelBounds = labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0)\n\n\t\tif (isEditing && labelGeometry) {\n\t\t\treturn (\n\t\t\t\t<rect\n\t\t\t\t\tx={toDomPrecision(labelBounds.x)}\n\t\t\t\t\ty={toDomPrecision(labelBounds.y)}\n\t\t\t\t\twidth={labelBounds.w}\n\t\t\t\t\theight={labelBounds.h}\n\t\t\t\t\trx={3.5 * shape.props.scale}\n\t\t\t\t\try={3.5 * shape.props.scale}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\t\tconst clipStartArrowhead = !(\n\t\t\tinfo.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'\n\t\t)\n\t\tconst clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\n\t\treturn (\n\t\t\t<g>\n\t\t\t\t{includeClipPath && (\n\t\t\t\t\t<defs>\n\t\t\t\t\t\t<ArrowClipPath\n\t\t\t\t\t\t\tradius={3.5 * shape.props.scale}\n\t\t\t\t\t\t\thasText={!isEmpty}\n\t\t\t\t\t\t\tbounds={bounds}\n\t\t\t\t\t\t\tlabelBounds={labelBounds}\n\t\t\t\t\t\t\tas={clipStartArrowhead && as ? as : ''}\n\t\t\t\t\t\t\tae={clipEndArrowhead && ae ? ae : ''}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</defs>\n\t\t\t\t)}\n\t\t\t\t<g\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tclipPath: includeClipPath ? `url(#${clipPathId})` : undefined,\n\t\t\t\t\t\tWebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t{includeClipPath && (\n\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\twidth={bounds.width + 200}\n\t\t\t\t\t\t\theight={bounds.height + 200}\n\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{getArrowBodyPath(\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tshape.props.dash === 'draw'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tstyle: 'draw',\n\t\t\t\t\t\t\t\t\trandomSeed: shape.id,\n\t\t\t\t\t\t\t\t\tstrokeWidth: 1,\n\t\t\t\t\t\t\t\t\tpasses: 1,\n\t\t\t\t\t\t\t\t\toffset: 0,\n\t\t\t\t\t\t\t\t\troundness: strokeWidth * 2,\n\t\t\t\t\t\t\t\t\tprops: { strokeWidth: undefined },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: { style: 'solid', strokeWidth: 1, props: { strokeWidth: undefined } }\n\t\t\t\t\t)}\n\t\t\t\t</g>\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t{labelGeometry && (\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={toDomPrecision(labelBounds.x)}\n\t\t\t\t\t\ty={toDomPrecision(labelBounds.y)}\n\t\t\t\t\t\twidth={labelBounds.w}\n\t\t\t\t\t\theight={labelBounds.h}\n\t\t\t\t\t\trx={3.5}\n\t\t\t\t\t\try={3.5}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride useLegacyIndicator() {\n\t\treturn false\n\t}\n\n\toverride getIndicatorPath(shape: TLArrowShape) {\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (!info) return undefined\n\n\t\tconst isEditing = this.editor.getEditingShapeId() === shape.id\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)\n\t\tconst geometry = this.editor.getShapeGeometry<Group2d>(shape)\n\t\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\n\t\tconst labelGeometry = isEditing || !isEmpty ? (geometry.children[1] as Rectangle2d) : null\n\n\t\tif (Vec.Equals(start, end)) return undefined\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\t\t// If editing and has label, just return the label rect\n\t\tif (isEditing && labelGeometry) {\n\t\t\tconst labelBounds = labelGeometry.getBounds()\n\t\t\tconst path = new Path2D()\n\t\t\tpath.roundRect(\n\t\t\t\tlabelBounds.x,\n\t\t\t\tlabelBounds.y,\n\t\t\t\tlabelBounds.w,\n\t\t\t\tlabelBounds.h,\n\t\t\t\t3.5 * shape.props.scale\n\t\t\t)\n\t\t\treturn path\n\t\t}\n\n\t\t// Get arrow body path\n\t\tconst isForceSolid = this.editor.getEfficientZoomLevel() < shape.props.scale * 0.25\n\t\tconst bodyPathBuilder = getArrowBodyPathBuilder(info)\n\t\tconst bodyPath2D = bodyPathBuilder.toPath2D(\n\t\t\tshape.props.dash === 'draw' && !isForceSolid\n\t\t\t\t? {\n\t\t\t\t\t\tstyle: 'draw',\n\t\t\t\t\t\trandomSeed: shape.id,\n\t\t\t\t\t\tstrokeWidth: 1,\n\t\t\t\t\t\tpasses: 1,\n\t\t\t\t\t\toffset: 0,\n\t\t\t\t\t\troundness: strokeWidth * 2,\n\t\t\t\t\t}\n\t\t\t\t: { style: 'solid', strokeWidth: 1 }\n\t\t)\n\n\t\t// Get arrowhead paths\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\t// Check if we need clipping (label or complex arrowheads)\n\t\tconst clipStartArrowhead = !!(as && info.start.arrowhead !== 'arrow')\n\t\tconst clipEndArrowhead = !!(ae && info.end.arrowhead !== 'arrow')\n\t\tconst needsClipping = labelGeometry || clipStartArrowhead || clipEndArrowhead\n\n\t\tif (needsClipping) {\n\t\t\t// Create clip path using evenodd rule\n\t\t\tconst bounds = geometry.bounds\n\t\t\tconst clipPath = new Path2D()\n\n\t\t\t// Outer rectangle (clockwise) - defines the area to keep\n\t\t\tclipPath.rect(bounds.minX - 100, bounds.minY - 100, bounds.width + 200, bounds.height + 200)\n\n\t\t\t// Label cutout (counter-clockwise via roundRect's default winding)\n\t\t\tif (labelGeometry) {\n\t\t\t\tconst labelBounds = labelGeometry.getBounds()\n\t\t\t\tconst radius = 3.5 * shape.props.scale\n\t\t\t\t// Create counter-clockwise rounded rect to cut out the label area\n\t\t\t\t// We need to manually create the path in reverse winding order\n\t\t\t\tconst lb = labelBounds\n\t\t\t\tclipPath.moveTo(lb.x, lb.y + radius)\n\t\t\t\tclipPath.lineTo(lb.x, lb.maxY - radius)\n\t\t\t\tclipPath.arcTo(lb.x, lb.maxY, lb.x + radius, lb.maxY, radius)\n\t\t\t\tclipPath.lineTo(lb.maxX - radius, lb.maxY)\n\t\t\t\tclipPath.arcTo(lb.maxX, lb.maxY, lb.maxX, lb.maxY - radius, radius)\n\t\t\t\tclipPath.lineTo(lb.maxX, lb.y + radius)\n\t\t\t\tclipPath.arcTo(lb.maxX, lb.y, lb.maxX - radius, lb.y, radius)\n\t\t\t\tclipPath.lineTo(lb.x + radius, lb.y)\n\t\t\t\tclipPath.arcTo(lb.x, lb.y, lb.x, lb.y + radius, radius)\n\t\t\t\tclipPath.closePath()\n\t\t\t}\n\n\t\t\t// Add arrowhead paths to clip path if needed\n\t\t\tif (clipStartArrowhead && as) {\n\t\t\t\tclipPath.addPath(new Path2D(as))\n\t\t\t}\n\t\t\tif (clipEndArrowhead && ae) {\n\t\t\t\tclipPath.addPath(new Path2D(ae))\n\t\t\t}\n\n\t\t\t// Additional paths (arrowheads, label rect) to draw after clipped body\n\t\t\tconst additionalPaths: Path2D[] = []\n\t\t\tif (as) additionalPaths.push(new Path2D(as))\n\t\t\tif (ae) additionalPaths.push(new Path2D(ae))\n\t\t\tif (labelGeometry) {\n\t\t\t\tconst labelBounds = labelGeometry.getBounds()\n\t\t\t\tconst labelPath = new Path2D()\n\t\t\t\tlabelPath.roundRect(labelBounds.x, labelBounds.y, labelBounds.w, labelBounds.h, 3.5)\n\t\t\t\tadditionalPaths.push(labelPath)\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpath: bodyPath2D,\n\t\t\t\tclipPath,\n\t\t\t\tadditionalPaths,\n\t\t\t}\n\t\t}\n\n\t\t// No clipping needed - combine all paths into one\n\t\tconst combinedPath = new Path2D()\n\t\tcombinedPath.addPath(bodyPath2D)\n\n\t\tif (as) {\n\t\t\tcombinedPath.addPath(new Path2D(as))\n\t\t}\n\t\tif (ae) {\n\t\t\tcombinedPath.addPath(new Path2D(ae))\n\t\t}\n\n\t\treturn combinedPath\n\t}\n\n\toverride onEditStart(shape: TLArrowShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) {\n\t\t\t// editing text for the first time, so set the position to the default:\n\t\t\tconst labelPosition = getArrowLabelDefaultPosition(this.editor, shape)\n\t\t\tthis.editor.updateShape({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: { labelPosition },\n\t\t\t})\n\t\t}\n\t}\n\n\toverride toSvg(shape: TLArrowShape, ctx: SvgExportContext) {\n\t\tctx.addExportDef(getFillDefForExport(shape.props.fill))\n\t\tconst theme = getDefaultColorTheme(ctx)\n\t\tconst scaleFactor = 1 / shape.props.scale\n\n\t\treturn (\n\t\t\t<g transform={`scale(${scaleFactor})`}>\n\t\t\t\t<ArrowSvg shape={shape} shouldDisplayHandles={false} />\n\t\t\t\t<RichTextSVG\n\t\t\t\t\tfontSize={getArrowLabelFontSize(shape)}\n\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\talign=\"middle\"\n\t\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\t\tlabelColor={getColorValue(theme, shape.props.labelColor, 'solid')}\n\t\t\t\t\trichText={shape.props.richText}\n\t\t\t\t\tbounds={getArrowLabelPosition(this.editor, shape)\n\t\t\t\t\t\t.box.clone()\n\t\t\t\t\t\t.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}\n\t\t\t\t\tpadding={0}\n\t\t\t\t\tshowTextOutline={this.options.showTextOutline}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn [\n\t\t\tgetFillDefForCanvas(),\n\t\t\t{\n\t\t\t\tkey: `arrow:dot`,\n\t\t\t\tcomponent: ArrowheadDotDef,\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: `arrow:cross`,\n\t\t\t\tcomponent: ArrowheadCrossDef,\n\t\t\t},\n\t\t]\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLArrowShape,\n\t\tendShape: TLArrowShape,\n\t\tprogress: number\n\t): TLArrowShapeProps {\n\t\treturn {\n\t\t\t...(progress > 0.5 ? endShape.props : startShape.props),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, progress),\n\t\t\tstart: {\n\t\t\t\tx: lerp(startShape.props.start.x, endShape.props.start.x, progress),\n\t\t\t\ty: lerp(startShape.props.start.y, endShape.props.start.y, progress),\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: lerp(startShape.props.end.x, endShape.props.end.x, progress),\n\t\t\t\ty: lerp(startShape.props.end.y, endShape.props.end.y, progress),\n\t\t\t},\n\t\t\tbend: lerp(startShape.props.bend, endShape.props.bend, progress),\n\t\t\tlabelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),\n\t\t}\n\t}\n}\n\nexport function getArrowLength(editor: Editor, shape: TLArrowShape): number {\n\tconst info = getArrowInfo(editor, shape)!\n\n\treturn info.type === 'straight'\n\t\t? Vec.Dist(info.start.handle, info.end.handle)\n\t\t: info.type === 'arc'\n\t\t\t? Math.abs(info.handleArc.length)\n\t\t\t: info.route.distance\n}\n\nconst ArrowSvg = track(function ArrowSvg({\n\tshape,\n\tshouldDisplayHandles,\n}: {\n\tshape: TLArrowShape\n\tshouldDisplayHandles: boolean\n}) {\n\tconst editor = useEditor()\n\tconst theme = useDefaultColorTheme()\n\tconst info = getArrowInfo(editor, shape)\n\tconst isForceSolid = useEfficientZoomThreshold(shape.props.scale * 0.25)\n\tconst clipPathId = useSharedSafeId(shape.id + '_clip')\n\tconst arrowheadDotId = useSharedSafeId('arrowhead-dot')\n\tconst arrowheadCrossId = useSharedSafeId('arrowhead-cross')\n\tconst isEditing = useIsEditing(shape.id)\n\tconst geometry = editor.getShapeGeometry(shape)\n\tif (!geometry) return null\n\tconst bounds = Box.ZeroFix(geometry.bounds)\n\tconst bindings = getArrowBindings(editor, shape)\n\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\n\tif (!info?.isValid) return null\n\n\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\tlet handlePath: null | React.JSX.Element = null\n\n\tif (shouldDisplayHandles && (bindings.start || bindings.end)) {\n\t\thandlePath = getArrowHandlePath(info, {\n\t\t\tstyle: 'dashed',\n\t\t\tstart: 'skip',\n\t\t\tend: 'skip',\n\t\t\tlengthRatio: 2.5,\n\t\t\tstrokeWidth: 2 / editor.getEfficientZoomLevel(),\n\t\t\tprops: {\n\t\t\t\tclassName: 'tl-arrow-hint',\n\t\t\t\tmarkerStart: bindings.start\n\t\t\t\t\t? bindings.start.props.isExact\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: bindings.start.props.isPrecise\n\t\t\t\t\t\t\t? `url(#${arrowheadCrossId})`\n\t\t\t\t\t\t\t: `url(#${arrowheadDotId})`\n\t\t\t\t\t: '',\n\t\t\t\tmarkerEnd: bindings.end\n\t\t\t\t\t? bindings.end.props.isExact\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: bindings.end.props.isPrecise\n\t\t\t\t\t\t\t? `url(#${arrowheadCrossId})`\n\t\t\t\t\t\t\t: `url(#${arrowheadDotId})`\n\t\t\t\t\t: '',\n\t\t\t\topacity: 0.16,\n\t\t\t},\n\t\t})\n\t}\n\n\tconst labelPosition = getArrowLabelPosition(editor, shape)\n\n\tconst clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')\n\tconst clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\n\treturn (\n\t\t<>\n\t\t\t{/* Yep */}\n\t\t\t<defs>\n\t\t\t\t<clipPath id={clipPathId}>\n\t\t\t\t\t<ArrowClipPath\n\t\t\t\t\t\tradius={3.5 * shape.props.scale}\n\t\t\t\t\t\thasText={isEditing || !isEmpty}\n\t\t\t\t\t\tbounds={bounds}\n\t\t\t\t\t\tlabelBounds={labelPosition.box}\n\t\t\t\t\t\tas={clipStartArrowhead && as ? as : ''}\n\t\t\t\t\t\tae={clipEndArrowhead && ae ? ae : ''}\n\t\t\t\t\t/>\n\t\t\t\t</clipPath>\n\t\t\t</defs>\n\t\t\t<g\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke={getColorValue(theme, shape.props.color, 'solid')}\n\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\tpointerEvents=\"none\"\n\t\t\t>\n\t\t\t\t{handlePath}\n\t\t\t\t<g\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tclipPath: `url(#${clipPathId})`,\n\t\t\t\t\t\tWebkitClipPath: `url(#${clipPathId})`,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={toDomPrecision(bounds.minX - 100)}\n\t\t\t\t\t\ty={toDomPrecision(bounds.minY - 100)}\n\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\topacity={0}\n\t\t\t\t\t/>\n\t\t\t\t\t{getArrowBodyPath(shape, info, {\n\t\t\t\t\t\tstyle: shape.props.dash,\n\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\tforceSolid: isForceSolid,\n\t\t\t\t\t\trandomSeed: shape.id,\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t\t{as && clipStartArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\td={as}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\tfill={shape.props.fill}\n\t\t\t\t\t\tscale={shape.props.scale}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{ae && clipEndArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\td={ae}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\tfill={shape.props.fill}\n\t\t\t\t\t\tscale={shape.props.scale}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t</g>\n\t\t</>\n\t)\n})\n\nfunction ArrowClipPath({\n\tradius,\n\thasText,\n\tbounds,\n\tlabelBounds,\n\tas,\n\tae,\n}: {\n\tradius: number\n\thasText: boolean\n\tbounds: Box\n\tlabelBounds: Box\n\tas: string\n\tae: string\n}) {\n\tconst path = useMemo(() => {\n\t\t// The direction in which we create the different path parts is important, as it determines what gets clipped.\n\t\t// See the description on the directions in the non-zero fill rule example:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#nonzero\n\t\tconst path = new PathBuilder()\n\n\t\t// We create this one in the clockwise direction\n\t\tpath\n\t\t\t.moveTo(bounds.left - 100, bounds.top - 100)\n\t\t\t.lineTo(bounds.right + 100, bounds.top - 100)\n\t\t\t.lineTo(bounds.right + 100, bounds.bottom + 100)\n\t\t\t.lineTo(bounds.left - 100, bounds.bottom + 100)\n\t\t\t.close()\n\n\t\tif (hasText) {\n\t\t\t// We create this one in the counter-clockwise direction, which cuts out the label box\n\t\t\tpath\n\t\t\t\t.moveTo(labelBounds.left, labelBounds.top + radius)\n\t\t\t\t.lineTo(labelBounds.left, labelBounds.bottom - radius)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom)\n\t\t\t\t.lineTo(labelBounds.right - radius, labelBounds.bottom)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius)\n\t\t\t\t.lineTo(labelBounds.right, labelBounds.top + radius)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.right - radius, labelBounds.top)\n\t\t\t\t.lineTo(labelBounds.left + radius, labelBounds.top)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.left, labelBounds.top + radius)\n\t\t\t\t.close()\n\t\t}\n\n\t\treturn path.toD()\n\t}, [\n\t\tradius,\n\t\thasText,\n\t\tbounds.bottom,\n\t\tbounds.left,\n\t\tbounds.right,\n\t\tbounds.top,\n\t\tlabelBounds.bottom,\n\t\tlabelBounds.left,\n\t\tlabelBounds.right,\n\t\tlabelBounds.top,\n\t])\n\n\t// We also append the arrowhead paths to the clip path, so that we also clip the arrowheads\n\treturn <path d={`${path}${as}${ae}`} />\n}\n\nconst shapeAtTranslationStart = new WeakMap<\n\tTLArrowShape,\n\t{\n\t\tpagePosition: Vec\n\t\tterminalBindings: Record<\n\t\t\t'start' | 'end',\n\t\t\t{\n\t\t\t\tpagePosition: Vec\n\t\t\t\tshapePosition: Vec\n\t\t\t\tbinding: TLArrowBinding\n\t\t\t} | null\n\t\t>\n\t}\n>()\n\nfunction ArrowheadDotDef() {\n\tconst id = useSharedSafeId('arrowhead-dot')\n\treturn (\n\t\t<marker id={id} className=\"tl-arrow-hint\" refX=\"3.0\" refY=\"3.0\" orient=\"0\">\n\t\t\t<circle cx=\"3\" cy=\"3\" r=\"2\" strokeDasharray=\"100%\" />\n\t\t</marker>\n\t)\n}\n\nfunction ArrowheadCrossDef() {\n\tconst id = useSharedSafeId('arrowhead-cross')\n\treturn (\n\t\t<marker id={id} className=\"tl-arrow-hint\" refX=\"3.0\" refY=\"3.0\" orient=\"auto\">\n\t\t\t<line x1=\"1.5\" y1=\"1.5\" x2=\"4.5\" y2=\"4.5\" strokeDasharray=\"100%\" />\n\t\t\t<line x1=\"1.5\" y1=\"4.5\" x2=\"4.5\" y2=\"1.5\" strokeDasharray=\"100%\" />\n\t\t</marker>\n\t)\n}\n\n/**\n * Take 2 angles and return true if they are approximately parallel. Angle that point in the same\n * (or opposite) directions are considered parallel. This also handles wrap around - e.g. 0, \u03C0, and\n * 2\u03C0 are all considered parallel.\n */\nfunction anglesAreApproximatelyParallel(a: number, b: number, tolerance = 0.0001) {\n\tconst diff = Math.abs(a - b)\n\n\tconst isParallel = diff < tolerance\n\tconst isFlippedParallel = Math.abs(diff - Math.PI) < tolerance\n\tconst is360Parallel = Math.abs(diff - PI2) < tolerance\n\n\treturn { isParallel: isParallel || is360Parallel, isFlippedParallel }\n}\n"],"names":["ArrowHandles", "ArrowSvg", "path"],"mappings":"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"}}]
}