{
  "version": 3,
  "sources": [],
  "debugId": "435108ce-db81-97f9-a93d-2b26f879111d",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../../../ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/api/params.ts","../../../../../../ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/sanitize.ts"],"sourcesContent":["/**\n * Normalize Next.js dynamic route params to a single string.\n * Next.js 15+ may expose params as Record<string, string | string[]> or Promise<...>.\n * Use this so Drizzle eq(column, id) receives string, not string | string[].\n */\nexport function getParam(\n  params: Record<string, string | string[] | undefined> | undefined,\n  key: string\n): string | undefined {\n  if (!params || typeof params !== 'object') return undefined\n  const value = params[key]\n  if (value == null) return undefined\n  return Array.isArray(value) ? value[0] : value\n}\n\n/**\n * Await params if it's a Promise, then get a single string param.\n */\nexport async function getParamAsync(\n  params: Promise<Record<string, string | string[]>> | Record<string, string | string[]> | undefined,\n  key: string\n): Promise<string | undefined> {\n  const resolved = params instanceof Promise ? await params : params\n  return getParam(resolved as Record<string, string | string[] | undefined>, key)\n}\n","/**\n * XSS prevention: sanitize user input before rendering or storing.\n * Use for display and for any user-generated content that may be shown as HTML.\n */\n\nconst SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi\nconst ON_EVENT_REGEX = /\\s*on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi\nconst JAVASCRIPT_URL_REGEX = /javascript\\s*:/gi\nconst DATA_URL_REGEX = /data\\s*:\\s*[^,]*\\s*,/gi\n// Strip dangerous tags (iframe, object, embed, form, meta with refresh, link with import)\nconst DANGEROUS_TAGS_REGEX = /<(?:iframe|object|embed|form|meta|link)\\b[^>]*>/gi\n\n/**\n * Strip script tags, event handlers, javascript: URLs, data: URLs, and dangerous tags.\n * Safe for inserting into text content or plain HTML contexts.\n */\nexport function sanitizeHtml(input: string): string {\n  if (typeof input !== 'string') return ''\n  return input\n    .replace(SCRIPT_REGEX, '')\n    .replace(DANGEROUS_TAGS_REGEX, '')\n    .replace(ON_EVENT_REGEX, '')\n    .replace(JAVASCRIPT_URL_REGEX, '')\n    .replace(DATA_URL_REGEX, '')\n}\n\n/**\n * Sanitize and optionally truncate to a max length (for DB/store).\n */\nexport function sanitizeHtmlWithMax(input: string, maxLength: number = 50_000): string {\n  const s = sanitizeHtml(input)\n  if (s.length <= maxLength) return s\n  return s.slice(0, maxLength)\n}\n\n/**\n * Escape HTML entities so the string is safe for use in text nodes or attributes.\n */\nexport function escapeHtml(input: string): string {\n  if (typeof input !== 'string') return ''\n  const map: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;'\n  }\n  return input.replace(/[&<>\"'/]/g, (c) => map[c] ?? c)\n}\n\n/**\n * Sanitize for display in a context where only safe text is allowed (e.g. profile name, bio).\n * Prefer escapeHtml when rendering in React (React escapes by default); use this for legacy or raw HTML.\n */\nexport function sanitizeForDisplay(input: string): string {\n  return escapeHtml(sanitizeHtml(input))\n}\n"],"names":[],"mappings":"wCAkBO,eAAe,EACpB,CAAkG,CAClG,CAAW,MAdX,EAgBiB,IAhBgD,EACjE,GAAW,IAewB,QAAU,MAAM,EAAS,EAb5D,GAAI,CAAC,GAA4B,UAAlB,OAAO,EAAqB,OAAO,AAClD,IAAM,EAAQ,CAAM,CAAC,AAasD,EAblD,QACzB,AAAa,MAAT,AAAe,EACZ,KADmB,CACb,OAAO,CAAC,GAAS,CAAK,CAAC,EAAE,CAAG,QAY3C,uDCnBA,IAAM,EAAe,sDACf,EAAiB,kCACjB,EAAuB,mBACvB,EAAiB,yBAEjB,EAAuB,oDAMtB,SAAS,EAAa,CAAa,QACnB,AAArB,UAA+B,AAA3B,OAAO,EAA2B,GAC/B,EACJ,OAAO,CAAC,EAAc,IACtB,OAAO,CAAC,EAAsB,IAC9B,OAAO,CAAC,EAAgB,IACxB,OAAO,CAAC,EAAsB,IAC9B,OAAO,CAAC,EAAgB,GAC7B,CAKO,SAAS,EAAoB,CAAa,CAAE,EAAoB,GAAM,EAC3E,IAAM,EAAI,EAAa,UACvB,AAAI,EAAE,MAAM,EAAI,EAAkB,EAC3B,EAAE,KADkB,AACb,CAAC,EAAG,EACpB"}}]
}