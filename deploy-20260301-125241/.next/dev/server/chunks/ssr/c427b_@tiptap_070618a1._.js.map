{
  "version": 3,
  "sources": [],
  "debugId": "04085a04-d098-b8bd-c3c6-e9e17cfdaed6",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/transform/index.js"],"sourcesContent":["// transform/index.ts\nexport * from \"prosemirror-transform\";\n"],"names":[],"mappings":"AAAA,qBAAqB","ignoreList":[0]}},
    {"offset": {"line": 12, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/commands/index.js"],"sourcesContent":["// commands/index.ts\nexport * from \"prosemirror-commands\";\n"],"names":[],"mappings":"AAAA,oBAAoB","ignoreList":[0]}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/state/index.js"],"sourcesContent":["// state/index.ts\nexport * from \"prosemirror-state\";\n"],"names":[],"mappings":"AAAA,iBAAiB","ignoreList":[0]}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/model/index.js"],"sourcesContent":["// model/index.ts\nexport * from \"prosemirror-model\";\n"],"names":[],"mappings":"AAAA,iBAAiB","ignoreList":[0]}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/schema-list/index.js"],"sourcesContent":["// schema-list/index.ts\nexport * from \"prosemirror-schema-list\";\n"],"names":[],"mappings":"AAAA,uBAAuB","ignoreList":[0]}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/view/index.js"],"sourcesContent":["// view/index.ts\nexport * from \"prosemirror-view\";\n"],"names":[],"mappings":"AAAA,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/keymap/index.js"],"sourcesContent":["// keymap/index.ts\nexport * from \"prosemirror-keymap\";\n"],"names":[],"mappings":"AAAA,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/dropcursor/index.js"],"sourcesContent":["// dropcursor/index.ts\nexport * from \"prosemirror-dropcursor\";\n"],"names":[],"mappings":"AAAA,sBAAsB","ignoreList":[0]}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/gapcursor/index.js"],"sourcesContent":["// gapcursor/index.ts\nexport * from \"prosemirror-gapcursor\";\n"],"names":[],"mappings":"AAAA,qBAAqB","ignoreList":[0]}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/pm/dist/history/index.js"],"sourcesContent":["// history/index.ts\nexport * from \"prosemirror-history\";\n"],"names":[],"mappings":"AAAA,mBAAmB","ignoreList":[0]}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-code/src/code.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-code/src/index.ts"],"sourcesContent":["import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface CodeOptions {\n  /**\n   * The HTML attributes applied to the code element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType\n    }\n  }\n}\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick as the final character.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nexport const inputRegex = /(^|[^`])`([^`]+)`(?!`)$/\n\n/**\n * Matches inline code while pasting.\n */\nexport const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g\n\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  exitable: true,\n\n  parseHTML() {\n    return [{ tag: 'code' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'codespan',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'codespan' token to code mark\n    // For codespan tokens, we use the raw text content, not tokens\n    return helpers.applyMark('code', [{ type: 'text', text: token.text || '' }])\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return `\\`${h.renderChildren(node.content)}\\``\n  },\n\n  addCommands() {\n    return {\n      setCode:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleCode:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetCode:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Code } from './code.js'\n\nexport * from './code.js'\n\nexport default Code\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,MAAM,eAAe,eAAe,uBAAuB;;AAuC7D,IAAM,aAAa;AAKnB,IAAM,aAAa;AAMnB,IAAM,OAAO,2MAAA,CAAK,MAAA,CAAoB;IAC3C,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,UAAU;IAEV,MAAM;IAEN,UAAU;IAEV,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAO,CAAC;SAAA;IACzB;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAQ,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IACjF;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QAGjC,OAAO,QAAQ,SAAA,CAAU,QAAQ;YAAC;gBAAE,MAAM;gBAAQ,MAAM,MAAM,IAAA,IAAQ;YAAG,CAAC;SAAC;IAC7E;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAEA,OAAO,CAAA,EAAA,EAAK,EAAE,cAAA,CAAe,KAAK,OAAO,CAAC,CAAA,EAAA,CAAA;IAC5C;IAEA,cAAc;QACZ,OAAO;YACL,SACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;YACF,YACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,WACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,UAAA,CAAW;QACjD;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;AChID,IAAO,gBAAQ"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-highlight/src/highlight.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-highlight/src/index.ts"],"sourcesContent":["import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface HighlightOptions {\n  /**\n   * Allow multiple highlight colors\n   * @default false\n   * @example true\n   */\n  multicolor: boolean\n\n  /**\n   * HTML attributes to add to the highlight element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    highlight: {\n      /**\n       * Set a highlight mark\n       * @param attributes The highlight attributes\n       * @example editor.commands.setHighlight({ color: 'red' })\n       */\n      setHighlight: (attributes?: { color: string }) => ReturnType\n      /**\n       * Toggle a highlight mark\n       * @param attributes The highlight attributes\n       * @example editor.commands.toggleHighlight({ color: 'red' })\n       */\n      toggleHighlight: (attributes?: { color: string }) => ReturnType\n      /**\n       * Unset a highlight mark\n       * @example editor.commands.unsetHighlight()\n       */\n      unsetHighlight: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a highlight to a ==highlight== on input.\n */\nexport const inputRegex = /(?:^|\\s)(==(?!\\s+==)((?:[^=]+))==(?!\\s+==))$/\n\n/**\n * Matches a highlight to a ==highlight== on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(==(?!\\s+==)((?:[^=]+))==(?!\\s+==))/g\n\n/**\n * This extension allows you to highlight text.\n * @see https://www.tiptap.dev/api/marks/highlight\n */\nexport const Highlight = Mark.create<HighlightOptions>({\n  name: 'highlight',\n\n  addOptions() {\n    return {\n      multicolor: false,\n      HTMLAttributes: {},\n    }\n  },\n\n  addAttributes() {\n    if (!this.options.multicolor) {\n      return {}\n    }\n\n    return {\n      color: {\n        default: null,\n        parseHTML: element => element.getAttribute('data-color') || element.style.backgroundColor,\n        renderHTML: attributes => {\n          if (!attributes.color) {\n            return {}\n          }\n\n          return {\n            'data-color': attributes.color,\n            style: `background-color: ${attributes.color}; color: inherit`,\n          }\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'mark',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['mark', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  renderMarkdown: (node, h) => {\n    return `==${h.renderChildren(node)}==`\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.applyMark('highlight', h.parseInline(token.tokens || []))\n  },\n\n  markdownTokenizer: {\n    name: 'highlight',\n    level: 'inline',\n    start: (src: string) => src.indexOf('=='),\n    tokenize(src, _, h) {\n      const rule = /^(==)([^=]+)(==)/ // ==highlighted text==\n      const match = rule.exec(src)\n\n      if (match) {\n        const innerContent = match[2].trim()\n\n        const children = h.inlineTokens(innerContent)\n\n        return {\n          type: 'highlight',\n          raw: match[0],\n          text: innerContent,\n          tokens: children,\n        }\n      }\n    },\n  },\n\n  addCommands() {\n    return {\n      setHighlight:\n        attributes =>\n        ({ commands }) => {\n          return commands.setMark(this.name, attributes)\n        },\n      toggleHighlight:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name, attributes)\n        },\n      unsetHighlight:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-h': () => this.editor.commands.toggleHighlight(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Highlight } from './highlight.js'\n\nexport * from './highlight.js'\n\nexport default Highlight\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,MAAM,eAAe,eAAe,uBAAuB;;AA6C7D,IAAM,aAAa;AAKnB,IAAM,aAAa;AAMnB,IAAM,YAAY,2MAAA,CAAK,MAAA,CAAyB;IACrD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,YAAY;YACZ,gBAAgB,CAAC;QACnB;IACF;IAEA,gBAAgB;QACd,IAAI,CAAC,IAAA,CAAK,OAAA,CAAQ,UAAA,EAAY;YAC5B,OAAO,CAAC;QACV;QAEA,OAAO;YACL,OAAO;gBACL,SAAS;gBACT,WAAW,CAAA,UAAW,QAAQ,YAAA,CAAa,YAAY,KAAK,QAAQ,KAAA,CAAM,eAAA;gBAC1E,YAAY,CAAA,eAAc;oBACxB,IAAI,CAAC,WAAW,KAAA,EAAO;wBACrB,OAAO,CAAC;oBACV;oBAEA,OAAO;wBACL,cAAc,WAAW,KAAA;wBACzB,OAAO,CAAA,kBAAA,EAAqB,WAAW,KAAK,CAAA,gBAAA,CAAA;oBAC9C;gBACF;YACF;QACF;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAQ,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IACjF;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,OAAO,CAAA,EAAA,EAAK,EAAE,cAAA,CAAe,IAAI,CAAC,CAAA,EAAA,CAAA;IACpC;IAEA,eAAe,CAAC,OAAO,MAAM;QAC3B,OAAO,EAAE,SAAA,CAAU,aAAa,EAAE,WAAA,CAAY,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IACnE;IAEA,mBAAmB;QACjB,MAAM;QACN,OAAO;QACP,OAAO,CAAC,MAAgB,IAAI,OAAA,CAAQ,IAAI;QACxC,UAAS,GAAA,EAAK,CAAA,EAAG,CAAA,EAAG;YAClB,MAAM,OAAO;YACb,MAAM,QAAQ,KAAK,IAAA,CAAK,GAAG;YAE3B,IAAI,OAAO;gBACT,MAAM,eAAe,KAAA,CAAM,CAAC,CAAA,CAAE,IAAA,CAAK;gBAEnC,MAAM,WAAW,EAAE,YAAA,CAAa,YAAY;gBAE5C,OAAO;oBACL,MAAM;oBACN,KAAK,KAAA,CAAM,CAAC,CAAA;oBACZ,MAAM;oBACN,QAAQ;gBACV;YACF;QACF;IACF;IAEA,cAAc;QACZ,OAAO;YACL,cACE,CAAA,aACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAA,EAAM,UAAU;gBAC/C;YACF,iBACE,CAAA,aACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,UAAU;gBAClD;YACF,gBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,eAAA,CAAgB;QAC5D;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;AC3KD,IAAO,gBAAQ"}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-blockquote/src/blockquote.tsx","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-blockquote/src/index.ts"],"sourcesContent":["/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Blockquote } from './blockquote.jsx'\n\nexport * from './blockquote.jsx'\n\nexport default Blockquote\n"],"names":[],"mappings":";;;;;;;;;AACA,SAAS,iBAAiB,MAAM,yBAAyB;AA6DjD;;;AA5BD,IAAM,aAAa;AAMnB,IAAM,aAAa,2MAAA,CAAK,MAAA,CAA0B;IACvD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,SAAS;IAET,OAAO;IAEP,UAAU;IAEV,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAa,CAAC;SAAA;IAC/B;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OACE,aAAA,GAAA,IAAA,qOAAA,EAAC,cAAA;YAAY,OAAG,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc,CAAA;YACzE,UAAA,aAAA,GAAA,IAAA,qOAAA,EAAC,QAAA,CAAA,CAAK;QAAA,CACR;IAEJ;IAEA,eAAe,CAAC,OAAO,YAAY;QACjC,OAAO,QAAQ,UAAA,CAAW,cAAc,KAAA,GAAW,QAAQ,aAAA,CAAc,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IAC9F;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAIA,MAAM,SAAS;QACf,MAAM,SAAmB,CAAC,CAAA;QAE1B,KAAK,OAAA,CAAQ,OAAA,CAAQ,CAAA,UAAS;YAE5B,MAAM,eAAe,EAAE,cAAA,CAAe;gBAAC,KAAK;aAAC;YAC7C,MAAM,QAAQ,aAAa,KAAA,CAAM,IAAI;YAErC,MAAM,kBAAkB,MAAM,GAAA,CAAI,CAAA,SAAQ;gBAExC,IAAI,KAAK,IAAA,CAAK,MAAM,IAAI;oBACtB,OAAO;gBACT;gBAIA,OAAO,GAAG,MAAM,CAAA,CAAA,EAAI,IAAI,EAAA;YAC1B,CAAC;YAED,OAAO,IAAA,CAAK,gBAAgB,IAAA,CAAK,IAAI,CAAC;QACxC,CAAC;QAGD,OAAO,OAAO,IAAA,CAAK,CAAA;AAAA,EAAK,MAAM,CAAA;AAAA,CAAI;IACpC;IAEA,cAAc;QACZ,OAAO;YACL,eACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,MAAA,CAAO,IAAA,CAAK,IAAI;gBAClC;YACF,kBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,iBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,IAAA,CAAK,IAAA,CAAK,IAAI;gBAChC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,gBAAA,CAAiB;QAC7D;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,wNAAA,EAAkB;gBAChB,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;ACtID,IAAO,gBAAQ"}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-bold/src/bold.tsx","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-bold/src/index.ts"],"sourcesContent":["/** @jsxImportSource @tiptap/core */\nimport { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface BoldOptions {\n  /**\n   * HTML attributes to add to the bold element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches bold text via `**` as input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/\n\n/**\n * Matches bold text via `**` while pasting.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g\n\n/**\n * Matches bold text via `__` as input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/\n\n/**\n * Matches bold text via `__` while pasting.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g\n\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight=400',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <strong {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </strong>\n    )\n  },\n\n  markdownTokenName: 'strong',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'strong' token to bold mark\n    return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`\n  },\n\n  addCommands() {\n    return {\n      setBold:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleBold:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetBold:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Bold } from './bold.jsx'\n\nexport * from './bold.jsx'\n\nexport default Bold\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA,SAAS,MAAM,eAAe,eAAe,uBAAuB;AAsF5D;;;AArDD,IAAM,iBAAiB;AAKvB,IAAM,iBAAiB;AAKvB,IAAM,uBAAuB;AAK7B,IAAM,uBAAuB;AAM7B,IAAM,OAAO,2MAAA,CAAK,MAAA,CAAoB;IAC3C,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;YACA;gBACE,KAAK;gBACL,UAAU,CAAA,OAAS,KAAqB,KAAA,CAAM,UAAA,KAAe,YAAY;YAC3E;YACA;gBACE,OAAO;gBACP,WAAW,CAAA,OAAQ,KAAK,IAAA,CAAK,IAAA,KAAS,IAAA,CAAK,IAAA;YAC7C;YACA;gBACE,OAAO;gBACP,UAAU,CAAA,QAAS,4BAA4B,IAAA,CAAK,KAAe,KAAK;YAC1E;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OACE,aAAA,GAAA,IAAA,qOAAA,EAAC,UAAA;YAAQ,OAAG,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc,CAAA;YACrE,UAAA,aAAA,GAAA,IAAA,qOAAA,EAAC,QAAA,CAAA,CAAK;QAAA,CACR;IAEJ;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QAEjC,OAAO,QAAQ,SAAA,CAAU,QAAQ,QAAQ,WAAA,CAAY,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IAC1E;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,OAAO,CAAA,EAAA,EAAK,EAAE,cAAA,CAAe,IAAI,CAAC,CAAA,EAAA,CAAA;IACpC;IAEA,cAAc;QACZ,OAAO;YACL,SACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;YACF,YACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,WACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,UAAA,CAAW;YAC/C,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,UAAA,CAAW;QACjD;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;gBACD,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;gBACD,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;ACvJD,IAAO,gBAAQ"}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-code-block/src/code-block.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-code-block/src/index.ts"],"sourcesContent":["import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // donâ€™t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { CodeBlock } from './code-block.js'\n\nexport * from './code-block.js'\n\nexport default CodeBlock\n"],"names":["_a"],"mappings":"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"}},
    {"offset": {"line": 850, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-document/src/document.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-document/src/index.ts"],"sourcesContent":["import { Node } from '@tiptap/core'\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n\\n')\n  },\n})\n","import { Document } from './document.js'\n\nexport * from './document.js'\n\nexport default Document\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,YAAY;;AAMd,IAAM,WAAW,2MAAA,CAAK,MAAA,CAAO;IAClC,MAAM;IACN,SAAS;IACT,SAAS;IAET,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAEA,OAAO,EAAE,cAAA,CAAe,KAAK,OAAA,EAAS,MAAM;IAC9C;AACF,CAAC;;ACdD,IAAO,gBAAQ"}},
    {"offset": {"line": 878, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-hard-break/src/hard-break.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-hard-break/src/index.ts"],"sourcesContent":["import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  /**\n   * Controls if marks should be kept after being split by a hard break.\n   * @default true\n   * @example false\n   */\n  keepMarks: boolean\n\n  /**\n   * HTML attributes to add to the hard break element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       * @example editor.commands.setHardBreak()\n       */\n      setHardBreak: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  markdownTokenName: 'br',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  parseHTML() {\n    return [{ tag: 'br' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  renderMarkdown: () => `  \\n`,\n\n  parseMarkdown: () => {\n    return {\n      type: 'hardBreak',\n    }\n  },\n\n  addCommands() {\n    return {\n      setHardBreak:\n        () =>\n        ({ commands, chain, state, editor }) => {\n          return commands.first([\n            () => commands.exitCode(),\n            () =>\n              commands.command(() => {\n                const { selection, storedMarks } = state\n\n                if (selection.$from.parent.type.spec.isolating) {\n                  return false\n                }\n\n                const { keepMarks } = this.options\n                const { splittableMarks } = editor.extensionManager\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n                return chain()\n                  .insertContent({ type: this.name })\n                  .command(({ tr, dispatch }) => {\n                    if (dispatch && marks && keepMarks) {\n                      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n                      tr.ensureMarks(filteredMarks)\n                    }\n\n                    return true\n                  })\n                  .run()\n              }),\n          ])\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n","import { HardBreak } from './hard-break.js'\n\nexport * from './hard-break.js'\n\nexport default HardBreak\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,iBAAiB,YAAY;;AAkC/B,IAAM,YAAY,2MAAA,CAAK,MAAA,CAAyB;IACrD,MAAM;IAEN,mBAAmB;IAEnB,aAAa;QACX,OAAO;YACL,WAAW;YACX,gBAAgB,CAAC;QACnB;IACF;IAEA,QAAQ;IAER,OAAO;IAEP,YAAY;IAEZ,sBAAsB;IAEtB,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAK,CAAC;SAAA;IACvB;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAM,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc,CAAC;SAAA;IAC5E;IAEA,aAAa;QACX,OAAO;IACT;IAEA,gBAAgB,IAAM,CAAA;AAAA,CAAA;IAEtB,eAAe,MAAM;QACnB,OAAO;YACL,MAAM;QACR;IACF;IAEA,cAAc;QACZ,OAAO;YACL,cACE,IACA,CAAC,EAAE,QAAA,EAAU,KAAA,EAAO,KAAA,EAAO,MAAA,CAAO,CAAA,KAAM;oBACtC,OAAO,SAAS,KAAA,CAAM;wBACpB,IAAM,SAAS,QAAA,CAAS;wBACxB,IACE,SAAS,OAAA,CAAQ,MAAM;gCACrB,MAAM,EAAE,SAAA,EAAW,WAAA,CAAY,CAAA,GAAI;gCAEnC,IAAI,UAAU,KAAA,CAAM,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,SAAA,EAAW;oCAC9C,OAAO;gCACT;gCAEA,MAAM,EAAE,SAAA,CAAU,CAAA,GAAI,IAAA,CAAK,OAAA;gCAC3B,MAAM,EAAE,eAAA,CAAgB,CAAA,GAAI,OAAO,gBAAA;gCACnC,MAAM,QAAQ,eAAgB,UAAU,GAAA,CAAI,YAAA,IAAgB,UAAU,KAAA,CAAM,KAAA,CAAM;gCAElF,OAAO,MAAM,EACV,aAAA,CAAc;oCAAE,MAAM,IAAA,CAAK,IAAA;gCAAK,CAAC,EACjC,OAAA,CAAQ,CAAC,EAAE,EAAA,EAAI,QAAA,CAAS,CAAA,KAAM;oCAC7B,IAAI,YAAY,SAAS,WAAW;wCAClC,MAAM,gBAAgB,MAAM,MAAA,CAAO,CAAA,OAAQ,gBAAgB,QAAA,CAAS,KAAK,IAAA,CAAK,IAAI,CAAC;wCAEnF,GAAG,WAAA,CAAY,aAAa;oCAC9B;oCAEA,OAAO;gCACT,CAAC,EACA,GAAA,CAAI;4BACT,CAAC;qBACJ;gBACH;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,aAAa,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;YACrD,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;QACzD;IACF;AACF,CAAC;;ACjHD,IAAO,gBAAQ"}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-heading/src/heading.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-heading/src/index.ts"],"sourcesContent":["import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\n\n/**\n * The heading level options.\n */\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  /**\n   * The available heading levels.\n   * @default [1, 2, 3, 4, 5, 6]\n   * @example [1, 2, 3]\n   */\n  levels: Level[]\n\n  /**\n   * The HTML attributes for a heading node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.setHeading({ level: 1 })\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType\n      /**\n       * Toggle a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.toggleHeading({ level: 1 })\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels.map((level: Level) => ({\n      tag: `h${level}`,\n      attrs: { level },\n    }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel ? node.attrs.level : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'heading' token to heading node\n    // marked provides 'depth' property (1-6) for heading level\n    return helpers.createNode('heading', { level: token.depth || 1 }, helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    const level = node.attrs?.level ? parseInt(node.attrs.level as string, 10) : 1\n    const headingChars = '#'.repeat(level)\n\n    if (!node.content) {\n      return ''\n    }\n\n    // Use current context for proper joining/spacing\n    return `${headingChars} ${h.renderChildren(node.content)}`\n  },\n\n  addCommands() {\n    return {\n      setHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.setNode(this.name, attributes)\n        },\n      toggleHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n        },\n      }),\n      {},\n    )\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n","import { Heading } from './heading.js'\n\nexport * from './heading.js'\n\nexport default Heading\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1077, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-horizontal-rule/src/horizontal-rule.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-horizontal-rule/src/index.ts"],"sourcesContent":["import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if itâ€™s the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|â€”-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,eAAe,iBAAiB,iBAAiB,MAAM,qBAAqB;;AACrF,SAAS,eAAe,qBAAqB;;;AAiCtC,IAAM,iBAAiB,2MAAA,CAAK,MAAA,CAA8B;IAC/D,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;YACjB,cAAc;QAChB;IACF;IAEA,OAAO;IAEP,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAK,CAAC;SAAA;IACvB;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAM,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc,CAAC;SAAA;IAC5E;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QACjC,OAAO,QAAQ,UAAA,CAAW,gBAAgB;IAC5C;IAEA,gBAAgB,MAAM;QACpB,OAAO;IACT;IAEA,cAAc;QACZ,OAAO;YACL,mBACE,IACA,CAAC,EAAE,KAAA,EAAO,KAAA,CAAM,CAAA,KAAM;oBAEpB,IAAI,KAAC,oNAAA,EAAc,OAAO,MAAM,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK,IAAI,CAAC,GAAG;wBACxD,OAAO;oBACT;oBAEA,MAAM,EAAE,SAAA,CAAU,CAAA,GAAI;oBACtB,MAAM,EAAE,KAAK,SAAA,CAAU,CAAA,GAAI;oBAE3B,MAAM,eAAe,MAAM;oBAE3B,QAAI,sNAAA,EAAgB,SAAS,GAAG;wBAC9B,aAAa,eAAA,CAAgB,UAAU,GAAA,EAAK;4BAC1C,MAAM,IAAA,CAAK,IAAA;wBACb,CAAC;oBACH,OAAO;wBACL,aAAa,aAAA,CAAc;4BAAE,MAAM,IAAA,CAAK,IAAA;wBAAK,CAAC;oBAChD;oBAEA,OACE,aAEG,OAAA,CAAQ,CAAC,EAAE,OAAO,UAAA,EAAY,EAAA,EAAI,QAAA,CAAS,CAAA,KAAM;wBAChD,IAAI,UAAU;4BACZ,MAAM,EAAE,GAAA,CAAI,CAAA,GAAI,GAAG,SAAA;4BACnB,MAAM,WAAW,IAAI,GAAA,CAAI;4BAEzB,IAAI,IAAI,SAAA,EAAW;gCACjB,IAAI,IAAI,SAAA,CAAU,WAAA,EAAa;oCAC7B,GAAG,YAAA,CAAa,wNAAA,CAAc,MAAA,CAAO,GAAG,GAAA,EAAK,IAAI,GAAA,GAAM,CAAC,CAAC;gCAC3D,OAAA,IAAW,IAAI,SAAA,CAAU,OAAA,EAAS;oCAChC,GAAG,YAAA,CAAa,wNAAA,CAAc,MAAA,CAAO,GAAG,GAAA,EAAK,IAAI,GAAG,CAAC;gCACvD,OAAO;oCACL,GAAG,YAAA,CAAa,wNAAA,CAAc,MAAA,CAAO,GAAG,GAAA,EAAK,IAAI,GAAG,CAAC;gCACvD;4BACF,OAAO;gCAEL,MAAM,WACJ,WAAW,MAAA,CAAO,KAAA,CAAM,IAAA,CAAK,OAAA,CAAQ,YAAY,CAAA,IAAK,IAAI,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,WAAA;gCACrF,MAAM,OAAO,YAAA,OAAA,KAAA,IAAA,SAAU,MAAA;gCAEvB,IAAI,MAAM;oCACR,GAAG,MAAA,CAAO,UAAU,IAAI;oCACxB,GAAG,YAAA,CAAa,wNAAA,CAAc,MAAA,CAAO,GAAG,GAAA,EAAK,WAAW,CAAC,CAAC;gCAC5D;4BACF;4BAEA,GAAG,cAAA,CAAe;wBACpB;wBAEA,OAAO;oBACT,CAAC,EACA,GAAA,CAAI;gBAEX;QACJ;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;AClID,IAAO,gBAAQ"}},
    {"offset": {"line": 1180, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-italic/src/italic.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-italic/src/index.ts"],"sourcesContent":["import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface ItalicOptions {\n  /**\n   * HTML attributes to add to the italic element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       * @example editor.commands.setItalic()\n       */\n      setItalic: () => ReturnType\n      /**\n       * Toggle an italic mark\n       * @example editor.commands.toggleItalic()\n       */\n      toggleItalic: () => ReturnType\n      /**\n       * Unset an italic mark\n       * @example editor.commands.unsetItalic()\n       */\n      unsetItalic: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an italic to a *italic* on input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/\n\n/**\n * Matches an italic to a *italic* on paste.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g\n\n/**\n * Matches an italic to a _italic_ on input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/\n\n/**\n * Matches an italic to a _italic_ on paste.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g\n\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=normal',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleItalic:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetItalic:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  markdownTokenName: 'em',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'em' token to italic mark\n    return helpers.applyMark('italic', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Italic } from './italic.js'\n\nexport * from './italic.js'\n\nexport default Italic\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,SAAS,MAAM,eAAe,eAAe,uBAAuB;;AAoC7D,IAAM,iBAAiB;AAKvB,IAAM,iBAAiB;AAKvB,IAAM,uBAAuB;AAK7B,IAAM,uBAAuB;AAM7B,IAAM,SAAS,2MAAA,CAAK,MAAA,CAAsB;IAC/C,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;YACA;gBACE,KAAK;gBACL,UAAU,CAAA,OAAS,KAAqB,KAAA,CAAM,SAAA,KAAc,YAAY;YAC1E;YACA;gBACE,OAAO;gBACP,WAAW,CAAA,OAAQ,KAAK,IAAA,CAAK,IAAA,KAAS,IAAA,CAAK,IAAA;YAC7C;YACA;gBACE,OAAO;YACT;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAM,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC/E;IAEA,cAAc;QACZ,OAAO;YACL,WACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;YACF,cACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,aACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QAEjC,OAAO,QAAQ,SAAA,CAAU,UAAU,QAAQ,WAAA,CAAY,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IAC5E;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,OAAO,CAAA,CAAA,EAAI,EAAE,cAAA,CAAe,IAAI,CAAC,CAAA,CAAA,CAAA;IACnC;IAEA,uBAAuB;QACrB,OAAO;YACL,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;YACjD,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;QACnD;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;gBACD,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;gBACD,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;ACpJD,IAAO,gBAAQ"}},
    {"offset": {"line": 1292, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/link.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/helpers/autolink.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/helpers/whitespace.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/helpers/clickHandler.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/helpers/pasteHandler.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-link/src/index.ts"],"sourcesContent":["import type { PasteRuleMatch } from '@tiptap/core'\nimport { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport type { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\nimport { UNICODE_WHITESPACE_REGEX_GLOBAL } from './helpers/whitespace.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean\n}\n\nexport const pasteRegex =\n  /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable\n  /**\n   * If enabled, the link will be selected when clicked.\n   * @default false\n   * @example true\n   */\n  enableClickSelection: boolean\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * @deprecated Use the `shouldAutoLink` option instead.\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean\n\n  /**\n   * A validation function which is used for configuring link verification for preventing XSS attacks.\n   * Only modify this if you know what you're doing.\n   *\n   * @returns {boolean} `true` if the URL is valid, `false` otherwise.\n   *\n   * @example\n   * isAllowedUri: (url, { defaultValidate, protocols, defaultProtocol }) => {\n   * return url.startsWith('./') || defaultValidate(url)\n   * }\n   */\n  isAllowedUri: (\n    /**\n     * The URL to be validated.\n     */\n    url: string,\n    ctx: {\n      /**\n       * The default validation function.\n       */\n      defaultValidate: (url: string) => boolean\n      /**\n       * An array of allowed protocols for the URL (e.g., \"http\", \"https\"). As defined in the `protocols` option.\n       */\n      protocols: Array<LinkProtocolOptions | string>\n      /**\n       * A string that represents the default protocol (e.g., 'http'). As defined in the `defaultProtocol` option.\n       */\n      defaultProtocol: string\n    },\n  ) => boolean\n\n  /**\n   * Determines whether a valid link should be automatically linked in the content.\n   *\n   * @param {string} url - The URL that has already been validated.\n   * @returns {boolean} - True if the link should be auto-linked; false if it should not be auto-linked.\n   */\n  shouldAutoLink: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n        title?: string | null\n      }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes?: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n        title?: string | null\n      }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\nexport function isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  return (\n    !uri ||\n    uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, '').match(\n      new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`,\n        'i',\n      ),\n    )\n  )\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    // TODO: v4 - remove validate option\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate\n      console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.')\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => {\n        // URLs with explicit protocols (e.g., https://) should be auto-linked\n        // But not if @ appears before :// (that would be userinfo like user:pass@host)\n        const hasProtocol = /^[a-z][a-z0-9+.-]*:\\/\\//i.test(url)\n        const hasMaybeProtocol = /^[a-z][a-z0-9+.-]*:/i.test(url)\n\n        if (hasProtocol || (hasMaybeProtocol && !url.includes('@'))) {\n          return true\n        }\n        // Strip userinfo (user:pass@) if present, then extract hostname\n        const urlWithoutUserinfo = url.includes('@') ? url.split('@').pop()! : url\n        const hostname = urlWithoutUserinfo.split(/[/?#:]/)[0]\n\n        // Don't auto-link IP addresses without protocol\n        if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(hostname)) {\n          return false\n        }\n        // Don't auto-link single-word hostnames without TLD (e.g., \"localhost\")\n        if (!/\\./.test(hostname)) {\n          return false\n        }\n        return true\n      },\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n      title: {\n        default: null,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'a[href]',\n        getAttrs: dom => {\n          const href = (dom as HTMLElement).getAttribute('href')\n\n          // prevent XSS attacks\n          if (\n            !href ||\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n          return null\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (\n      !this.options.isAllowedUri(HTMLAttributes.href, {\n        defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n        protocols: this.options.protocols,\n        defaultProtocol: this.options.defaultProtocol,\n      })\n    ) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'link',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark('link', helpers.parseInline(token.tokens || []), {\n      href: token.href,\n      title: token.title || null,\n    })\n  },\n\n  renderMarkdown: (node, h) => {\n    const href = node.attrs?.href ?? ''\n    const title = node.attrs?.title ?? ''\n    const text = h.renderChildren(node)\n\n    return title ? `[${text}](${href} \"${title}\")` : `[${text}](${href})`\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes\n\n          if (\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes || {}\n\n          if (\n            href &&\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () =>\n        ({ chain }) => {\n          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta('preventAutolink', true).run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { protocols, defaultProtocol } = this.options\n            const links = find(text).filter(\n              item =>\n                item.isLink &&\n                this.options.isAllowedUri(item.value, {\n                  defaultValidate: href => !!isAllowedUri(href, protocols),\n                  protocols,\n                  defaultProtocol,\n                }),\n            )\n\n            if (links.length) {\n              links.forEach(link => {\n                if (!this.options.shouldAutoLink(link.value)) {\n                  return\n                }\n\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href,\n                  },\n                  index: link.start,\n                })\n              })\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n    const { protocols, defaultProtocol } = this.options\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: url =>\n            this.options.isAllowedUri(url, {\n              defaultValidate: href => !!isAllowedUri(href, protocols),\n              protocols,\n              defaultProtocol,\n            }),\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    plugins.push(\n      clickHandler({\n        type: this.type,\n        editor: this.editor,\n        openOnClick: this.options.openOnClick === 'whenNotEditable' ? true : this.options.openOnClick,\n        enableClickSelection: this.options.enableClickSelection,\n      }),\n    )\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n","import type { NodeWithPos } from '@tiptap/core'\nimport { combineTransactionSteps, findChildrenInRange, getChangedRanges, getMarksBetween } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { MultiToken } from 'linkifyjs'\nimport { tokenize } from 'linkifyjs'\n\nimport { UNICODE_WHITESPACE_REGEX, UNICODE_WHITESPACE_REGEX_END } from './whitespace.js'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n  shouldAutoLink: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ')\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return\n          }\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ')\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean)\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code)\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // check whether should autolink\n            .filter(link => options.shouldAutoLink(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.ts\nexport const UNICODE_WHITESPACE_PATTERN = '[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]'\n\nexport const UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN)\nexport const UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`)\nexport const UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, 'g')\n","import type { Editor } from '@tiptap/core'\nimport { getAttributes } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType\n  editor: Editor\n  openOnClick?: boolean\n  enableClickSelection?: boolean\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let link: HTMLAnchorElement | null = null\n\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target\n        } else {\n          const target = event.target as HTMLElement | null\n          if (!target) {\n            return false\n          }\n\n          const root = options.editor.view.dom\n\n          // Tntentionally limit the lookup to the editor root.\n          // Using tag names like DIV as boundaries breaks with custom NodeViews,\n          link = target.closest<HTMLAnchorElement>('a')\n\n          if (link && !root.contains(link)) {\n            link = null\n          }\n        }\n\n        if (!link) {\n          return false\n        }\n\n        let handled = false\n\n        if (options.enableClickSelection) {\n          const commandResult = options.editor.commands.extendMarkRange(options.type.name)\n          handled = commandResult\n        }\n\n        if (options.openOnClick) {\n          const attrs = getAttributes(view.state, options.type.name)\n          const href = link.href ?? attrs.href\n          const target = link.target ?? attrs.target\n\n          if (href) {\n            window.open(href, target)\n            handled = true\n          }\n        }\n\n        return handled\n      },\n    },\n  })\n}\n","import type { Editor } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\nimport type { LinkOptions } from '../link.js'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n  shouldAutoLink?: LinkOptions['shouldAutoLink']\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, _event, slice) => {\n        const { shouldAutoLink } = options\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          item => item.isLink && item.value === textContent,\n        )\n\n        if (!textContent || !link || (shouldAutoLink !== undefined && !shouldAutoLink(link.value))) {\n          return false\n        }\n\n        return options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n      },\n    },\n  })\n}\n","import { Link } from './link.js'\n\nexport * from './link.js'\n\nexport default Link\n"],"names":["find","Plugin","PluginKey","Plugin","PluginKey","find"],"mappings":"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"}},
    {"offset": {"line": 1750, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/bullet-list/bullet-list.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/item/list-item.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/list-keymap.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/index.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/findListItemPos.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/getNextListDepth.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/handleBackspace.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/hasListBefore.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/hasListItemBefore.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/listItemHasSubList.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/handleDelete.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/nextListIsDeeper.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/nextListIsHigher.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/keymap/listHelpers/hasListItemAfter.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/kit/index.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/ordered-list/ordered-list.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/ordered-list/utils.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/task-item/task-item.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-list/src/task-list/task-list.ts"],"sourcesContent":["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          const start = context.meta?.parentAttrs?.start || 1\n          return `${start + context.index}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n","export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n","import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n","import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Itâ€™s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport {\n  getRenderedAttributes,\n  mergeAttributes,\n  Node,\n  renderNestedMarkdownContent,\n  wrappingInputRule,\n} from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isnâ€™t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      // Track the keys of previously rendered HTML attributes for proper removal\n      let prevRenderedAttributeKeys = new Set(Object.keys(HTMLAttributes))\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          // Sync all HTML attributes from the updated node\n          const extensionAttributes = editor.extensionManager.attributes\n          const newHTMLAttributes = getRenderedAttributes(updatedNode, extensionAttributes)\n          const newKeys = new Set(Object.keys(newHTMLAttributes))\n\n          // Remove attributes that were previously rendered but are no longer present\n          // If the attribute exists in static options, restore it instead of removing\n          const staticAttrs = this.options.HTMLAttributes\n\n          prevRenderedAttributeKeys.forEach(key => {\n            if (!newKeys.has(key)) {\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            }\n          })\n\n          // Update or add new attributes\n          Object.entries(newHTMLAttributes).forEach(([key, value]) => {\n            if (value === null || value === undefined) {\n              // If the attribute exists in static options, restore it instead of removing\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            } else {\n              listItem.setAttribute(key, value)\n            }\n          })\n\n          // Update the tracked keys for next update\n          prevRenderedAttributeKeys = newKeys\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n"],"names":["mergeAttributes","Node","getNodeType","isNodeActive","isNodeActive","Extension","mergeAttributes","Node","wrappingInputRule","ListItemName","TextStyleName","Node","mergeAttributes","wrappingInputRule","mergeAttributes","Node","renderNestedMarkdownContent","wrappingInputRule","mergeAttributes","Node","Extension"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,iBAAiB,MAAM,yBAAyB;;;;;;;;;AAEzD,IAAM,eAAe;AACrB,IAAM,gBAAgB;AA8Cf,IAAM,uBAAuB;AAQ7B,IAAM,aAAa,2MAAA,CAAK,MAAA,CAA0B;IACvD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,cAAc;YACd,gBAAgB,CAAC;YACjB,WAAW;YACX,gBAAgB;QAClB;IACF;IAEA,OAAO;IAEP,UAAU;QACR,OAAO,GAAG,IAAA,CAAK,OAAA,CAAQ,YAAY,CAAA,CAAA,CAAA;IACrC;IAEA,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAK,CAAC;SAAA;IACvB;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAM,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC/E;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QACjC,IAAI,MAAM,IAAA,KAAS,UAAW,MAAc,OAAA,EAAS;YACnD,OAAO,CAAC,CAAA;QACV;QAEA,OAAO;YACL,MAAM;YACN,SAAS,MAAM,KAAA,GAAQ,QAAQ,aAAA,CAAc,MAAM,KAAK,IAAI,CAAC,CAAA;QAC/D;IACF;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAEA,OAAO,EAAE,cAAA,CAAe,KAAK,OAAA,EAAS,IAAI;IAC5C;IAEA,iBAAiB;QACf,gBAAgB;IAClB;IAEA,cAAc;QACZ,OAAO;YACL,kBACE,IACA,CAAC,EAAE,QAAA,EAAU,KAAA,CAAM,CAAA,KAAM;oBACvB,IAAI,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB;wBAC/B,OAAO,MAAM,EACV,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,YAAA,EAAc,IAAA,CAAK,OAAA,CAAQ,SAAS,EACvE,gBAAA,CAAiB,cAAc,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,aAAa,CAAC,EACvE,GAAA,CAAI;oBACT;oBACA,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,YAAA,EAAc,IAAA,CAAK,OAAA,CAAQ,SAAS;gBACzF;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,gBAAA,CAAiB;QAC7D;IACF;IAEA,gBAAgB;QACd,IAAI,YAAY,4NAAA,EAAkB;YAChC,MAAM;YACN,MAAM,IAAA,CAAK,IAAA;QACb,CAAC;QAED,IAAI,IAAA,CAAK,OAAA,CAAQ,SAAA,IAAa,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB;YACzD,gBAAY,wNAAA,EAAkB;gBAC5B,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;gBACX,WAAW,IAAA,CAAK,OAAA,CAAQ,SAAA;gBACxB,gBAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA;gBAC7B,eAAe,MAAM;oBACnB,OAAO,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,aAAa;gBAChD;gBACA,QAAQ,IAAA,CAAK,MAAA;YACf,CAAC;QACH;QACA,OAAO;YAAC,SAAS;SAAA;IACnB;AACF,CAAC;;ACzHM,IAAM,WAAWC,2MAAAA,CAAK,MAAA,CAAwB;IACnD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;YACjB,oBAAoB;YACpB,qBAAqB;QACvB;IACF;IAEA,SAAS;IAET,UAAU;IAEV,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAMD,sNAAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC/E;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QACjC,IAAI,MAAM,IAAA,KAAS,aAAa;YAC9B,OAAO,CAAC,CAAA;QACV;QAEA,IAAI,UAAiB,CAAC,CAAA;QAEtB,IAAI,MAAM,MAAA,IAAU,MAAM,MAAA,CAAO,MAAA,GAAS,GAAG;YAE3C,MAAM,qBAAqB,MAAM,MAAA,CAAO,IAAA,CAAK,CAAA,IAAK,EAAE,IAAA,KAAS,WAAW;YAExE,IAAI,oBAAoB;gBAEtB,UAAU,QAAQ,aAAA,CAAc,MAAM,MAAM;YAC9C,OAAO;gBAEL,MAAM,aAAa,MAAM,MAAA,CAAO,CAAC,CAAA;gBAEjC,IAAI,cAAc,WAAW,IAAA,KAAS,UAAU,WAAW,MAAA,IAAU,WAAW,MAAA,CAAO,MAAA,GAAS,GAAG;oBAEjG,MAAM,gBAAgB,QAAQ,WAAA,CAAY,WAAW,MAAM;oBAG3D,UAAU;wBACR;4BACE,MAAM;4BACN,SAAS;wBACX;qBACF;oBAIA,IAAI,MAAM,MAAA,CAAO,MAAA,GAAS,GAAG;wBAC3B,MAAM,kBAAkB,MAAM,MAAA,CAAO,KAAA,CAAM,CAAC;wBAC5C,MAAM,oBAAoB,QAAQ,aAAA,CAAc,eAAe;wBAC/D,QAAQ,IAAA,CAAK,GAAG,iBAAiB;oBACnC;gBACF,OAAO;oBAEL,UAAU,QAAQ,aAAA,CAAc,MAAM,MAAM;gBAC9C;YACF;QACF;QAGA,IAAI,QAAQ,MAAA,KAAW,GAAG;YACxB,UAAU;gBACR;oBACE,MAAM;oBACN,SAAS,CAAC,CAAA;gBACZ;aACF;QACF;QAEA,OAAO;YACL,MAAM;YACN;QACF;IACF;IAEA,gBAAgB,CAAC,MAAM,GAAG,QAAQ;QAChC,WAAO,kOAAA,EACL,MACA,GACA,CAAC,YAAiB;YA1HxB,IAAA,IAAA;YA2HQ,IAAI,QAAQ,UAAA,KAAe,cAAc;gBACvC,OAAO;YACT;YACA,IAAI,QAAQ,UAAA,KAAe,eAAe;gBACxC,MAAM,QAAA,CAAA,CAAQ,KAAA,CAAA,KAAA,QAAQ,IAAA,KAAR,OAAA,KAAA,IAAA,GAAc,WAAA,KAAd,OAAA,KAAA,IAAA,GAA2B,KAAA,KAAS;gBAClD,OAAO,GAAG,QAAQ,QAAQ,KAAK,CAAA,EAAA,CAAA;YACjC;YAEA,OAAO;QACT,GACA;IAEJ;IAEA,uBAAuB;QACrB,OAAO;YACL,OAAO,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,aAAA,CAAc,IAAA,CAAK,IAAI;YACzD,KAAK,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa,IAAA,CAAK,IAAI;YACtD,aAAa,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa,IAAA,CAAK,IAAI;QAChE;IACF;AACF,CAAC;;;AEhJD,IAAA,sBAAA,CAAA;AAAA,SAAA,qBAAA;IAAA,iBAAA,IAAA;IAAA,kBAAA,IAAA;IAAA,iBAAA,IAAA;IAAA,cAAA,IAAA;IAAA,eAAA,IAAA;IAAA,kBAAA,IAAA;IAAA,mBAAA,IAAA;IAAA,oBAAA,IAAA;IAAA,kBAAA,IAAA;IAAA,kBAAA,IAAA;AAAA;;ACIO,IAAM,kBAAkB,CAAC,YAA+B,UAAuB;IACpF,MAAM,EAAE,KAAA,CAAM,CAAA,GAAI,MAAM,SAAA;IACxB,MAAM,WAAW,sNAAA,EAAY,YAAY,MAAM,MAAM;IAErD,IAAI,cAAc;IAClB,IAAI,eAAe,MAAM,KAAA;IACzB,IAAI,aAAa,MAAM,GAAA;IACvB,IAAI,cAA6B;IAEjC,MAAO,eAAe,KAAK,gBAAgB,KAAM;QAC/C,cAAc,MAAM,IAAA,CAAK,YAAY;QAErC,IAAI,YAAY,IAAA,KAAS,UAAU;YACjC,cAAc;QAChB,OAAO;YACL,gBAAgB;YAChB,cAAc;QAChB;IACF;IAEA,IAAI,gBAAgB,MAAM;QACxB,OAAO;IACT;IAEA,OAAO;QAAE,MAAM,MAAM,GAAA,CAAI,OAAA,CAAQ,UAAU;QAAG,OAAO;IAAY;AACnE;;ACxBO,IAAM,mBAAmB,CAAC,YAAoB,UAAuB;IAC1E,MAAM,cAAc,gBAAgB,YAAY,KAAK;IAErD,IAAI,CAAC,aAAa;QAChB,OAAO;IACT;IAEA,MAAM,CAAC,EAAE,KAAK,CAAA,OAAI,wNAAA,EAAkB,OAAO,YAAY,YAAY,IAAA,CAAK,GAAA,GAAM,CAAC;IAE/E,OAAO;AACT;;;AEbO,IAAM,gBAAgB,CAAC,aAA0B,MAAc,oBAA8B;IAClG,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,YAAY,SAAA;IAEhC,MAAM,kBAAkB,KAAK,GAAA,CAAI,GAAG,QAAQ,GAAA,GAAM,CAAC;IAEnD,MAAM,eAAe,YAAY,GAAA,CAAI,OAAA,CAAQ,eAAe,EAAE,IAAA,CAAK;IAEnE,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,QAAA,CAAS,aAAa,IAAA,CAAK,IAAI,GAAG;QACtE,OAAO;IACT;IAEA,OAAO;AACT;;ACZO,IAAM,oBAAoB,CAAC,YAAoB,UAAgC;IAFtF,IAAA;IAGE,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,MAAM,SAAA;IAE1B,MAAM,aAAa,MAAM,GAAA,CAAI,OAAA,CAAQ,QAAQ,GAAA,GAAM,CAAC;IAEpD,IAAI,WAAW,KAAA,CAAM,MAAM,GAAG;QAC5B,OAAO;IACT;IAEA,IAAA,CAAA,CAAI,KAAA,WAAW,UAAA,KAAX,OAAA,KAAA,IAAA,GAAuB,IAAA,CAAK,IAAA,MAAS,YAAY;QACnD,OAAO;IACT;IAEA,OAAO;AACT;;ACZO,IAAM,qBAAqB,CAAC,YAAoB,OAAoB,SAAgB;IACzF,IAAI,CAAC,MAAM;QACT,OAAO;IACT;IAEA,MAAM,eAAWE,kNAAAA,EAAY,YAAY,MAAM,MAAM;IAErD,IAAI,aAAa;IAEjB,KAAK,WAAA,CAAY,CAAA,UAAS;QACxB,IAAI,MAAM,IAAA,KAAS,UAAU;YAC3B,aAAa;QACf;IACF,CAAC;IAED,OAAO;AACT;;AHXO,IAAM,kBAAkB,CAAC,QAAgB,MAAc,oBAA8B;IAE1F,IAAI,OAAO,QAAA,CAAS,aAAA,CAAc,GAAG;QACnC,OAAO;IACT;IAIA,IAAI,OAAO,KAAA,CAAM,SAAA,CAAU,IAAA,KAAS,OAAO,KAAA,CAAM,SAAA,CAAU,EAAA,EAAI;QAC7D,OAAO;IACT;IAKA,IAAI,KAAC,mNAAA,EAAa,OAAO,KAAA,EAAO,IAAI,KAAK,cAAc,OAAO,KAAA,EAAO,MAAM,eAAe,GAAG;QAC3F,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,OAAO,KAAA,CAAM,SAAA;QAEjC,MAAM,WAAW,OAAO,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,QAAQ,MAAA,CAAO,IAAI,CAAC;QAE9D,MAAM,kBAAsD,CAAC,CAAA;QAE7D,SAAS,IAAA,CAAK,EAAE,WAAA,CAAY,CAAC,MAAM,QAAQ;YACzC,IAAI,KAAK,IAAA,CAAK,IAAA,KAAS,MAAM;gBAC3B,gBAAgB,IAAA,CAAK;oBAAE;oBAAM;gBAAI,CAAC;YACpC;QACF,CAAC;QAED,MAAM,WAAW,gBAAgB,EAAA,CAAG,CAAA,CAAE;QAEtC,IAAI,CAAC,UAAU;YACb,OAAO;QACT;QAEA,MAAM,eAAe,OAAO,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,SAAS,KAAA,CAAM,IAAI,SAAS,GAAA,GAAM,CAAC;QAEjF,OAAO,OACJ,KAAA,CAAM,EACN,GAAA,CAAI;YAAE,MAAM,QAAQ,KAAA,CAAM,IAAI;YAAG,IAAI,QAAQ,GAAA,CAAI,IAAI;QAAE,GAAG,aAAa,GAAA,CAAI,CAAC,EAC5E,WAAA,CAAY,EACZ,GAAA,CAAI;IACT;IAIA,IAAI,KAAC,mNAAA,EAAa,OAAO,KAAA,EAAO,IAAI,GAAG;QACrC,OAAO;IACT;IAIA,IAAI,KAAC,sNAAA,EAAgB,OAAO,KAAK,GAAG;QAClC,OAAO;IACT;IAEA,MAAM,cAAc,gBAAgB,MAAM,OAAO,KAAK;IAEtD,IAAI,CAAC,aAAa;QAChB,OAAO;IACT;IAEA,MAAM,QAAQ,OAAO,KAAA,CAAM,GAAA,CAAI,OAAA,CAAQ,YAAY,IAAA,CAAK,GAAA,GAAM,CAAC;IAC/D,MAAM,WAAW,MAAM,IAAA,CAAK,YAAY,KAAK;IAE7C,MAAM,6BAA6B,mBAAmB,MAAM,OAAO,KAAA,EAAO,QAAQ;IAGlF,IAAI,kBAAkB,MAAM,OAAO,KAAK,KAAK,CAAC,4BAA4B;QACxE,OAAO,OAAO,QAAA,CAAS,gBAAA,CAAiB;IAC1C;IAKA,OAAO,OAAO,KAAA,CAAM,EAAE,YAAA,CAAa,IAAI,EAAE,GAAA,CAAI;AAC/C;;;AK/EO,IAAM,mBAAmB,CAAC,YAAoB,UAAuB;IAC1E,MAAM,YAAY,iBAAiB,YAAY,KAAK;IACpD,MAAM,cAAc,gBAAgB,YAAY,KAAK;IAErD,IAAI,CAAC,eAAe,CAAC,WAAW;QAC9B,OAAO;IACT;IAEA,IAAI,YAAY,YAAY,KAAA,EAAO;QACjC,OAAO;IACT;IAEA,OAAO;AACT;;ACbO,IAAM,mBAAmB,CAAC,YAAoB,UAAuB;IAC1E,MAAM,YAAY,iBAAiB,YAAY,KAAK;IACpD,MAAM,cAAc,gBAAgB,YAAY,KAAK;IAErD,IAAI,CAAC,eAAe,CAAC,WAAW;QAC9B,OAAO;IACT;IAEA,IAAI,YAAY,YAAY,KAAA,EAAO;QACjC,OAAO;IACT;IAEA,OAAO;AACT;;AFZO,IAAM,eAAe,CAAC,QAAgB,SAAiB;IAG5D,IAAI,KAACE,mNAAAA,EAAa,OAAO,KAAA,EAAO,IAAI,GAAG;QACrC,OAAO;IACT;IAIA,IAAI,CAAC,wNAAA,EAAc,OAAO,KAAA,EAAO,IAAI,GAAG;QACtC,OAAO;IACT;IAIA,MAAM,EAAE,SAAA,CAAU,CAAA,GAAI,OAAO,KAAA;IAC7B,MAAM,EAAE,KAAA,EAAO,GAAA,CAAI,CAAA,GAAI;IAEvB,IAAI,CAAC,UAAU,KAAA,IAAS,MAAM,UAAA,CAAW,GAAG,GAAG;QAC7C,OAAO;IACT;IAGA,IAAI,iBAAiB,MAAM,OAAO,KAAK,GAAG;QACxC,OAAO,OACJ,KAAA,CAAM,EACN,KAAA,CAAM,OAAO,KAAA,CAAM,SAAA,CAAU,IAAA,GAAO,CAAC,EACrC,IAAA,CAAK,IAAI,EACT,YAAA,CAAa,EACb,GAAA,CAAI;IACT;IAEA,IAAI,iBAAiB,MAAM,OAAO,KAAK,GAAG;QACxC,OAAO,OAAO,KAAA,CAAM,EAAE,WAAA,CAAY,EAAE,YAAA,CAAa,EAAE,GAAA,CAAI;IACzD;IAEA,OAAO,OAAO,QAAA,CAAS,eAAA,CAAgB;AACzC;;AGzCO,IAAM,mBAAmB,CAAC,YAAoB,UAAgC;IAFrF,IAAA;IAGE,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,MAAM,SAAA;IAE1B,MAAM,aAAa,MAAM,GAAA,CAAI,OAAA,CAAQ,QAAQ,GAAA,GAAM,QAAQ,YAAA,GAAe,CAAC;IAE3E,IAAI,WAAW,KAAA,CAAM,MAAM,WAAW,MAAA,CAAO,UAAA,GAAa,GAAG;QAC3D,OAAO;IACT;IAEA,IAAA,CAAA,CAAI,KAAA,WAAW,SAAA,KAAX,OAAA,KAAA,IAAA,GAAsB,IAAA,CAAK,IAAA,MAAS,YAAY;QAClD,OAAO;IACT;IAEA,OAAO;AACT;;AXOO,IAAM,aAAa,gNAAA,CAAU,MAAA,CAA0B;IAC5D,MAAM;IAEN,aAAa;QACX,OAAO;YACL,WAAW;gBACT;oBACE,UAAU;oBACV,cAAc;wBAAC;wBAAc,aAAa;qBAAA;gBAC5C;gBACA;oBACE,UAAU;oBACV,cAAc;wBAAC,UAAU;qBAAA;gBAC3B;aACF;QACF;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,QAAQ,CAAC,EAAE,MAAA,CAAO,CAAA,KAAM;gBACtB,IAAI,UAAU;gBAEd,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,OAAA,CAAQ,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAC/C,IAAI,OAAO,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,QAAQ,CAAA,KAAM,KAAA,GAAW;wBACrD;oBACF;oBAEA,IAAI,aAAa,QAAQ,QAAQ,GAAG;wBAClC,UAAU;oBACZ;gBACF,CAAC;gBAED,OAAO;YACT;YACA,cAAc,CAAC,EAAE,MAAA,CAAO,CAAA,KAAM;gBAC5B,IAAI,UAAU;gBAEd,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,OAAA,CAAQ,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAC/C,IAAI,OAAO,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,QAAQ,CAAA,KAAM,KAAA,GAAW;wBACrD;oBACF;oBAEA,IAAI,aAAa,QAAQ,QAAQ,GAAG;wBAClC,UAAU;oBACZ;gBACF,CAAC;gBAED,OAAO;YACT;YACA,WAAW,CAAC,EAAE,MAAA,CAAO,CAAA,KAAM;gBACzB,IAAI,UAAU;gBAEd,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,OAAA,CAAQ,CAAC,EAAE,QAAA,EAAU,YAAA,CAAa,CAAA,KAAM;oBAC7D,IAAI,OAAO,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,QAAQ,CAAA,KAAM,KAAA,GAAW;wBACrD;oBACF;oBAEA,IAAI,gBAAgB,QAAQ,UAAU,YAAY,GAAG;wBACnD,UAAU;oBACZ;gBACF,CAAC;gBAED,OAAO;YACT;YACA,iBAAiB,CAAC,EAAE,MAAA,CAAO,CAAA,KAAM;gBAC/B,IAAI,UAAU;gBAEd,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,OAAA,CAAQ,CAAC,EAAE,QAAA,EAAU,YAAA,CAAa,CAAA,KAAM;oBAC7D,IAAI,OAAO,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,QAAQ,CAAA,KAAM,KAAA,GAAW;wBACrD;oBACF;oBAEA,IAAI,gBAAgB,QAAQ,UAAU,YAAY,GAAG;wBACnD,UAAU;oBACZ;gBACF,CAAC;gBAED,OAAO;YACT;QACF;IACF;AACF,CAAC;;;;AclGD,IAAM,0BAA0B;AAMhC,IAAM,sBAAsB;AAoBrB,SAAS,wBAAwB,KAAA,EAA8C;IACpF,MAAM,YAA+B,CAAC,CAAA;IACtC,IAAI,mBAAmB;IACvB,IAAI,WAAW;IAEf,MAAO,mBAAmB,MAAM,MAAA,CAAQ;QACtC,MAAM,OAAO,KAAA,CAAM,gBAAgB,CAAA;QACnC,MAAM,QAAQ,KAAK,KAAA,CAAM,uBAAuB;QAEhD,IAAI,CAAC,OAAO;YACV;QACF;QAEA,MAAM,CAAC,EAAE,QAAQ,QAAQ,OAAO,CAAA,GAAI;QACpC,MAAM,cAAc,OAAO,MAAA;QAC3B,IAAI,cAAc;QAClB,IAAI,gBAAgB,mBAAmB;QACvC,MAAM,YAAY;YAAC,IAAI;SAAA;QAGvB,MAAO,gBAAgB,MAAM,MAAA,CAAQ;YACnC,MAAM,WAAW,KAAA,CAAM,aAAa,CAAA;YACpC,MAAM,YAAY,SAAS,KAAA,CAAM,uBAAuB;YAGxD,IAAI,WAAW;gBACb;YACF;YAGA,IAAI,SAAS,IAAA,CAAK,MAAM,IAAI;gBAE1B,UAAU,IAAA,CAAK,QAAQ;gBACvB,eAAe;gBACf,iBAAiB;YACnB,OAAA,IAAW,SAAS,KAAA,CAAM,mBAAmB,GAAG;gBAE9C,UAAU,IAAA,CAAK,QAAQ;gBACvB,eAAe,CAAA;AAAA,EAAK,SAAS,KAAA,CAAM,cAAc,CAAC,CAAC,EAAA;gBACnD,iBAAiB;YACnB,OAAO;gBAEL;YACF;QACF;QAEA,UAAU,IAAA,CAAK;YACb,QAAQ;YACR,QAAQ,SAAS,QAAQ,EAAE;YAC3B,SAAS,YAAY,IAAA,CAAK;YAC1B,KAAK,UAAU,IAAA,CAAK,IAAI;QAC1B,CAAC;QAED,WAAW;QACX,mBAAmB;IACrB;IAEA,OAAO;QAAC;QAAW,QAAQ;KAAA;AAC7B;AAYO,SAAS,qBACd,KAAA,EACA,UAAA,EACA,KAAA,EACW;IA3Gb,IAAA;IA4GE,MAAM,SAAoB,CAAC,CAAA;IAC3B,IAAI,eAAe;IAEnB,MAAO,eAAe,MAAM,MAAA,CAAQ;QAClC,MAAM,OAAO,KAAA,CAAM,YAAY,CAAA;QAE/B,IAAI,KAAK,MAAA,KAAW,YAAY;YAE9B,MAAM,eAAe,KAAK,OAAA,CAAQ,KAAA,CAAM,IAAI;YAC5C,MAAM,WAAA,CAAA,CAAW,KAAA,YAAA,CAAa,CAAC,CAAA,KAAd,OAAA,KAAA,IAAA,GAAiB,IAAA,EAAA,KAAU;YAE5C,MAAM,SAAS,CAAC,CAAA;YAGhB,IAAI,UAAU;gBACZ,OAAO,IAAA,CAAK;oBACV,MAAM;oBACN,KAAK;oBACL,QAAQ,MAAM,YAAA,CAAa,QAAQ;gBACrC,CAAC;YACH;YAGA,MAAM,oBAAoB,aAAa,KAAA,CAAM,CAAC,EAAE,IAAA,CAAK,IAAI,EAAE,IAAA,CAAK;YAChE,IAAI,mBAAmB;gBAErB,MAAM,cAAc,MAAM,WAAA,CAAY,iBAAiB;gBACvD,OAAO,IAAA,CAAK,GAAG,WAAW;YAC5B;YAGA,IAAI,iBAAiB,eAAe;YACpC,MAAM,cAAc,CAAC,CAAA;YAErB,MAAO,iBAAiB,MAAM,MAAA,IAAU,KAAA,CAAM,cAAc,CAAA,CAAE,MAAA,GAAS,WAAY;gBACjF,YAAY,IAAA,CAAK,KAAA,CAAM,cAAc,CAAC;gBACtC,kBAAkB;YACpB;YAGA,IAAI,YAAY,MAAA,GAAS,GAAG;gBAE1B,MAAM,aAAa,KAAK,GAAA,CAAI,GAAG,YAAY,GAAA,CAAI,CAAA,aAAc,WAAW,MAAM,CAAC;gBAI/E,MAAM,kBAAkB,qBAAqB,aAAa,YAAY,KAAK;gBAG3E,OAAO,IAAA,CAAK;oBACV,MAAM;oBACN,SAAS;oBACT,OAAO,WAAA,CAAY,CAAC,CAAA,CAAE,MAAA;oBACtB,OAAO;oBACP,KAAK,YAAY,GAAA,CAAI,CAAA,aAAc,WAAW,GAAG,EAAE,IAAA,CAAK,IAAI;gBAC9D,CAAC;YACH;YAEA,OAAO,IAAA,CAAK;gBACV,MAAM;gBACN,KAAK,KAAK,GAAA;gBACV;YACF,CAAC;YAGD,eAAe;QACjB,OAAO;YAGL,gBAAgB;QAClB;IACF;IAEA,OAAO;AACT;AAUO,SAAS,eAAe,KAAA,EAAwB,OAAA,EAA8C;IACnG,OAAO,MAAM,GAAA,CAAI,CAAA,SAAQ;QACvB,IAAI,KAAK,IAAA,KAAS,aAAa;YAC7B,OAAO,QAAQ,aAAA,CAAc;gBAAC,IAAI;aAAC,CAAA,CAAE,CAAC,CAAA;QACxC;QAGA,MAAM,UAAyB,CAAC,CAAA;QAEhC,IAAI,KAAK,MAAA,IAAU,KAAK,MAAA,CAAO,MAAA,GAAS,GAAG;YACzC,KAAK,MAAA,CAAO,OAAA,CAAQ,CAAA,cAAa;gBAE/B,IACE,UAAU,IAAA,KAAS,eACnB,UAAU,IAAA,KAAS,UACnB,UAAU,IAAA,KAAS,gBACnB,UAAU,IAAA,KAAS,QACnB;oBACA,QAAQ,IAAA,CAAK,GAAG,QAAQ,aAAA,CAAc;wBAAC,SAAS;qBAAC,CAAC;gBACpD,OAAA,IAAW,UAAU,IAAA,KAAS,UAAU,UAAU,MAAA,EAAQ;oBAExD,MAAM,gBAAgB,QAAQ,aAAA,CAAc;wBAAC,SAAS;qBAAC;oBACvD,QAAQ,IAAA,CAAK;wBACX,MAAM;wBACN,SAAS;oBACX,CAAC;gBACH,OAAO;oBAEL,MAAM,SAAS,QAAQ,aAAA,CAAc;wBAAC,SAAS;qBAAC;oBAChD,IAAI,OAAO,MAAA,GAAS,GAAG;wBACrB,QAAQ,IAAA,CAAK,GAAG,MAAM;oBACxB;gBACF;YACF,CAAC;QACH;QAEA,OAAO;YACL,MAAM;YACN;QACF;IACF,CAAC;AACH;;ADrOA,IAAMK,gBAAe;AACrB,IAAMC,iBAAgB;AA+Cf,IAAM,wBAAwB;AAQ9B,IAAM,cAAcC,2MAAAA,CAAK,MAAA,CAA2B;IACzD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,cAAc;YACd,gBAAgB,CAAC;YACjB,WAAW;YACX,gBAAgB;QAClB;IACF;IAEA,OAAO;IAEP,UAAU;QACR,OAAO,GAAG,IAAA,CAAK,OAAA,CAAQ,YAAY,CAAA,CAAA,CAAA;IACrC;IAEA,gBAAgB;QACd,OAAO;YACL,OAAO;gBACL,SAAS;gBACT,WAAW,CAAA,YAAW;oBACpB,OAAO,QAAQ,YAAA,CAAa,OAAO,IAAI,SAAS,QAAQ,YAAA,CAAa,OAAO,KAAK,IAAI,EAAE,IAAI;gBAC7F;YACF;YACA,MAAM;gBACJ,SAAS;gBACT,WAAW,CAAA,UAAW,QAAQ,YAAA,CAAa,MAAM;YACnD;QACF;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,MAAM,EAAE,KAAA,EAAO,GAAG,uBAAuB,CAAA,GAAI;QAE7C,OAAO,UAAU,IACb;YAAC;gBAAMC,sNAAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,sBAAsB;YAAG,CAAC;SAAA,GAC9E;YAAC;gBAAMA,sNAAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC5E;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QACjC,IAAI,MAAM,IAAA,KAAS,UAAU,CAAC,MAAM,OAAA,EAAS;YAC3C,OAAO,CAAC,CAAA;QACV;QAEA,MAAM,aAAa,MAAM,KAAA,IAAS;QAClC,MAAM,UAAU,MAAM,KAAA,GAAQ,eAAe,MAAM,KAAA,EAAO,OAAO,IAAI,CAAC,CAAA;QAEtE,IAAI,eAAe,GAAG;YACpB,OAAO;gBACL,MAAM;gBACN,OAAO;oBAAE,OAAO;gBAAW;gBAC3B;YACF;QACF;QAEA,OAAO;YACL,MAAM;YACN;QACF;IACF;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAEA,OAAO,EAAE,cAAA,CAAe,KAAK,OAAA,EAAS,IAAI;IAC5C;IAEA,mBAAmB;QACjB,MAAM;QACN,OAAO;QACP,OAAO,CAAC,QAAgB;YACtB,MAAM,QAAQ,IAAI,KAAA,CAAM,kBAAkB;YAC1C,MAAM,QAAQ,SAAA,OAAA,KAAA,IAAA,MAAO,KAAA;YACrB,OAAO,UAAU,KAAA,IAAY,QAAQ,CAAA;QACvC;QACA,UAAU,CAAC,KAAa,SAAS,UAAU;YArJ/C,IAAA;YAsJM,MAAM,QAAQ,IAAI,KAAA,CAAM,IAAI;YAC5B,MAAM,CAAC,WAAW,QAAQ,CAAA,GAAI,wBAAwB,KAAK;YAE3D,IAAI,UAAU,MAAA,KAAW,GAAG;gBAC1B,OAAO,KAAA;YACT;YAEA,MAAM,QAAQ,qBAAqB,WAAW,GAAG,KAAK;YAEtD,IAAI,MAAM,MAAA,KAAW,GAAG;gBACtB,OAAO,KAAA;YACT;YAEA,MAAM,aAAA,CAAA,CAAa,KAAA,SAAA,CAAU,CAAC,CAAA,KAAX,OAAA,KAAA,IAAA,GAAc,MAAA,KAAU;YAE3C,OAAO;gBACL,MAAM;gBACN,SAAS;gBACT,OAAO;gBACP;gBACA,KAAK,MAAM,KAAA,CAAM,GAAG,QAAQ,EAAE,IAAA,CAAK,IAAI;YACzC;QACF;IACF;IAEA,iBAAiB;QACf,gBAAgB;IAClB;IAEA,cAAc;QACZ,OAAO;YACL,mBACE,IACA,CAAC,EAAE,QAAA,EAAU,KAAA,CAAM,CAAA,KAAM;oBACvB,IAAI,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB;wBAC/B,OAAO,MAAM,EACV,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,YAAA,EAAc,IAAA,CAAK,OAAA,CAAQ,SAAS,EACvE,gBAAA,CAAiBH,eAAc,IAAA,CAAK,MAAA,CAAO,aAAA,CAAcC,cAAa,CAAC,EACvE,GAAA,CAAI;oBACT;oBACA,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,YAAA,EAAc,IAAA,CAAK,OAAA,CAAQ,SAAS;gBACzF;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,iBAAA,CAAkB;QAC9D;IACF;IAEA,gBAAgB;QACd,IAAI,gBAAYG,wNAAAA,EAAkB;YAChC,MAAM;YACN,MAAM,IAAA,CAAK,IAAA;YACX,eAAe,CAAA,QAAA,CAAU;oBAAE,OAAO,CAAC,KAAA,CAAM,CAAC,CAAA;gBAAE,CAAA;YAC5C,eAAe,CAAC,OAAO,OAAS,KAAK,UAAA,GAAa,KAAK,KAAA,CAAM,KAAA,KAAU,CAAC,KAAA,CAAM,CAAC,CAAA;QACjF,CAAC;QAED,IAAI,IAAA,CAAK,OAAA,CAAQ,SAAA,IAAa,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB;YACzD,gBAAYA,wNAAAA,EAAkB;gBAC5B,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;gBACX,WAAW,IAAA,CAAK,OAAA,CAAQ,SAAA;gBACxB,gBAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA;gBAC7B,eAAe,CAAA,QAAA,CAAU;wBAAE,OAAO,CAAC,KAAA,CAAM,CAAC,CAAA;wBAAG,GAAG,IAAA,CAAK,MAAA,CAAO,aAAA,CAAcH,cAAa,CAAA;oBAAE,CAAA;gBACzF,eAAe,CAAC,OAAO,OAAS,KAAK,UAAA,GAAa,KAAK,KAAA,CAAM,KAAA,KAAU,CAAC,KAAA,CAAM,CAAC,CAAA;gBAC/E,QAAQ,IAAA,CAAK,MAAA;YACf,CAAC;QACH;QACA,OAAO;YAAC,SAAS;SAAA;IACnB;AACF,CAAC;;AErKM,IAAM,aAAa;AAMnB,IAAM,WAAWK,2MAAAA,CAAK,MAAA,CAAwB;IACnD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,QAAQ;YACR,gBAAgB,CAAC;YACjB,kBAAkB;YAClB,MAAM,KAAA;QACR;IACF;IAEA,UAAU;QACR,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,GAAS,qBAAqB;IACpD;IAEA,UAAU;IAEV,gBAAgB;QACd,OAAO;YACL,SAAS;gBACP,SAAS;gBACT,aAAa;gBACb,WAAW,CAAA,YAAW;oBACpB,MAAM,cAAc,QAAQ,YAAA,CAAa,cAAc;oBAEvD,OAAO,gBAAgB,MAAM,gBAAgB;gBAC/C;gBACA,YAAY,CAAA,aAAA,CAAe;wBACzB,gBAAgB,WAAW,OAAA;oBAC7B,CAAA;YACF;QACF;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK,CAAA,cAAA,EAAiB,IAAA,CAAK,IAAI,CAAA,EAAA,CAAA;gBAC/B,UAAU;YACZ;SACF;IACF;IAEA,YAAW,EAAE,IAAA,EAAM,cAAA,CAAe,CAAA,EAAG;QACnC,OAAO;YACL;gBACAD,sNAAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,gBAAgB;gBAC3D,aAAa,IAAA,CAAK,IAAA;YACpB,CAAC;YACD;gBACE;gBACA;oBACE;oBACA;wBACE,MAAM;wBACN,SAAS,KAAK,KAAA,CAAM,OAAA,GAAU,YAAY;oBAC5C;iBACF;gBACA;oBAAC,MAAM;iBAAA;aACT;YACA;gBAAC;gBAAO,CAAC;aAAA;SACX;IACF;IAEA,eAAe,CAAC,OAAO,MAAM;QAE3B,MAAM,UAAU,CAAC,CAAA;QAGjB,IAAI,MAAM,MAAA,IAAU,MAAM,MAAA,CAAO,MAAA,GAAS,GAAG;YAE3C,QAAQ,IAAA,CAAK,EAAE,UAAA,CAAW,aAAa,CAAC,GAAG,EAAE,WAAA,CAAY,MAAM,MAAM,CAAC,CAAC;QACzE,OAAA,IAAW,MAAM,IAAA,EAAM;YAErB,QAAQ,IAAA,CAAK,EAAE,UAAA,CAAW,aAAa,CAAC,GAAG;gBAAC,EAAE,UAAA,CAAW,QAAQ;oBAAE,MAAM,MAAM,IAAA;gBAAK,CAAC,CAAC;aAAC,CAAC;QAC1F,OAAO;YAEL,QAAQ,IAAA,CAAK,EAAE,UAAA,CAAW,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;QAChD;QAGA,IAAI,MAAM,YAAA,IAAgB,MAAM,YAAA,CAAa,MAAA,GAAS,GAAG;YACvD,MAAM,gBAAgB,EAAE,aAAA,CAAc,MAAM,YAAY;YACxD,QAAQ,IAAA,CAAK,GAAG,aAAa;QAC/B;QAEA,OAAO,EAAE,UAAA,CAAW,YAAY;YAAE,SAAS,MAAM,OAAA,IAAW;QAAM,GAAG,OAAO;IAC9E;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAzJ/B,IAAA;QA0JI,MAAM,cAAA,CAAA,CAAc,KAAA,KAAK,KAAA,KAAL,OAAA,KAAA,IAAA,GAAY,OAAA,IAAU,MAAM;QAChD,MAAM,SAAS,CAAA,GAAA,EAAM,WAAW,CAAA,EAAA,CAAA;QAEhC,WAAOE,kOAAAA,EAA4B,MAAM,GAAG,MAAM;IACpD;IAEA,uBAAuB;QACrB,MAAM,YAEF;YACF,OAAO,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,aAAA,CAAc,IAAA,CAAK,IAAI;YACzD,aAAa,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa,IAAA,CAAK,IAAI;QAChE;QAEA,IAAI,CAAC,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ;YACxB,OAAO;QACT;QAEA,OAAO;YACL,GAAG,SAAA;YACH,KAAK,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa,IAAA,CAAK,IAAI;QACxD;IACF;IAEA,cAAc;QACZ,OAAO,CAAC,EAAE,IAAA,EAAM,cAAA,EAAgB,MAAA,EAAQ,MAAA,CAAO,CAAA,KAAM;YACnD,MAAM,WAAW,SAAS,aAAA,CAAc,IAAI;YAC5C,MAAM,kBAAkB,SAAS,aAAA,CAAc,OAAO;YACtD,MAAM,iBAAiB,SAAS,aAAA,CAAc,MAAM;YACpD,MAAM,WAAW,SAAS,aAAA,CAAc,OAAO;YAC/C,MAAM,UAAU,SAAS,aAAA,CAAc,KAAK;YAE5C,MAAM,aAAa,CAAC,gBAAiC;gBA1L3D,IAAA,IAAA;gBA2LQ,SAAS,SAAA,GAAA,CAAA,CACP,KAAA,CAAA,KAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,KAAb,OAAA,KAAA,IAAA,GAAmB,aAAA,KAAnB,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,IAAmC,aAAa,SAAS,OAAA,CAAA,KACzD,CAAA,uBAAA,EAA0B,YAAY,WAAA,IAAe,iBAAiB,EAAA;YAC1E;YAEA,WAAW,IAAI;YAEf,gBAAgB,eAAA,GAAkB;YAClC,SAAS,IAAA,GAAO;YAChB,SAAS,gBAAA,CAAiB,aAAa,CAAA,QAAS,MAAM,cAAA,CAAe,CAAC;YACtE,SAAS,gBAAA,CAAiB,UAAU,CAAA,UAAS;gBAG3C,IAAI,CAAC,OAAO,UAAA,IAAc,CAAC,IAAA,CAAK,OAAA,CAAQ,iBAAA,EAAmB;oBACzD,SAAS,OAAA,GAAU,CAAC,SAAS,OAAA;oBAE7B;gBACF;gBAEA,MAAM,EAAE,OAAA,CAAQ,CAAA,GAAI,MAAM,MAAA;gBAE1B,IAAI,OAAO,UAAA,IAAc,OAAO,WAAW,YAAY;oBACrD,OACG,KAAA,CAAM,EACN,KAAA,CAAM,KAAA,GAAW;wBAAE,gBAAgB;oBAAM,CAAC,EAC1C,OAAA,CAAQ,CAAC,EAAE,EAAA,CAAG,CAAA,KAAM;wBACnB,MAAM,WAAW,OAAO;wBAExB,IAAI,OAAO,aAAa,UAAU;4BAChC,OAAO;wBACT;wBACA,MAAM,cAAc,GAAG,GAAA,CAAI,MAAA,CAAO,QAAQ;wBAE1C,GAAG,aAAA,CAAc,UAAU,KAAA,GAAW;4BACpC,GAAG,eAAA,OAAA,KAAA,IAAA,YAAa,KAAA;4BAChB;wBACF,CAAC;wBAED,OAAO;oBACT,CAAC,EACA,GAAA,CAAI;gBACT;gBACA,IAAI,CAAC,OAAO,UAAA,IAAc,IAAA,CAAK,OAAA,CAAQ,iBAAA,EAAmB;oBAExD,IAAI,CAAC,IAAA,CAAK,OAAA,CAAQ,iBAAA,CAAkB,MAAM,OAAO,GAAG;wBAClD,SAAS,OAAA,GAAU,CAAC,SAAS,OAAA;oBAC/B;gBACF;YACF,CAAC;YAED,OAAO,OAAA,CAAQ,IAAA,CAAK,OAAA,CAAQ,cAAc,EAAE,OAAA,CAAQ,CAAC,CAAC,KAAK,KAAK,CAAA,KAAM;gBACpE,SAAS,YAAA,CAAa,KAAK,KAAK;YAClC,CAAC;YAED,SAAS,OAAA,CAAQ,OAAA,GAAU,KAAK,KAAA,CAAM,OAAA;YACtC,SAAS,OAAA,GAAU,KAAK,KAAA,CAAM,OAAA;YAE9B,gBAAgB,MAAA,CAAO,UAAU,cAAc;YAC/C,SAAS,MAAA,CAAO,iBAAiB,OAAO;YAExC,OAAO,OAAA,CAAQ,cAAc,EAAE,OAAA,CAAQ,CAAC,CAAC,KAAK,KAAK,CAAA,KAAM;gBACvD,SAAS,YAAA,CAAa,KAAK,KAAK;YAClC,CAAC;YAGD,IAAI,4BAA4B,IAAI,IAAI,OAAO,IAAA,CAAK,cAAc,CAAC;YAEnE,OAAO;gBACL,KAAK;gBACL,YAAY;gBACZ,QAAQ,CAAA,gBAAe;oBACrB,IAAI,YAAY,IAAA,KAAS,IAAA,CAAK,IAAA,EAAM;wBAClC,OAAO;oBACT;oBAEA,SAAS,OAAA,CAAQ,OAAA,GAAU,YAAY,KAAA,CAAM,OAAA;oBAC7C,SAAS,OAAA,GAAU,YAAY,KAAA,CAAM,OAAA;oBACrC,WAAW,WAAW;oBAGtB,MAAM,sBAAsB,OAAO,gBAAA,CAAiB,UAAA;oBACpD,MAAM,wBAAoB,4NAAA,EAAsB,aAAa,mBAAmB;oBAChF,MAAM,UAAU,IAAI,IAAI,OAAO,IAAA,CAAK,iBAAiB,CAAC;oBAItD,MAAM,cAAc,IAAA,CAAK,OAAA,CAAQ,cAAA;oBAEjC,0BAA0B,OAAA,CAAQ,CAAA,QAAO;wBACvC,IAAI,CAAC,QAAQ,GAAA,CAAI,GAAG,GAAG;4BACrB,IAAI,OAAO,aAAa;gCACtB,SAAS,YAAA,CAAa,KAAK,WAAA,CAAY,GAAG,CAAC;4BAC7C,OAAO;gCACL,SAAS,eAAA,CAAgB,GAAG;4BAC9B;wBACF;oBACF,CAAC;oBAGD,OAAO,OAAA,CAAQ,iBAAiB,EAAE,OAAA,CAAQ,CAAC,CAAC,KAAK,KAAK,CAAA,KAAM;wBAC1D,IAAI,UAAU,QAAQ,UAAU,KAAA,GAAW;4BAEzC,IAAI,OAAO,aAAa;gCACtB,SAAS,YAAA,CAAa,KAAK,WAAA,CAAY,GAAG,CAAC;4BAC7C,OAAO;gCACL,SAAS,eAAA,CAAgB,GAAG;4BAC9B;wBACF,OAAO;4BACL,SAAS,YAAA,CAAa,KAAK,KAAK;wBAClC;oBACF,CAAC;oBAGD,4BAA4B;oBAE5B,OAAO;gBACT;YACF;QACF;IACF;IAEA,gBAAgB;QACd,OAAO;gBACLC,wNAAAA,EAAkB;gBAChB,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;gBACX,eAAe,CAAA,QAAA,CAAU;wBACvB,SAAS,KAAA,CAAM,MAAM,MAAA,GAAS,CAAC,CAAA,KAAM;oBACvC,CAAA;YACF,CAAC;SACH;IACF;AACF,CAAC;;AC7RM,IAAM,WAAWE,2MAAAA,CAAK,MAAA,CAAwB;IACnD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,cAAc;YACd,gBAAgB,CAAC;QACnB;IACF;IAEA,OAAO;IAEP,UAAU;QACR,OAAO,GAAG,IAAA,CAAK,OAAA,CAAQ,YAAY,CAAA,CAAA,CAAA;IACrC;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK,CAAA,cAAA,EAAiB,IAAA,CAAK,IAAI,CAAA,EAAA,CAAA;gBAC/B,UAAU;YACZ;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;YAAMD,0NAAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,gBAAgB;gBAAE,aAAa,IAAA,CAAK,IAAA;YAAK,CAAC;YAAG,CAAC;SAAA;IAC3G;IAEA,eAAe,CAAC,OAAO,MAAM;QAC3B,OAAO,EAAE,UAAA,CAAW,YAAY,CAAC,GAAG,EAAE,aAAA,CAAc,MAAM,KAAA,IAAS,CAAC,CAAC,CAAC;IACxE;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,KAAK,OAAA,EAAS;YACjB,OAAO;QACT;QAEA,OAAO,EAAE,cAAA,CAAe,KAAK,OAAA,EAAS,IAAI;IAC5C;IAEA,mBAAmB;QACjB,MAAM;QACN,OAAO;QACP,OAAM,GAAA,EAAK;YA9Ef,IAAA;YAgFM,MAAM,QAAA,CAAQ,KAAA,IAAI,KAAA,CAAM,4BAA4B,CAAA,KAAtC,OAAA,KAAA,IAAA,GAAyC,KAAA;YACvD,OAAO,UAAU,KAAA,IAAY,QAAQ,CAAA;QACvC;QACA,UAAS,GAAA,EAAK,MAAA,EAAQ,KAAA,EAAO;YAE3B,MAAM,uBAAuB,CAAC,YAAuC;gBACnE,MAAM,mBAAe,0NAAA,EACnB,SACA;oBACE,aAAa;oBACb,iBAAiB,CAAA,QAAA,CAAU;4BACzB,aAAa,KAAA,CAAM,CAAC,CAAA,CAAE,MAAA;4BACtB,aAAa,KAAA,CAAM,CAAC,CAAA;4BACpB,SAAS,KAAA,CAAM,CAAC,CAAA,CAAE,WAAA,CAAY,MAAM;wBACtC,CAAA;oBACA,aAAa,CAAC,MAAM,eAAA,CAAkB;4BACpC,MAAM;4BACN,KAAK;4BACL,aAAa,KAAK,WAAA;4BAClB,aAAa,KAAK,WAAA;4BAClB,SAAS,KAAK,OAAA;4BACd,MAAM,KAAK,WAAA;4BACX,QAAQ,MAAM,YAAA,CAAa,KAAK,WAAW;4BAC3C;wBACF,CAAA;oBAAA,0BAAA;oBAEA,oBAAoB;gBACtB,GACA;gBAGF,IAAI,cAAc;oBAEhB,OAAO;wBACL;4BACE,MAAM;4BACN,KAAK,aAAa,GAAA;4BAClB,OAAO,aAAa,KAAA;wBACtB;qBACF;gBACF;gBAGA,OAAO,MAAM,WAAA,CAAY,OAAO;YAClC;YAEA,MAAM,aAAS,0NAAA,EACb,KACA;gBACE,aAAa;gBACb,iBAAiB,CAAA,QAAA,CAAU;wBACzB,aAAa,KAAA,CAAM,CAAC,CAAA,CAAE,MAAA;wBACtB,aAAa,KAAA,CAAM,CAAC,CAAA;wBACpB,SAAS,KAAA,CAAM,CAAC,CAAA,CAAE,WAAA,CAAY,MAAM;oBACtC,CAAA;gBACA,aAAa,CAAC,MAAM,eAAA,CAAkB;wBACpC,MAAM;wBACN,KAAK;wBACL,aAAa,KAAK,WAAA;wBAClB,aAAa,KAAK,WAAA;wBAClB,SAAS,KAAK,OAAA;wBACd,MAAM,KAAK,WAAA;wBACX,QAAQ,MAAM,YAAA,CAAa,KAAK,WAAW;wBAC3C;oBACF,CAAA;gBAAA,8CAAA;gBAEA,oBAAoB;YACtB,GACA;YAGF,IAAI,CAAC,QAAQ;gBACX,OAAO,KAAA;YACT;YAEA,OAAO;gBACL,MAAM;gBACN,KAAK,OAAO,GAAA;gBACZ,OAAO,OAAO,KAAA;YAChB;QACF;IACF;IAEA,iBAAiB;QACf,gBAAgB;IAClB;IAEA,cAAc;QACZ,OAAO;YACL,gBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,YAAY;gBACjE;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,cAAA,CAAe;QAC3D;IACF;AACF,CAAC;;AJtIM,IAAM,UAAUE,gNAAAA,CAAU,MAAA,CAAuB;IACtD,MAAM;IAEN,gBAAgB;QACd,MAAM,aAAa,CAAC,CAAA;QAEpB,IAAI,IAAA,CAAK,OAAA,CAAQ,UAAA,KAAe,OAAO;YACrC,WAAW,IAAA,CAAK,WAAW,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,UAAU,CAAC;QAC/D;QAEA,IAAI,IAAA,CAAK,OAAA,CAAQ,QAAA,KAAa,OAAO;YACnC,WAAW,IAAA,CAAK,SAAS,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAC;QAC3D;QAEA,IAAI,IAAA,CAAK,OAAA,CAAQ,UAAA,KAAe,OAAO;YACrC,WAAW,IAAA,CAAK,WAAW,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,UAAU,CAAC;QAC/D;QAEA,IAAI,IAAA,CAAK,OAAA,CAAQ,WAAA,KAAgB,OAAO;YACtC,WAAW,IAAA,CAAK,YAAY,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,WAAW,CAAC;QACjE;QAEA,IAAI,IAAA,CAAK,OAAA,CAAQ,QAAA,KAAa,OAAO;YACnC,WAAW,IAAA,CAAK,SAAS,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAC;QAC3D;QAEA,IAAI,IAAA,CAAK,OAAA,CAAQ,QAAA,KAAa,OAAO;YACnC,WAAW,IAAA,CAAK,SAAS,SAAA,CAAU,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAC;QAC3D;QAEA,OAAO;IACT;AACF,CAAC"}},
    {"offset": {"line": 2895, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-paragraph/src/paragraph.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-paragraph/src/index.ts"],"sourcesContent":["import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  /**\n   * The HTML attributes for a paragraph node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       * @example editor.commands.toggleParagraph()\n       */\n      setParagraph: () => ReturnType\n    }\n  }\n}\n\n/**\n * Markdown marker for empty paragraphs to preserve blank lines.\n * Using &nbsp; (non-breaking space HTML entity) ensures the paragraph\n * is not collapsed by markdown parsers while remaining human-readable.\n */\nconst EMPTY_PARAGRAPH_MARKDOWN = '&nbsp;'\n\n/**\n * Unicode character for non-breaking space (U+00A0).\n * Some markdown parsers may convert &nbsp; entities to this literal character.\n */\nconst NBSP_CHAR = '\\u00A0'\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [{ tag: 'p' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || []\n\n    // Special case: if paragraph contains only a single image token,\n    // unwrap it to avoid nesting block elements incorrectly\n    if (tokens.length === 1 && tokens[0].type === 'image') {\n      // Parse the image token directly as a block element\n      return helpers.parseChildren([tokens[0]])\n    }\n\n    // Parse the inline tokens\n    const content = helpers.parseInline(tokens)\n\n    // Special case: if paragraph contains only &nbsp; (non-breaking space),\n    // treat it as an empty paragraph to preserve blank lines\n    if (\n      content.length === 1 &&\n      content[0].type === 'text' &&\n      (content[0].text === EMPTY_PARAGRAPH_MARKDOWN || content[0].text === NBSP_CHAR)\n    ) {\n      return helpers.createNode('paragraph', undefined, [])\n    }\n\n    // Convert 'paragraph' token to paragraph node\n    return helpers.createNode('paragraph', undefined, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node) {\n      return ''\n    }\n\n    // Normalize content: treat undefined/null as empty array\n    const content = Array.isArray(node.content) ? node.content : []\n\n    // If the paragraph is empty, render a non-breaking space to preserve blank lines\n    if (content.length === 0) {\n      return EMPTY_PARAGRAPH_MARKDOWN\n    }\n\n    return h.renderChildren(content)\n  },\n\n  addCommands() {\n    return {\n      setParagraph:\n        () =>\n        ({ commands }) => {\n          return commands.setNode(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n","import { Paragraph } from './paragraph.js'\n\nexport * from './paragraph.js'\n\nexport default Paragraph\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,iBAAiB,YAAY;;AA4BtC,IAAM,2BAA2B;AAMjC,IAAM,YAAY;AAMX,IAAM,YAAY,2MAAA,CAAK,MAAA,CAAyB;IACrD,MAAM;IAEN,UAAU;IAEV,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,OAAO;IAEP,SAAS;IAET,YAAY;QACV,OAAO;YAAC;gBAAE,KAAK;YAAI,CAAC;SAAA;IACtB;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAK,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC9E;IAEA,eAAe,CAAC,OAAO,YAAY;QACjC,MAAM,SAAS,MAAM,MAAA,IAAU,CAAC,CAAA;QAIhC,IAAI,OAAO,MAAA,KAAW,KAAK,MAAA,CAAO,CAAC,CAAA,CAAE,IAAA,KAAS,SAAS;YAErD,OAAO,QAAQ,aAAA,CAAc;gBAAC,MAAA,CAAO,CAAC,CAAC;aAAC;QAC1C;QAGA,MAAM,UAAU,QAAQ,WAAA,CAAY,MAAM;QAI1C,IACE,QAAQ,MAAA,KAAW,KACnB,OAAA,CAAQ,CAAC,CAAA,CAAE,IAAA,KAAS,UAAA,CACnB,OAAA,CAAQ,CAAC,CAAA,CAAE,IAAA,KAAS,4BAA4B,OAAA,CAAQ,CAAC,CAAA,CAAE,IAAA,KAAS,SAAA,GACrE;YACA,OAAO,QAAQ,UAAA,CAAW,aAAa,KAAA,GAAW,CAAC,CAAC;QACtD;QAGA,OAAO,QAAQ,UAAA,CAAW,aAAa,KAAA,GAAW,OAAO;IAC3D;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,IAAI,CAAC,MAAM;YACT,OAAO;QACT;QAGA,MAAM,UAAU,MAAM,OAAA,CAAQ,KAAK,OAAO,IAAI,KAAK,OAAA,GAAU,CAAC,CAAA;QAG9D,IAAI,QAAQ,MAAA,KAAW,GAAG;YACxB,OAAO;QACT;QAEA,OAAO,EAAE,cAAA,CAAe,OAAO;IACjC;IAEA,cAAc;QACZ,OAAO;YACL,cACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,aAAa,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;QACvD;IACF;AACF,CAAC;;ACrHD,IAAO,gBAAQ"}},
    {"offset": {"line": 2974, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-strike/src/strike.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-strike/src/index.ts"],"sourcesContent":["import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface StrikeOptions {\n  /**\n   * HTML attributes to add to the strike element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       * @example editor.commands.setStrike()\n       */\n      setStrike: () => ReturnType\n      /**\n       * Toggle a strike mark\n       * @example editor.commands.toggleStrike()\n       */\n      toggleStrike: () => ReturnType\n      /**\n       * Unset a strike mark\n       * @example editor.commands.unsetStrike()\n       */\n      unsetStrike: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nexport const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/\n\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g\n\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'del',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'del' token to strike mark\n    return helpers.applyMark('strike', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`\n  },\n\n  addCommands() {\n    return {\n      setStrike:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleStrike:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetStrike:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Strike } from './strike.js'\n\nexport * from './strike.js'\n\nexport default Strike\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,MAAM,eAAe,eAAe,uBAAuB;;AAoC7D,IAAM,aAAa;AAKnB,IAAM,aAAa;AAMnB,IAAM,SAAS,2MAAA,CAAK,MAAA,CAAsB;IAC/C,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;YACA;gBACE,KAAK;YACP;YACA;gBACE,KAAK;YACP;YACA;gBACE,OAAO;gBACP,WAAW;gBACX,UAAU,CAAA,QAAW,MAAiB,QAAA,CAAS,cAAc,IAAI,CAAC,IAAI;YACxE;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAK,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC9E;IAEA,mBAAmB;IAEnB,eAAe,CAAC,OAAO,YAAY;QAEjC,OAAO,QAAQ,SAAA,CAAU,UAAU,QAAQ,WAAA,CAAY,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IAC5E;IAEA,gBAAgB,CAAC,MAAM,MAAM;QAC3B,OAAO,CAAA,EAAA,EAAK,EAAE,cAAA,CAAe,IAAI,CAAC,CAAA,EAAA,CAAA;IACpC;IAEA,cAAc;QACZ,OAAO;YACL,WACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;YACF,cACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,aACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,eAAe,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,CAAa;QACzD;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;IAEA,gBAAgB;QACd,OAAO;gBACL,oNAAA,EAAc;gBACZ,MAAM;gBACN,MAAM,IAAA,CAAK,IAAA;YACb,CAAC;SACH;IACF;AACF,CAAC;;ACjID,IAAO,gBAAQ"}},
    {"offset": {"line": 3071, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-text/src/text.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-text/src/index.ts"],"sourcesContent":["import { Node } from '@tiptap/core'\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n\n  parseMarkdown: token => {\n    // Convert 'text' token to text node - text nodes are special as they store text directly\n    return {\n      type: 'text',\n      text: token.text || '',\n    }\n  },\n\n  renderMarkdown: node => node.text || '',\n})\n","import { Text } from './text.js'\n\nexport * from './text.js'\n\nexport default Text\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,YAAY;;AAMd,IAAM,OAAO,2MAAA,CAAK,MAAA,CAAO;IAC9B,MAAM;IACN,OAAO;IAEP,eAAe,CAAA,UAAS;QAEtB,OAAO;YACL,MAAM;YACN,MAAM,MAAM,IAAA,IAAQ;QACtB;IACF;IAEA,gBAAgB,CAAA,OAAQ,KAAK,IAAA,IAAQ;AACvC,CAAC;;ACfD,IAAO,gBAAQ"}},
    {"offset": {"line": 3099, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-underline/src/underline.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extension-underline/src/index.ts"],"sourcesContent":["import { Mark, mergeAttributes } from '@tiptap/core'\n\nexport interface UnderlineOptions {\n  /**\n   * HTML attributes to add to the underline element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    underline: {\n      /**\n       * Set an underline mark\n       * @example editor.commands.setUnderline()\n       */\n      setUnderline: () => ReturnType\n      /**\n       * Toggle an underline mark\n       * @example editor.commands.toggleUnderline()\n       */\n      toggleUnderline: () => ReturnType\n      /**\n       * Unset an underline mark\n       * @example editor.commands.unsetUnderline()\n       */\n      unsetUnderline: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nexport const Underline = Mark.create<UnderlineOptions>({\n  name: 'underline',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'u',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('underline') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || 'underline', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`\n  },\n\n  markdownTokenizer: {\n    name: 'underline',\n    level: 'inline',\n    start(src) {\n      return src.indexOf('++')\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/\n      const match = rule.exec(src)\n\n      if (!match) {\n        return undefined\n      }\n\n      const innerContent = match[2].trim()\n\n      return {\n        type: 'underline',\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent),\n      }\n    },\n  },\n\n  addCommands() {\n    return {\n      setUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-u': () => this.editor.commands.toggleUnderline(),\n      'Mod-U': () => this.editor.commands.toggleUnderline(),\n    }\n  },\n})\n","import { Underline } from './underline.js'\n\nexport * from './underline.js'\n\nexport default Underline\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,MAAM,uBAAuB;;AAqC/B,IAAM,YAAY,2MAAA,CAAK,MAAA,CAAyB;IACrD,MAAM;IAEN,aAAa;QACX,OAAO;YACL,gBAAgB,CAAC;QACnB;IACF;IAEA,YAAY;QACV,OAAO;YACL;gBACE,KAAK;YACP;YACA;gBACE,OAAO;gBACP,WAAW;gBACX,UAAU,CAAA,QAAW,MAAiB,QAAA,CAAS,WAAW,IAAI,CAAC,IAAI;YACrE;SACF;IACF;IAEA,YAAW,EAAE,cAAA,CAAe,CAAA,EAAG;QAC7B,OAAO;YAAC;gBAAK,sNAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,cAAA,EAAgB,cAAc;YAAG,CAAC;SAAA;IAC9E;IAEA,eAAc,KAAA,EAAO,OAAA,EAAS;QAC5B,OAAO,QAAQ,SAAA,CAAU,IAAA,CAAK,IAAA,IAAQ,aAAa,QAAQ,WAAA,CAAY,MAAM,MAAA,IAAU,CAAC,CAAC,CAAC;IAC5F;IAEA,gBAAe,IAAA,EAAM,OAAA,EAAS;QAC5B,OAAO,CAAA,EAAA,EAAK,QAAQ,cAAA,CAAe,IAAI,CAAC,CAAA,EAAA,CAAA;IAC1C;IAEA,mBAAmB;QACjB,MAAM;QACN,OAAO;QACP,OAAM,GAAA,EAAK;YACT,OAAO,IAAI,OAAA,CAAQ,IAAI;QACzB;QACA,UAAS,GAAA,EAAK,OAAA,EAAS,KAAA,EAAO;YAC5B,MAAM,OAAO;YACb,MAAM,QAAQ,KAAK,IAAA,CAAK,GAAG;YAE3B,IAAI,CAAC,OAAO;gBACV,OAAO,KAAA;YACT;YAEA,MAAM,eAAe,KAAA,CAAM,CAAC,CAAA,CAAE,IAAA,CAAK;YAEnC,OAAO;gBACL,MAAM;gBACN,KAAK,KAAA,CAAM,CAAC,CAAA;gBACZ,MAAM;gBACN,QAAQ,MAAM,YAAA,CAAa,YAAY;YACzC;QACF;IACF;IAEA,cAAc;QACZ,OAAO;YACL,cACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACnC;YACF,iBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,UAAA,CAAW,IAAA,CAAK,IAAI;gBACtC;YACF,gBACE,IACA,CAAC,EAAE,QAAA,CAAS,CAAA,KAAM;oBAChB,OAAO,SAAS,SAAA,CAAU,IAAA,CAAK,IAAI;gBACrC;QACJ;IACF;IAEA,uBAAuB;QACrB,OAAO;YACL,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,eAAA,CAAgB;YACpD,SAAS,IAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,eAAA,CAAgB;QACtD;IACF;AACF,CAAC;;ACtHD,IAAO,gBAAQ"}},
    {"offset": {"line": 3189, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/character-count/character-count.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/drop-cursor/drop-cursor.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/focus/focus.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/gap-cursor/gap-cursor.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/placeholder/placeholder.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/selection/selection.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/trailing-node/trailing-node.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/extensions/src/undo-redo/undo-redo.ts"],"sourcesContent":["import { Extension } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface CharacterCountOptions {\n  /**\n   * The maximum number of characters that should be allowed. Defaults to `0`.\n   * @default null\n   * @example 180\n   */\n  limit: number | null | undefined\n  /**\n   * The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   * If set to `nodeSize`, the nodeSize of the document is used.\n   * @default 'textSize'\n   * @example 'textSize'\n   */\n  mode: 'textSize' | 'nodeSize'\n  /**\n   * The text counter function to use. Defaults to a simple character count.\n   * @default (text) => text.length\n   * @example (text) => [...new Intl.Segmenter().segment(text)].length\n   */\n  textCounter: (text: string) => number\n  /**\n   * The word counter function to use. Defaults to a simple word count.\n   * @default (text) => text.split(' ').filter(word => word !== '').length\n   * @example (text) => text.split(/\\s+/).filter(word => word !== '').length\n   */\n  wordCounter: (text: string) => number\n}\n\nexport interface CharacterCountStorage {\n  /**\n   * Get the number of characters for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the characters from. Defaults to the current document.\n   * @param options.mode The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   */\n  characters: (options?: { node?: ProseMirrorNode; mode?: 'textSize' | 'nodeSize' }) => number\n\n  /**\n   * Get the number of words for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the words from. Defaults to the current document.\n   */\n  words: (options?: { node?: ProseMirrorNode }) => number\n}\n\ndeclare module '@tiptap/core' {\n  interface Storage {\n    characterCount: CharacterCountStorage\n  }\n}\n\n/**\n * This extension allows you to count the characters and words of your document.\n * @see https://tiptap.dev/api/extensions/character-count\n */\nexport const CharacterCount = Extension.create<CharacterCountOptions, CharacterCountStorage>({\n  name: 'characterCount',\n\n  addOptions() {\n    return {\n      limit: null,\n      mode: 'textSize',\n      textCounter: text => text.length,\n      wordCounter: text => text.split(' ').filter(word => word !== '').length,\n    }\n  },\n\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0,\n    }\n  },\n\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = options?.node || this.editor.state.doc\n      const mode = options?.mode || this.options.mode\n\n      if (mode === 'textSize') {\n        const text = node.textBetween(0, node.content.size, undefined, ' ')\n\n        return this.options.textCounter(text)\n      }\n\n      return node.nodeSize\n    }\n\n    this.storage.words = options => {\n      const node = options?.node || this.editor.state.doc\n      const text = node.textBetween(0, node.content.size, ' ', ' ')\n\n      return this.options.wordCounter(text)\n    }\n  },\n\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('characterCount'),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return\n          }\n\n          const limit = this.options.limit\n\n          if (limit === null || limit === undefined || limit === 0) {\n            initialEvaluationDone = true\n            return\n          }\n\n          const initialContentSize = this.storage.characters({ node: newState.doc })\n\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit\n            const from = 0\n            const to = over\n\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`,\n            )\n            const tr = newState.tr.deleteRange(from, to)\n\n            initialEvaluationDone = true\n            return tr\n          }\n\n          initialEvaluationDone = true\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit\n\n          // Nothing has changed or no limit is defined. Ignore it.\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {\n            return true\n          }\n\n          const oldSize = this.storage.characters({ node: state.doc })\n          const newSize = this.storage.characters({ node: transaction.doc })\n\n          // Everything is in the limit. Good.\n          if (newSize <= limit) {\n            return true\n          }\n\n          // The limit has already been exceeded but will be reduced.\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true\n          }\n\n          // The limit has already been exceeded and will be increased further.\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false\n          }\n\n          const isPaste = transaction.getMeta('paste')\n\n          // Block all exceeding transactions that were not pasted.\n          if (!isPaste) {\n            return false\n          }\n\n          // For pasted content, we try to remove the exceeding content.\n          const pos = transaction.selection.$head.pos\n          const over = newSize - limit\n          const from = pos - over\n          const to = pos\n\n          // Itâ€™s probably a bad idea to mutate transactions within `filterTransaction`\n          // but for now this is working fine.\n          transaction.deleteRange(from, to)\n\n          // In some situations, the limit will continue to be exceeded after trimming.\n          // This happens e.g. when truncating within a complex node (e.g. table)\n          // and ProseMirror has to close this node again.\n          // If this is the case, we prevent the transaction completely.\n          const updatedSize = this.storage.characters({ node: transaction.doc })\n\n          if (updatedSize > limit) {\n            return false\n          }\n\n          return true\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { dropCursor } from '@tiptap/pm/dropcursor'\n\nexport interface DropcursorOptions {\n  /**\n   * The color of the drop cursor. Use `false` to apply no color and rely only on class.\n   * @default 'currentColor'\n   * @example 'red'\n   */\n  color?: string | false\n\n  /**\n   * The width of the drop cursor\n   * @default 1\n   * @example 2\n   */\n  width: number | undefined\n\n  /**\n   * The class of the drop cursor\n   * @default undefined\n   * @example 'drop-cursor'\n   */\n  class: string | undefined\n}\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * in-between nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */\nexport const Dropcursor = Extension.create<DropcursorOptions>({\n  name: 'dropCursor',\n\n  addOptions() {\n    return {\n      color: 'currentColor',\n      width: 1,\n      class: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [dropCursor(this.options)]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport interface FocusOptions {\n  /**\n   * The class name that should be added to the focused node.\n   * @default 'has-focus'\n   * @example 'is-focused'\n   */\n  className: string\n\n  /**\n   * The mode by which the focused node is determined.\n   * - All: All nodes are marked as focused.\n   * - Deepest: Only the deepest node is marked as focused.\n   * - Shallowest: Only the shallowest node is marked as focused.\n   *\n   * @default 'all'\n   * @example 'deepest'\n   * @example 'shallowest'\n   */\n  mode: 'all' | 'deepest' | 'shallowest'\n}\n\n/**\n * This extension allows you to add a class to the focused node.\n * @see https://www.tiptap.dev/api/extensions/focus\n */\nexport const Focus = Extension.create<FocusOptions>({\n  name: 'focus',\n\n  addOptions() {\n    return {\n      className: 'has-focus',\n      mode: 'all',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('focus'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!isEditable || !isFocused) {\n              return DecorationSet.create(doc, [])\n            }\n\n            // Maximum Levels\n            let maxLevels = 0\n\n            if (this.options.mode === 'deepest') {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return\n                }\n\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n                if (!isCurrent) {\n                  return false\n                }\n\n                maxLevels += 1\n              })\n            }\n\n            // Loop through current\n            let currentLevel = 0\n\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false\n              }\n\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n              if (!isCurrent) {\n                return false\n              }\n\n              currentLevel += 1\n\n              const outOfScope =\n                (this.options.mode === 'deepest' && maxLevels - currentLevel > 0) ||\n                (this.options.mode === 'shallowest' && currentLevel > 1)\n\n              if (outOfScope) {\n                return this.options.mode === 'deepest'\n              }\n\n              decorations.push(\n                Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className,\n                }),\n              )\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n","import type { ParentConfig } from '@tiptap/core'\nimport { callOrReturn, Extension, getExtensionField } from '@tiptap/core'\nimport { gapCursor } from '@tiptap/pm/gapcursor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A function to determine whether the gap cursor is allowed at the current position. Must return `true` or `false`.\n     * @default null\n     */\n    allowGapCursor?:\n      | boolean\n      | null\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options>>['allowGapCursor']\n        }) => boolean | null)\n  }\n}\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nexport const Gapcursor = Extension.create({\n  name: 'gapCursor',\n\n  addProseMirrorPlugins() {\n    return [gapCursor()]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      allowGapCursor: callOrReturn(getExtensionField(extension, 'allowGapCursor', context)) ?? null,\n    }\n  },\n})\n","import type { Editor } from '@tiptap/core'\nimport { Extension, isNodeEmpty } from '@tiptap/core'\nimport type { Node as ProsemirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\n/**\n * The default data attribute label\n */\nconst DEFAULT_DATA_ATTRIBUTE = 'placeholder'\n\n/**\n * Prepares the placeholder attribute by ensuring it is properly formatted.\n * @param attr - The placeholder attribute string.\n * @returns The prepared placeholder attribute string.\n */\nexport function preparePlaceholderAttribute(attr: string): string {\n  return (\n    attr\n      // replace whitespace with dashes\n      .replace(/\\s+/g, '-')\n      // replace non-alphanumeric  characters\n      // or special chars like $, %, &, etc.\n      // but not dashes\n      .replace(/[^a-zA-Z0-9-]/g, '')\n      // and replace any numeric character at the start\n      .replace(/^[0-9-]+/, '')\n      // and finally replace any stray, leading dashes\n      .replace(/^-+/, '')\n      .toLowerCase()\n  )\n}\n\nexport interface PlaceholderOptions {\n  /**\n   * **The class name for the empty editor**\n   * @default 'is-editor-empty'\n   */\n  emptyEditorClass: string\n\n  /**\n   * **The class name for empty nodes**\n   * @default 'is-empty'\n   */\n  emptyNodeClass: string\n\n  /**\n   * **The data-attribute used for the placeholder label**\n   * Will be prepended with `data-` and converted to kebab-case and cleaned of special characters.\n   * @default 'placeholder'\n   */\n  dataAttribute: string\n\n  /**\n   * **The placeholder content**\n   *\n   * You can use a function to return a dynamic placeholder or a string.\n   * @default 'Write something â€¦'\n   */\n  placeholder:\n    | ((PlaceholderProps: { editor: Editor; node: ProsemirrorNode; pos: number; hasAnchor: boolean }) => string)\n    | string\n\n  /**\n   * **Checks if the placeholder should be only shown when the editor is editable.**\n   *\n   * If true, the placeholder will only be shown when the editor is editable.\n   * If false, the placeholder will always be shown.\n   * @default true\n   */\n  showOnlyWhenEditable: boolean\n\n  /**\n   * **Checks if the placeholder should be only shown when the current node is empty.**\n   *\n   * If true, the placeholder will only be shown when the current node is empty.\n   * If false, the placeholder will be shown when any node is empty.\n   * @default true\n   */\n  showOnlyCurrent: boolean\n\n  /**\n   * **Controls if the placeholder should be shown for all descendents.**\n   *\n   * If true, the placeholder will be shown for all descendents.\n   * If false, the placeholder will only be shown for the current node.\n   * @default false\n   */\n  includeChildren: boolean\n}\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: 'placeholder',\n\n  addOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      dataAttribute: DEFAULT_DATA_ATTRIBUTE,\n      placeholder: 'Write something â€¦',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const dataAttribute = this.options.dataAttribute\n      ? `data-${preparePlaceholderAttribute(this.options.dataAttribute)}`\n      : `data-${DEFAULT_DATA_ATTRIBUTE}`\n\n    return [\n      new Plugin({\n        key: new PluginKey('placeholder'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!active) {\n              return null\n            }\n\n            const isEmptyDoc = this.editor.isEmpty\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize\n              const isEmpty = !node.isLeaf && isNodeEmpty(node)\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass]\n\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass)\n                }\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(' '),\n                  [dataAttribute]:\n                    typeof this.options.placeholder === 'function'\n                      ? this.options.placeholder({\n                          editor: this.editor,\n                          node,\n                          pos,\n                          hasAnchor,\n                        })\n                      : this.options.placeholder,\n                })\n\n                decorations.push(decoration)\n              }\n\n              return this.options.includeChildren\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension, isNodeSelection } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport type SelectionOptions = {\n  /**\n   * The class name that should be added to the selected text.\n   * @default 'selection'\n   * @example 'is-selected'\n   */\n  className: string\n}\n\n/**\n * This extension allows you to add a class to the selected text.\n * @see https://www.tiptap.dev/api/extensions/selection\n */\nexport const Selection = Extension.create<SelectionOptions>({\n  name: 'selection',\n\n  addOptions() {\n    return {\n      className: 'selection',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const { editor, options } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('selection'),\n        props: {\n          decorations(state) {\n            if (\n              state.selection.empty ||\n              editor.isFocused ||\n              !editor.isEditable ||\n              isNodeSelection(state.selection) ||\n              editor.view.dragging\n            ) {\n              return null\n            }\n\n            return DecorationSet.create(state.doc, [\n              Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className,\n              }),\n            ])\n          },\n        },\n      }),\n    ]\n  },\n})\n\nexport default Selection\n","import { Extension } from '@tiptap/core'\nimport type { Node, NodeType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nfunction nodeEqualsType({ types, node }: { types: NodeType | NodeType[]; node: Node | null | undefined }) {\n  return (node && Array.isArray(types) && types.includes(node.type)) || node?.type === types\n}\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  /**\n   * The node type that should be inserted at the end of the document.\n   * @note the node will always be added to the `notAfter` lists to\n   * prevent an infinite loop.\n   * @default undefined\n   */\n  node?: string\n  /**\n   * The node types after which the trailing node should not be inserted.\n   * @default ['paragraph']\n   */\n  notAfter?: string | string[]\n}\n\n/**\n * This extension allows you to add an extra node at the end of the document.\n * @see https://www.tiptap.dev/api/extensions/trailing-node\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: 'trailingNode',\n\n  addOptions() {\n    return {\n      node: undefined,\n      notAfter: [],\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name)\n    const defaultNode =\n      this.options.node || this.editor.schema.topNodeType.contentMatch.defaultType?.name || 'paragraph'\n\n    const disabledNodes = Object.entries(this.editor.schema.nodes)\n      .map(([, value]) => value)\n      .filter(node => (this.options.notAfter || []).concat(defaultNode).includes(node.name))\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state\n          const shouldInsertNodeAtEnd = plugin.getState(state)\n          const endPosition = doc.content.size\n          const type = schema.nodes[defaultNode]\n\n          if (!shouldInsertNodeAtEnd) {\n            return\n          }\n\n          return tr.insert(endPosition, type.create())\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value\n            }\n\n            // Ignore transactions from UniqueID extension to prevent infinite loops\n            // when UniqueID adds IDs to newly inserted trailing nodes\n            if (tr.getMeta('__uniqueIDTransaction')) {\n              return value\n            }\n\n            const lastNode = tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { history, redo, undo } from '@tiptap/pm/history'\n\nexport interface UndoRedoOptions {\n  /**\n   * The amount of history events that are collected before the oldest events are discarded.\n   * @default 100\n   * @example 50\n   */\n  depth: number\n\n  /**\n   * The delay (in milliseconds) between changes after which a new group should be started.\n   * @default 500\n   * @example 1000\n   */\n  newGroupDelay: number\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoRedo: {\n      /**\n       * Undo recent changes\n       * @example editor.commands.undo()\n       */\n      undo: () => ReturnType\n      /**\n       * Reapply reverted changes\n       * @example editor.commands.redo()\n       */\n      redo: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/undo-redo\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `undo-redo` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nexport const UndoRedo = Extension.create<UndoRedoOptions>({\n  name: 'undoRedo',\n\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500,\n    }\n  },\n\n  addCommands() {\n    return {\n      undo:\n        () =>\n        ({ state, dispatch }) => {\n          return undo(state, dispatch)\n        },\n      redo:\n        () =>\n        ({ state, dispatch }) => {\n          return redo(state, dispatch)\n        },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [history(this.options)]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n      'Mod-y': () => this.editor.commands.redo(),\n\n      // Russian keyboard layouts\n      'Mod-Ñ': () => this.editor.commands.undo(),\n      'Shift-Mod-Ñ': () => this.editor.commands.redo(),\n    }\n  },\n})\n"],"names":["Extension","Extension","Plugin","PluginKey","Extension","Extension","Plugin","PluginKey","Decoration","DecorationSet","Extension","Plugin","PluginKey","Decoration","DecorationSet","Extension","Plugin","PluginKey","Extension"],"mappings":"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"}},
    {"offset": {"line": 3617, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/starter-kit/src/starter-kit.ts","file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tiptap/starter-kit/src/index.ts"],"sourcesContent":["import { Extension } from '@tiptap/core'\nimport type { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport { Blockquote } from '@tiptap/extension-blockquote'\nimport type { BoldOptions } from '@tiptap/extension-bold'\nimport { Bold } from '@tiptap/extension-bold'\nimport type { CodeOptions } from '@tiptap/extension-code'\nimport { Code } from '@tiptap/extension-code'\nimport type { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport { CodeBlock } from '@tiptap/extension-code-block'\nimport { Document } from '@tiptap/extension-document'\nimport type { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport { HardBreak } from '@tiptap/extension-hard-break'\nimport type { HeadingOptions } from '@tiptap/extension-heading'\nimport { Heading } from '@tiptap/extension-heading'\nimport type { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport { HorizontalRule } from '@tiptap/extension-horizontal-rule'\nimport type { ItalicOptions } from '@tiptap/extension-italic'\nimport { Italic } from '@tiptap/extension-italic'\nimport type { LinkOptions } from '@tiptap/extension-link'\nimport { Link } from '@tiptap/extension-link'\nimport type { BulletListOptions, ListItemOptions, ListKeymapOptions, OrderedListOptions } from '@tiptap/extension-list'\nimport { BulletList, ListItem, ListKeymap, OrderedList } from '@tiptap/extension-list'\nimport type { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport { Paragraph } from '@tiptap/extension-paragraph'\nimport type { StrikeOptions } from '@tiptap/extension-strike'\nimport { Strike } from '@tiptap/extension-strike'\nimport { Text } from '@tiptap/extension-text'\nimport type { UnderlineOptions } from '@tiptap/extension-underline'\nimport { Underline } from '@tiptap/extension-underline'\nimport type { DropcursorOptions, TrailingNodeOptions, UndoRedoOptions } from '@tiptap/extensions'\nimport { Dropcursor, Gapcursor, TrailingNode, UndoRedo } from '@tiptap/extensions'\n\nexport interface StarterKitOptions {\n  /**\n   * If set to false, the blockquote extension will not be registered\n   * @example blockquote: false\n   */\n  blockquote: Partial<BlockquoteOptions> | false\n\n  /**\n   * If set to false, the bold extension will not be registered\n   * @example bold: false\n   */\n  bold: Partial<BoldOptions> | false\n\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example bulletList: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n\n  /**\n   * If set to false, the code extension will not be registered\n   * @example code: false\n   */\n  code: Partial<CodeOptions> | false\n\n  /**\n   * If set to false, the codeBlock extension will not be registered\n   * @example codeBlock: false\n   */\n  codeBlock: Partial<CodeBlockOptions> | false\n\n  /**\n   * If set to false, the document extension will not be registered\n   * @example document: false\n   */\n  document: false\n\n  /**\n   * If set to false, the dropcursor extension will not be registered\n   * @example dropcursor: false\n   */\n  dropcursor: Partial<DropcursorOptions> | false\n\n  /**\n   * If set to false, the gapcursor extension will not be registered\n   * @example gapcursor: false\n   */\n  gapcursor: false\n\n  /**\n   * If set to false, the hardBreak extension will not be registered\n   * @example hardBreak: false\n   */\n  hardBreak: Partial<HardBreakOptions> | false\n\n  /**\n   * If set to false, the heading extension will not be registered\n   * @example heading: false\n   */\n  heading: Partial<HeadingOptions> | false\n\n  /**\n   * If set to false, the undo-redo extension will not be registered\n   * @example undoRedo: false\n   */\n  undoRedo: Partial<UndoRedoOptions> | false\n\n  /**\n   * If set to false, the horizontalRule extension will not be registered\n   * @example horizontalRule: false\n   */\n  horizontalRule: Partial<HorizontalRuleOptions> | false\n\n  /**\n   * If set to false, the italic extension will not be registered\n   * @example italic: false\n   */\n  italic: Partial<ItalicOptions> | false\n\n  /**\n   * If set to false, the listItem extension will not be registered\n   * @example listItem: false\n   */\n  listItem: Partial<ListItemOptions> | false\n\n  /**\n   * If set to false, the listItemKeymap extension will not be registered\n   * @example listKeymap: false\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n\n  /**\n   * If set to false, the link extension will not be registered\n   * @example link: false\n   */\n  link: Partial<LinkOptions> | false\n\n  /**\n   * If set to false, the orderedList extension will not be registered\n   * @example orderedList: false\n   */\n  orderedList: Partial<OrderedListOptions> | false\n\n  /**\n   * If set to false, the paragraph extension will not be registered\n   * @example paragraph: false\n   */\n  paragraph: Partial<ParagraphOptions> | false\n\n  /**\n   * If set to false, the strike extension will not be registered\n   * @example strike: false\n   */\n  strike: Partial<StrikeOptions> | false\n\n  /**\n   * If set to false, the text extension will not be registered\n   * @example text: false\n   */\n  text: false\n\n  /**\n   * If set to false, the underline extension will not be registered\n   * @example underline: false\n   */\n  underline: Partial<UnderlineOptions> | false\n\n  /**\n   * If set to false, the trailingNode extension will not be registered\n   * @example trailingNode: false\n   */\n  trailingNode: Partial<TrailingNodeOptions> | false\n}\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * Itâ€™s a good starting point for building your own editor.\n */\nexport const StarterKit = Extension.create<StarterKitOptions>({\n  name: 'starterKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bold !== false) {\n      extensions.push(Bold.configure(this.options.bold))\n    }\n\n    if (this.options.blockquote !== false) {\n      extensions.push(Blockquote.configure(this.options.blockquote))\n    }\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.code !== false) {\n      extensions.push(Code.configure(this.options.code))\n    }\n\n    if (this.options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(this.options.codeBlock))\n    }\n\n    if (this.options.document !== false) {\n      extensions.push(Document.configure(this.options.document))\n    }\n\n    if (this.options.dropcursor !== false) {\n      extensions.push(Dropcursor.configure(this.options.dropcursor))\n    }\n\n    if (this.options.gapcursor !== false) {\n      extensions.push(Gapcursor.configure(this.options.gapcursor))\n    }\n\n    if (this.options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(this.options.hardBreak))\n    }\n\n    if (this.options.heading !== false) {\n      extensions.push(Heading.configure(this.options.heading))\n    }\n\n    if (this.options.undoRedo !== false) {\n      extensions.push(UndoRedo.configure(this.options.undoRedo))\n    }\n\n    if (this.options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(this.options.horizontalRule))\n    }\n\n    if (this.options.italic !== false) {\n      extensions.push(Italic.configure(this.options.italic))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options?.listKeymap))\n    }\n\n    if (this.options.link !== false) {\n      extensions.push(Link.configure(this.options?.link))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.paragraph !== false) {\n      extensions.push(Paragraph.configure(this.options.paragraph))\n    }\n\n    if (this.options.strike !== false) {\n      extensions.push(Strike.configure(this.options.strike))\n    }\n\n    if (this.options.text !== false) {\n      extensions.push(Text.configure(this.options.text))\n    }\n\n    if (this.options.underline !== false) {\n      extensions.push(Underline.configure(this.options?.underline))\n    }\n\n    if (this.options.trailingNode !== false) {\n      extensions.push(TrailingNode.configure(this.options?.trailingNode))\n    }\n\n    return extensions\n  },\n})\n","import { StarterKit } from './starter-kit.js'\n\nexport type { StarterKitOptions } from './starter-kit.js'\nexport * from './starter-kit.js'\n\nexport default StarterKit\n"],"names":[],"mappings":"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"}}]
}