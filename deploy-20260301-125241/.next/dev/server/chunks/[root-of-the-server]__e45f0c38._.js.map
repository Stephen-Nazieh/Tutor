{
  "version": 3,
  "sources": [],
  "debugId": "f334ca89-2d94-efcc-7fd5-ba93b9d09ce0",
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/lib/security/csrf.ts"],"sourcesContent":["/**\n * CSRF protection for state-changing API requests.\n * Uses a double-submit cookie pattern: cookie set on session, validated on POST/PUT/DELETE/PATCH.\n */\n\nimport { cookies } from 'next/headers'\nimport crypto from 'crypto'\n\nconst CSRF_COOKIE_NAME = 'tutorme_csrf'\nconst CSRF_HEADER_NAME = 'x-csrf-token'\nconst SECRET = process.env.NEXTAUTH_SECRET || process.env.CSRF_SECRET || 'csrf-secret-change-in-production'\n\nfunction hash(value: string): string {\n  return crypto.createHmac('sha256', SECRET).update(value).digest('hex')\n}\n\n/**\n * Generate a CSRF token for the current request. Call from a route or pass to client.\n */\nexport async function getCsrfToken(): Promise<string> {\n  const value = crypto.randomBytes(24).toString('hex')\n  const token = `${value}.${hash(value)}`\n  const cookieStore = await cookies()\n  cookieStore.set(CSRF_COOKIE_NAME, token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24, // 24h\n    path: '/'\n  })\n  return token\n}\n\n/**\n * Verify CSRF token from request header against cookie. Returns true if valid.\n */\nexport async function verifyCsrfToken(req: Request): Promise<boolean> {\n  try {\n    const headerToken = req.headers.get(CSRF_HEADER_NAME)\n    const cookieStore = await cookies()\n    const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value\n    if (!headerToken || !cookieToken) return false\n    if (headerToken !== cookieToken) return false\n\n    const [value] = headerToken.split('.')\n    if (!value) return false\n\n    const expected = `${value}.${hash(value)}`\n    const headerBuffer = Buffer.from(headerToken)\n    const expectedBuffer = Buffer.from(expected)\n    if (headerBuffer.length !== expectedBuffer.length) return false\n\n    return crypto.timingSafeEqual(headerBuffer, expectedBuffer)\n  } catch {\n    return false\n  }\n}\n\nexport { CSRF_HEADER_NAME }\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGC,GAED;AACA;;;AAEA,MAAM,mBAAmB;AACzB,MAAM,mBAAmB;AACzB,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe,IAAI,QAAQ,GAAG,CAAC,WAAW,IAAI;AAEzE,SAAS,KAAK,KAAa;IACzB,OAAO,gHAAM,CAAC,UAAU,CAAC,UAAU,QAAQ,MAAM,CAAC,OAAO,MAAM,CAAC;AAClE;AAKO,eAAe;IACpB,MAAM,QAAQ,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;IAC9C,MAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,KAAK,QAAQ;IACvC,MAAM,cAAc,MAAM,IAAA,8LAAO;IACjC,YAAY,GAAG,CAAC,kBAAkB,OAAO;QACvC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK;QAClB,MAAM;IACR;IACA,OAAO;AACT;AAKO,eAAe,gBAAgB,GAAY;IAChD,IAAI;QACF,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC;QACpC,MAAM,cAAc,MAAM,IAAA,8LAAO;QACjC,MAAM,cAAc,YAAY,GAAG,CAAC,mBAAmB;QACvD,IAAI,CAAC,eAAe,CAAC,aAAa,OAAO;QACzC,IAAI,gBAAgB,aAAa,OAAO;QAExC,MAAM,CAAC,MAAM,GAAG,YAAY,KAAK,CAAC;QAClC,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,WAAW,GAAG,MAAM,CAAC,EAAE,KAAK,QAAQ;QAC1C,MAAM,eAAe,OAAO,IAAI,CAAC;QACjC,MAAM,iBAAiB,OAAO,IAAI,CAAC;QACnC,IAAI,aAAa,MAAM,KAAK,eAAe,MAAM,EAAE,OAAO;QAE1D,OAAO,gHAAM,CAAC,eAAe,CAAC,cAAc;IAC9C,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/src/app/api/csrf/route.ts"],"sourcesContent":["/**\n * CSRF token endpoint. GET returns a token and sets the CSRF cookie.\n * Client should send this token in X-CSRF-Token header on state-changing requests.\n */\n\nimport { NextResponse } from 'next/server'\nimport { getCsrfToken } from '@/lib/security/csrf'\n\nexport async function GET() {\n  const token = await getCsrfToken()\n  return NextResponse.json({ token })\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;AACA;;;AAEO,eAAe;IACpB,MAAM,QAAQ,MAAM,IAAA,kMAAY;IAChC,OAAO,kMAAY,CAAC,IAAI,CAAC;QAAE;IAAM;AACnC"}}]
}