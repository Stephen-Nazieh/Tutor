{
  "version": 3,
  "sources": [],
  "debugId": "95bb9aa2-5020-57ff-3962-703478451873",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/debug-flags.ts"],"sourcesContent":["import { Atom, atom, react } from '@tldraw/state'\nimport { deleteFromSessionStorage, getFromSessionStorage, setInSessionStorage } from '@tldraw/utils'\n\n// --- 1. DEFINE ---\n//\n// Define your debug values and feature flags here. Use `createDebugValue` to\n// create an arbitrary value with defaults for production, staging, and\n// development. Use `createFeatureFlag` to create a boolean flag which will be\n// `true` by default in development and staging, and `false` in production.\n/** @internal */\nexport const featureFlags: Record<string, DebugFlag<boolean>> = {}\n\n/** @internal */\nexport const pointerCaptureTrackingObject = createDebugValue(\n\t'pointerCaptureTrackingObject',\n\t// ideally we wouldn't store this mutable value in an atom but it's not\n\t// a big deal for debug values\n\t{\n\t\tdefaults: { all: new Map<Element, number>() },\n\t\tshouldStoreForSession: false,\n\t}\n)\n\n/** @internal */\nexport const debugFlags = {\n\t// --- DEBUG VALUES ---\n\tlogPreventDefaults: createDebugValue('logPreventDefaults', {\n\t\tdefaults: { all: false },\n\t}),\n\tlogPointerCaptures: createDebugValue('logPointerCaptures', {\n\t\tdefaults: { all: false },\n\t}),\n\tlogElementRemoves: createDebugValue('logElementRemoves', {\n\t\tdefaults: { all: false },\n\t}),\n\tdebugSvg: createDebugValue('debugSvg', {\n\t\tdefaults: { all: false },\n\t}),\n\tshowFps: createDebugValue('showFps', {\n\t\tdefaults: { all: false },\n\t}),\n\tmeasurePerformance: createDebugValue('measurePerformance', { defaults: { all: false } }),\n\tthrowToBlob: createDebugValue('throwToBlob', {\n\t\tdefaults: { all: false },\n\t}),\n\treconnectOnPing: createDebugValue('reconnectOnPing', {\n\t\tdefaults: { all: false },\n\t}),\n\tdebugCursors: createDebugValue('debugCursors', {\n\t\tdefaults: { all: false },\n\t}),\n\tforceSrgb: createDebugValue('forceSrgbColors', { defaults: { all: false } }),\n\tdebugGeometry: createDebugValue('debugGeometry', { defaults: { all: false } }),\n\thideShapes: createDebugValue('hideShapes', { defaults: { all: false } }),\n\teditOnType: createDebugValue('editOnType', { defaults: { all: false } }),\n\ta11y: createDebugValue('a11y', { defaults: { all: false } }),\n\tdebugElbowArrows: createDebugValue('debugElbowArrows', { defaults: { all: false } }),\n} as const\n\ndeclare global {\n\tinterface Window {\n\t\ttldrawLog(message: any): void\n\t}\n}\n\n// --- 2. USE ---\n// In normal code, read from debug flags directly by calling .value on them:\n//    if (debugFlags.preventDefaultLogging.value) { ... }\n//\n// In react, wrap your reads in `useValue` (or your component in `track`)\n// so they react to changes:\n//    const shouldLog = useValue(debugFlags.preventDefaultLogging)\n\n// --- 3. GET FUNKY ---\n// If you need to do fun stuff like monkey-patching in response to flag changes,\n// add that here. Make sure you wrap your code in `react` so it runs\n// automatically when values change!\n\nif (typeof Element !== 'undefined') {\n\tconst nativeElementRemoveChild = Element.prototype.removeChild\n\treact('element removal logging', () => {\n\t\tif (debugFlags.logElementRemoves.get()) {\n\t\t\tElement.prototype.removeChild = function <T extends Node>(this: any, child: Node): T {\n\t\t\t\tconsole.warn('[tldraw] removing child:', child)\n\t\t\t\treturn nativeElementRemoveChild.call(this, child) as T\n\t\t\t}\n\t\t} else {\n\t\t\tElement.prototype.removeChild = nativeElementRemoveChild\n\t\t}\n\t})\n}\n\n// --- IMPLEMENTATION ---\n// you probably don't need to read this if you're just using the debug values system\n/** @public */\nexport function createDebugValue<T>(\n\tname: string,\n\t{\n\t\tdefaults,\n\t\tshouldStoreForSession = true,\n\t}: { defaults: DebugFlagDefaults<T>; shouldStoreForSession?: boolean }\n) {\n\treturn createDebugValueBase({\n\t\tname,\n\t\tdefaults,\n\t\tshouldStoreForSession,\n\t})\n}\n\n// function createFeatureFlag<T>(\n// \tname: string,\n// \t{\n// \t\tdefaults,\n// \t\tshouldStoreForSession = true,\n// \t}: { defaults: DebugFlagDefaults<T>; shouldStoreForSession?: boolean }\n// ) {\n// \treturn createDebugValueBase({\n// \t\tname,\n// \t\tdefaults,\n// \t\tshouldStoreForSession,\n// \t})\n// }\n\nfunction createDebugValueBase<T>(def: DebugFlagDef<T>): DebugFlag<T> {\n\tconst defaultValue = getDefaultValue(def)\n\tconst storedValue = def.shouldStoreForSession\n\t\t? (getStoredInitialValue(def.name) as T | null)\n\t\t: null\n\tconst valueAtom = atom(`debug:${def.name}`, storedValue ?? defaultValue)\n\n\tif (typeof window !== 'undefined') {\n\t\tif (def.shouldStoreForSession) {\n\t\t\treact(`debug:${def.name}`, () => {\n\t\t\t\tconst currentValue = valueAtom.get()\n\t\t\t\tif (currentValue === defaultValue) {\n\t\t\t\t\tdeleteFromSessionStorage(`tldraw_debug:${def.name}`)\n\t\t\t\t} else {\n\t\t\t\t\tsetInSessionStorage(`tldraw_debug:${def.name}`, JSON.stringify(currentValue))\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tObject.defineProperty(window, `tldraw${def.name.replace(/^[a-z]/, (l) => l.toUpperCase())}`, {\n\t\t\tget() {\n\t\t\t\treturn valueAtom.get()\n\t\t\t},\n\t\t\tset(newValue) {\n\t\t\t\tvalueAtom.set(newValue)\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t})\n\t}\n\n\treturn Object.assign(valueAtom, def, {\n\t\treset: () => valueAtom.set(defaultValue),\n\t})\n}\n\nfunction getStoredInitialValue(name: string) {\n\ttry {\n\t\treturn JSON.parse(getFromSessionStorage(`tldraw_debug:${name}`) ?? 'null')\n\t} catch {\n\t\treturn null\n\t}\n}\n\n// process.env might not be defined, but we can't access it using optional\n// chaining because some bundlers search for `process.env.SOMETHING` as a string\n// and replace it with its value.\nfunction readEnv(fn: () => string | undefined) {\n\ttry {\n\t\treturn fn()\n\t} catch {\n\t\treturn null\n\t}\n}\n\nfunction getDefaultValue<T>(def: DebugFlagDef<T>): T {\n\tconst env =\n\t\treadEnv(() => process.env.TLDRAW_ENV) ??\n\t\treadEnv(() => process.env.VERCEL_PUBLIC_TLDRAW_ENV) ??\n\t\treadEnv(() => process.env.NEXT_PUBLIC_TLDRAW_ENV) ??\n\t\t// default to production because if we don't have one of these, this is probably a library use\n\t\t'production'\n\n\tswitch (env) {\n\t\tcase 'production':\n\t\t\treturn def.defaults.production ?? def.defaults.all\n\t\tcase 'preview':\n\t\tcase 'staging':\n\t\t\treturn def.defaults.staging ?? def.defaults.all\n\t\tdefault:\n\t\t\treturn def.defaults.development ?? def.defaults.all\n\t}\n}\n\n/** @public */\nexport interface DebugFlagDefaults<T> {\n\tdevelopment?: T\n\tstaging?: T\n\tproduction?: T\n\tall: T\n}\n\n/** @public */\nexport interface DebugFlagDef<T> {\n\tname: string\n\tdefaults: DebugFlagDefaults<T>\n\tshouldStoreForSession: boolean\n}\n\n/** @public */\nexport interface DebugFlag<T> extends DebugFlagDef<T>, Atom<T> {\n\treset(): void\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/dom.ts"],"sourcesContent":["/*\nThis is used to facilitate double clicking and pointer capture on elements.\n\nThe events in this file are possibly set on individual SVG elements, \nsuch as handles or corner handles, rather than on HTML elements or \nSVGSVGElements. Raw SVG elemnets do not support pointerCapture in \nmost cases, meaning that in order for pointer capture to work, we \nneed to crawl up the DOM tree to find the nearest HTML element. Then,\nin order for that element to also call the `onPointerUp` event from\nthis file, we need to manually set that event on that element and\nlater remove it when the pointerup occurs. This is a potential leak\nif the user clicks on a handle but the pointerup does not fire for\nwhatever reason.\n*/\n\nimport React from 'react'\nimport { debugFlags, pointerCaptureTrackingObject } from './debug-flags'\n\n/** @public */\nexport function loopToHtmlElement(elm: Element): HTMLElement {\n\tif (elm.nodeType === Node.ELEMENT_NODE) return elm as HTMLElement\n\tif (elm.parentElement) return loopToHtmlElement(elm.parentElement)\n\telse throw Error('Could not find a parent element of an HTML type!')\n}\n\n/**\n * This function calls `event.preventDefault()` for you. Why is that useful?\n *\n * Beacuase if you enable `window.preventDefaultLogging = true` it'll log out a message when it\n * happens. Because we use console.warn rather than (log) you'll get a stack trace in the inspector\n * telling you exactly where it happened. This is important because `e.preventDefault()` is the\n * source of many bugs, but unfortuantly it can't be avoided because it also stops a lot of default\n * behaviour which doesn't make sense in our UI\n *\n * @param event - To prevent default on\n * @public\n */\nexport function preventDefault(event: React.BaseSyntheticEvent | Event) {\n\tevent.preventDefault()\n\tif (debugFlags.logPreventDefaults.get()) {\n\t\tconsole.warn('preventDefault called on event:', event)\n\t}\n}\n\n/** @public */\nexport function setPointerCapture(\n\telement: Element,\n\tevent: React.PointerEvent<Element> | PointerEvent\n) {\n\telement.setPointerCapture(event.pointerId)\n\tif (debugFlags.logPointerCaptures.get()) {\n\t\tconst trackingObj = pointerCaptureTrackingObject.get()\n\t\ttrackingObj.set(element, (trackingObj.get(element) ?? 0) + 1)\n\t\tconsole.warn('setPointerCapture called on element:', element, event)\n\t}\n}\n\n/** @public */\nexport function releasePointerCapture(\n\telement: Element,\n\tevent: React.PointerEvent<Element> | PointerEvent\n) {\n\tif (!element.hasPointerCapture(event.pointerId)) {\n\t\treturn\n\t}\n\n\telement.releasePointerCapture(event.pointerId)\n\tif (debugFlags.logPointerCaptures.get()) {\n\t\tconst trackingObj = pointerCaptureTrackingObject.get()\n\t\tif (trackingObj.get(element) === 1) {\n\t\t\ttrackingObj.delete(element)\n\t\t} else if (trackingObj.has(element)) {\n\t\t\ttrackingObj.set(element, trackingObj.get(element)! - 1)\n\t\t} else {\n\t\t\tconsole.warn('Release without capture')\n\t\t}\n\t\tconsole.warn('releasePointerCapture called on element:', element, event)\n\t}\n}\n\n/**\n * Calls `event.stopPropagation()`.\n *\n * @deprecated Use {@link Editor.markEventAsHandled} instead, or manually call `event.stopPropagation()` if\n * that's what you really want.\n *\n * @public\n */\nexport const stopEventPropagation = (e: any) => e.stopPropagation()\n\n/** @internal */\nexport const setStyleProperty = (\n\telm: HTMLElement | null,\n\tproperty: string,\n\tvalue: string | number\n) => {\n\tif (!elm) return\n\telm.style.setProperty(property, value as string)\n}\n\n/** @internal */\nexport function activeElementShouldCaptureKeys(allowButtons = false) {\n\tconst { activeElement } = document\n\tconst elements = allowButtons ? ['input', 'textarea'] : ['input', 'select', 'button', 'textarea']\n\treturn !!(\n\t\tactiveElement &&\n\t\t((activeElement as HTMLElement).isContentEditable ||\n\t\t\telements.indexOf(activeElement.tagName.toLowerCase()) > -1 ||\n\t\t\tactiveElement.classList.contains('tlui-slider__thumb'))\n\t)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA,SAAS,YAAY,oCAAoC;;AAGlD,SAAS,kBAAkB,GAAA,EAA2B;IAC5D,IAAI,IAAI,QAAA,KAAa,KAAK,YAAA,CAAc,CAAA,OAAO;IAC/C,IAAI,IAAI,aAAA,CAAe,CAAA,OAAO,kBAAkB,IAAI,aAAa;SAC5D,MAAM,MAAM,kDAAkD;AACpE;AAcO,SAAS,eAAe,KAAA,EAAyC;IACvE,MAAM,cAAA,CAAe;IACrB,IAAI,uPAAA,CAAW,kBAAA,CAAmB,GAAA,CAAI,GAAG;QACxC,QAAQ,IAAA,CAAK,mCAAmC,KAAK;IACtD;AACD;AAGO,SAAS,kBACf,OAAA,EACA,KAAA,EACC;IACD,QAAQ,iBAAA,CAAkB,MAAM,SAAS;IACzC,IAAI,uPAAA,CAAW,kBAAA,CAAmB,GAAA,CAAI,GAAG;QACxC,MAAM,cAAc,yQAAA,CAA6B,GAAA,CAAI;QACrD,YAAY,GAAA,CAAI,SAAA,CAAU,YAAY,GAAA,CAAI,OAAO,KAAK,CAAA,IAAK,CAAC;QAC5D,QAAQ,IAAA,CAAK,wCAAwC,SAAS,KAAK;IACpE;AACD;AAGO,SAAS,sBACf,OAAA,EACA,KAAA,EACC;IACD,IAAI,CAAC,QAAQ,iBAAA,CAAkB,MAAM,SAAS,GAAG;QAChD;IACD;IAEA,QAAQ,qBAAA,CAAsB,MAAM,SAAS;IAC7C,IAAI,uPAAA,CAAW,kBAAA,CAAmB,GAAA,CAAI,GAAG;QACxC,MAAM,cAAc,yQAAA,CAA6B,GAAA,CAAI;QACrD,IAAI,YAAY,GAAA,CAAI,OAAO,MAAM,GAAG;YACnC,YAAY,MAAA,CAAO,OAAO;QAC3B,OAAA,IAAW,YAAY,GAAA,CAAI,OAAO,GAAG;YACpC,YAAY,GAAA,CAAI,SAAS,YAAY,GAAA,CAAI,OAAO,IAAK,CAAC;QACvD,OAAO;YACN,QAAQ,IAAA,CAAK,yBAAyB;QACvC;QACA,QAAQ,IAAA,CAAK,4CAA4C,SAAS,KAAK;IACxE;AACD;AAUO,MAAM,uBAAuB,CAAC,IAAW,EAAE,eAAA,CAAgB;AAG3D,MAAM,mBAAmB,CAC/B,KACA,UACA,UACI;IACJ,IAAI,CAAC,IAAK,CAAA;IACV,IAAI,KAAA,CAAM,WAAA,CAAY,UAAU,KAAe;AAChD;AAGO,SAAS,+BAA+B,eAAe,KAAA,EAAO;IACpE,MAAM,EAAE,aAAA,CAAc,CAAA,GAAI;IAC1B,MAAM,WAAW,eAAe;QAAC;QAAS,UAAU;KAAA,GAAI;QAAC;QAAS;QAAU;QAAU,UAAU;KAAA;IAChG,OAAO,CAAC,CAAA,CACP,iBAAA,CACE,cAA8B,iBAAA,IAC/B,SAAS,OAAA,CAAQ,cAAc,OAAA,CAAQ,WAAA,CAAY,CAAC,IAAI,CAAA,KACxD,cAAc,SAAA,CAAU,QAAA,CAAS,oBAAoB,CAAA,CAAA;AAExD"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/keyboard.ts"],"sourcesContent":["import { tlenv } from '../globals/environment'\n\n/** @internal */\nexport const isAccelKey = <InputType extends { metaKey: boolean; ctrlKey: boolean }>(\n\te: InputType\n) => {\n\treturn tlenv.isDarwin ? e.metaKey : e.ctrlKey || e.metaKey\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa;;AAGf,MAAM,aAAa,CACzB,MACI;IACJ,OAAO,iPAAA,CAAM,QAAA,GAAW,EAAE,OAAA,GAAU,EAAE,OAAA,IAAW,EAAE,OAAA;AACpD"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/getPointerInfo.ts"],"sourcesContent":["import { Editor } from '../editor/Editor'\nimport { isAccelKey } from './keyboard'\n\n/** @public */\nexport function getPointerInfo(editor: Editor, e: React.PointerEvent | PointerEvent) {\n\teditor.markEventAsHandled(e)\n\n\treturn {\n\t\tpoint: {\n\t\t\tx: e.clientX,\n\t\t\ty: e.clientY,\n\t\t\tz: e.pressure,\n\t\t},\n\t\tshiftKey: e.shiftKey,\n\t\taltKey: e.altKey,\n\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\tmetaKey: e.metaKey,\n\t\taccelKey: isAccelKey(e),\n\t\tpointerId: e.pointerId,\n\t\tbutton: e.button,\n\t\tisPen: e.pointerType === 'pen',\n\t}\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,kBAAkB;;AAGpB,SAAS,eAAe,MAAA,EAAgB,CAAA,EAAsC;IACpF,OAAO,kBAAA,CAAmB,CAAC;IAE3B,OAAO;QACN,OAAO;YACN,GAAG,EAAE,OAAA;YACL,GAAG,EAAE,OAAA;YACL,GAAG,EAAE,QAAA;QACN;QACA,UAAU,EAAE,QAAA;QACZ,QAAQ,EAAE,MAAA;QACV,SAAS,EAAE,OAAA,IAAW,EAAE,OAAA;QACxB,SAAS,EAAE,OAAA;QACX,cAAU,iPAAA,EAAW,CAAC;QACtB,WAAW,EAAE,SAAA;QACb,QAAQ,EAAE,MAAA;QACV,OAAO,EAAE,WAAA,KAAgB;IAC1B;AACD"}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/runtime.ts"],"sourcesContent":["/** @public */\nexport const runtime: {\n\topenWindow(url: string, target: string, allowReferrer?: boolean): void\n\trefreshPage(): void\n\thardReset(): void\n} = {\n\topenWindow(url, target, allowReferrer = false) {\n\t\treturn window.open(url, target, allowReferrer ? 'noopener' : 'noopener noreferrer')\n\t},\n\trefreshPage() {\n\t\twindow.location.reload()\n\t},\n\tasync hardReset() {\n\t\treturn await (window as any).__tldraw__hardReset?.()\n\t},\n}\n\n/** @public */\nexport function setRuntimeOverrides(input: Partial<typeof runtime>) {\n\tObject.assign(runtime, input)\n}\n"],"names":[],"mappings":";;;;;;AACO,MAAM,UAIT;IACH,YAAW,GAAA,EAAK,MAAA,EAAQ,gBAAgB,KAAA,EAAO;QAC9C,OAAO,OAAO,IAAA,CAAK,KAAK,QAAQ,gBAAgB,aAAa,qBAAqB;IACnF;IACA,cAAc;QACb,OAAO,QAAA,CAAS,MAAA,CAAO;IACxB;IACA,MAAM,YAAY;QACjB,OAAO,MAAO,OAAe,mBAAA,GAAsB;IACpD;AACD;AAGO,SAAS,oBAAoB,KAAA,EAAgC;IACnE,OAAO,MAAA,CAAO,SAAS,KAAK;AAC7B"}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/hardResetEditor.ts"],"sourcesContent":["import { runtime } from './runtime'\n\n/** @public */\nexport function hardResetEditor() {\n\truntime.hardReset()\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,eAAe;;AAGjB,SAAS,kBAAkB;IACjC,6OAAA,CAAQ,SAAA,CAAU;AACnB"}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/refreshPage.ts"],"sourcesContent":["import { runtime } from './runtime'\n\n/** @public */\nexport function refreshPage() {\n\truntime.refreshPage()\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,eAAe;;AAGjB,SAAS,cAAc;IAC7B,6OAAA,CAAQ,WAAA,CAAY;AACrB"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/areShapesContentEqual.ts"],"sourcesContent":["import { TLShape } from '@tldraw/tlschema'\n\nexport const areShapesContentEqual = (a: TLShape, b: TLShape) =>\n\ta.props === b.props && a.meta === b.meta\n"],"names":[],"mappings":";;;;AAEO,MAAM,wBAAwB,CAAC,GAAY,IACjD,EAAE,KAAA,KAAU,EAAE,KAAA,IAAS,EAAE,IAAA,KAAS,EAAE,IAAA"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/browserCanvasMaxSize.ts"],"sourcesContent":["/** @internal */\nexport interface CanvasMaxSize {\n\tmaxWidth: number\n\tmaxHeight: number\n\tmaxArea: number\n}\n\n// Cache this, only want to do this once per browser session\nlet maxCanvasSizes: CanvasMaxSize | null = null\n\nfunction getBrowserCanvasMaxSize(): CanvasMaxSize {\n\tif (!maxCanvasSizes) {\n\t\tmaxCanvasSizes = {\n\t\t\tmaxWidth: getCanvasSize('width'), // test very wide but 1 pixel tall canvases\n\t\t\tmaxHeight: getCanvasSize('height'), // test very tall but 1 pixel wide canvases\n\t\t\tmaxArea: getCanvasSize('area'), // test square canvases\n\t\t}\n\t}\n\treturn maxCanvasSizes\n}\n\n/*!\n * Extracted from https://github.com/jhildenbiddle/canvas-size\n * MIT License: https://github.com/jhildenbiddle/canvas-size/blob/master/LICENSE\n * Copyright (c) John Hildenbiddle\n */\n\nconst MAX_SAFE_CANVAS_DIMENSION = 8192\nconst MAX_SAFE_CANVAS_AREA = 4096 * 4096\n\nconst TEST_SIZES = {\n\tarea: [\n\t\t// Chrome 70 (Mac, Win)\n\t\t// Chrome 68 (Android 4.4)\n\t\t// Edge 17 (Win)\n\t\t// Safari 7-12 (Mac)\n\t\t16384,\n\t\t// Chrome 68 (Android 7.1-9)\n\t\t14188,\n\t\t// Chrome 68 (Android 5)\n\t\t11402,\n\t\t// Firefox 63 (Mac, Win)\n\t\t11180,\n\t\t// Chrome 68 (Android 6)\n\t\t10836,\n\t\t// IE 9-11 (Win)\n\t\t8192,\n\t\t// IE Mobile (Windows Phone 8.x)\n\t\t// Safari (iOS 9 - 12)\n\t\t4096,\n\t],\n\theight: [\n\t\t// Safari 7-12 (Mac)\n\t\t// Safari (iOS 9-12)\n\t\t8388607,\n\t\t// Chrome 83 (Mac, Win)\n\t\t65535,\n\t\t// Chrome 70 (Mac, Win)\n\t\t// Chrome 68 (Android 4.4-9)\n\t\t// Firefox 63 (Mac, Win)\n\t\t32767,\n\t\t// Edge 17 (Win)\n\t\t// IE11 (Win)\n\t\t16384,\n\t\t// IE 9-10 (Win)\n\t\t8192,\n\t\t// IE Mobile (Windows Phone 8.x)\n\t\t4096,\n\t],\n\twidth: [\n\t\t// Safari 7-12 (Mac)\n\t\t// Safari (iOS 9-12)\n\t\t4194303,\n\t\t// Chrome 83 (Mac, Win)\n\t\t65535,\n\t\t// Chrome 70 (Mac, Win)\n\t\t// Chrome 68 (Android 4.4-9)\n\t\t// Firefox 63 (Mac, Win)\n\t\t32767,\n\t\t// Edge 17 (Win)\n\t\t// IE11 (Win)\n\t\t16384,\n\t\t// IE 9-10 (Win)\n\t\t8192,\n\t\t// IE Mobile (Windows Phone 8.x)\n\t\t4096,\n\t],\n} as const\n\n/**\n * Tests ability to read pixel data from canvas elements of various dimensions\n * by decreasing canvas height and/or width until a test succeeds.\n */\nexport function getCanvasSize(dimension: 'width' | 'height' | 'area') {\n\tconst cropCvs = document.createElement('canvas')\n\tcropCvs.width = 1\n\tcropCvs.height = 1\n\tconst cropCtx = cropCvs.getContext('2d')!\n\n\tfor (const size of TEST_SIZES[dimension]) {\n\t\tconst w = dimension === 'height' ? 1 : size\n\t\tconst h = dimension === 'width' ? 1 : size\n\n\t\tconst testCvs = document.createElement('canvas')\n\t\ttestCvs.width = w\n\t\ttestCvs.height = h\n\t\tconst testCtx = testCvs.getContext('2d')!\n\n\t\ttestCtx.fillRect(w - 1, h - 1, 1, 1)\n\t\tcropCtx.drawImage(testCvs, w - 1, h - 1, 1, 1, 0, 0, 1, 1)\n\n\t\tconst isTestPassed = cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0\n\t\t// release memory\n\t\ttestCvs.width = 0\n\t\ttestCvs.height = 0\n\n\t\tif (isTestPassed) {\n\t\t\t// release memory\n\t\t\tcropCvs.width = 0\n\t\t\tcropCvs.height = 0\n\n\t\t\tif (dimension === 'area') {\n\t\t\t\treturn size * size\n\t\t\t} else {\n\t\t\t\treturn size\n\t\t\t}\n\t\t}\n\t}\n\n\t// didn't find a good size, release memory and error\n\tcropCvs.width = 0\n\tcropCvs.height = 0\n\n\tthrow Error('Failed to determine maximum canvas dimension')\n}\n\n/** @internal */\nexport function clampToBrowserMaxCanvasSize(width: number, height: number) {\n\tif (\n\t\twidth <= MAX_SAFE_CANVAS_DIMENSION &&\n\t\theight <= MAX_SAFE_CANVAS_DIMENSION &&\n\t\twidth * height <= MAX_SAFE_CANVAS_AREA\n\t) {\n\t\treturn [width, height]\n\t}\n\n\tconst { maxWidth, maxHeight, maxArea } = getBrowserCanvasMaxSize()\n\tconst aspectRatio = width / height\n\n\tif (width > maxWidth) {\n\t\twidth = maxWidth\n\t\theight = width / aspectRatio\n\t}\n\n\tif (height > maxHeight) {\n\t\theight = maxHeight\n\t\twidth = height * aspectRatio\n\t}\n\n\tif (width * height > maxArea) {\n\t\tconst ratio = Math.sqrt(maxArea / (width * height))\n\t\twidth *= ratio\n\t\theight *= ratio\n\t}\n\n\treturn [width, height]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/SharedStylesMap.ts"],"sourcesContent":["import { StyleProp } from '@tldraw/tlschema'\nimport { exhaustiveSwitchError } from '@tldraw/utils'\n\n/**\n * The value of a particular {@link @tldraw/tlschema#StyleProp}.\n *\n * A `mixed` style means that in the current selection, there are lots of different values for the\n * same style prop - e.g. a red and a blue shape are selected.\n *\n * A `shared` style means that all shapes in the selection share the same value for this style prop.\n *\n * @public\n */\nexport type SharedStyle<T> =\n\t| { readonly type: 'mixed' }\n\t| { readonly type: 'shared'; readonly value: T }\n\nfunction sharedStyleEquals<T>(a: SharedStyle<T>, b: SharedStyle<T> | undefined) {\n\tif (!b) return false\n\tswitch (a.type) {\n\t\tcase 'mixed':\n\t\t\treturn b.type === 'mixed'\n\t\tcase 'shared':\n\t\t\treturn b.type === 'shared' && a.value === b.value\n\t\tdefault:\n\t\t\tthrow exhaustiveSwitchError(a)\n\t}\n}\n\n/**\n * A map of {@link @tldraw/tlschema#StyleProp | StyleProps} to their {@link SharedStyle} values. See\n * {@link Editor.getSharedStyles}.\n *\n * @public\n */\nexport class ReadonlySharedStyleMap {\n\t/** @internal */\n\tprotected map: Map<StyleProp<any>, SharedStyle<unknown>>\n\n\tconstructor(entries?: Iterable<[StyleProp<unknown>, SharedStyle<unknown>]>) {\n\t\tthis.map = new Map(entries)\n\t}\n\n\tget<T>(prop: StyleProp<T>): SharedStyle<T> | undefined {\n\t\treturn this.map.get(prop) as SharedStyle<T> | undefined\n\t}\n\n\tgetAsKnownValue<T>(prop: StyleProp<T>): T | undefined {\n\t\tconst value = this.get(prop)\n\t\tif (!value) return undefined\n\t\tif (value.type === 'mixed') return undefined\n\t\treturn value.value\n\t}\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget size() {\n\t\treturn this.map.size\n\t}\n\n\tequals(other: ReadonlySharedStyleMap) {\n\t\tif (this.size !== other.size) return false\n\n\t\tconst checkedKeys = new Set()\n\t\tfor (const [styleProp, value] of this) {\n\t\t\tif (!sharedStyleEquals(value, other.get(styleProp))) return false\n\t\t\tcheckedKeys.add(styleProp)\n\t\t}\n\t\tfor (const [styleProp, value] of other) {\n\t\t\tif (checkedKeys.has(styleProp)) continue\n\t\t\tif (!sharedStyleEquals(value, this.get(styleProp))) return false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tkeys() {\n\t\treturn this.map.keys()\n\t}\n\n\tvalues() {\n\t\treturn this.map.values()\n\t}\n\n\tentries() {\n\t\treturn this.map.entries()\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.map[Symbol.iterator]()\n\t}\n}\n\n/** @internal */\nexport class SharedStyleMap extends ReadonlySharedStyleMap {\n\tset<T>(prop: StyleProp<T>, value: SharedStyle<T>) {\n\t\tthis.map.set(prop, value)\n\t}\n\n\tapplyValue<T>(prop: StyleProp<T>, value: T) {\n\t\tconst existingValue = this.get(prop)\n\n\t\t// if we don't have a value yet, set it\n\t\tif (!existingValue) {\n\t\t\tthis.set(prop, { type: 'shared', value })\n\t\t\treturn\n\t\t}\n\n\t\tswitch (existingValue.type) {\n\t\t\tcase 'mixed':\n\t\t\t\t// we're already mixed, adding new values won't help\n\t\t\t\treturn\n\t\t\tcase 'shared':\n\t\t\t\tif (existingValue.value !== value) {\n\t\t\t\t\t// if the value is different, we're now mixed:\n\t\t\t\t\tthis.set(prop, { type: 'mixed' })\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(existingValue, 'type')\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AACA,SAAS,6BAA6B;;AAgBtC,SAAS,kBAAqB,CAAA,EAAmB,CAAA,EAA+B;IAC/E,IAAI,CAAC,EAAG,CAAA,OAAO;IACf,OAAQ,EAAE,IAAA,EAAM;QACf,KAAK;YACJ,OAAO,EAAE,IAAA,KAAS;QACnB,KAAK;YACJ,OAAO,EAAE,IAAA,KAAS,YAAY,EAAE,KAAA,KAAU,EAAE,KAAA;QAC7C;YACC,UAAM,iPAAA,EAAsB,CAAC;IAC/B;AACD;AAQO,MAAM,uBAAuB;IAAA,cAAA,GAEzB,IAAA;IAEV,YAAY,OAAA,CAAgE;QAC3E,IAAA,CAAK,GAAA,GAAM,IAAI,IAAI,OAAO;IAC3B;IAEA,IAAO,IAAA,EAAgD;QACtD,OAAO,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,IAAI;IACzB;IAEA,gBAAmB,IAAA,EAAmC;QACrD,MAAM,QAAQ,IAAA,CAAK,GAAA,CAAI,IAAI;QAC3B,IAAI,CAAC,MAAO,CAAA,OAAO,KAAA;QACnB,IAAI,MAAM,IAAA,KAAS,QAAS,CAAA,OAAO,KAAA;QACnC,OAAO,MAAM,KAAA;IACd;IAAA,gDAAA;IAGA,IAAI,OAAO;QACV,OAAO,IAAA,CAAK,GAAA,CAAI,IAAA;IACjB;IAEA,OAAO,KAAA,EAA+B;QACrC,IAAI,IAAA,CAAK,IAAA,KAAS,MAAM,IAAA,CAAM,CAAA,OAAO;QAErC,MAAM,cAAc,aAAA,GAAA,IAAI,IAAI;QAC5B,KAAA,MAAW,CAAC,WAAW,KAAK,CAAA,IAAK,IAAA,CAAM;YACtC,IAAI,CAAC,kBAAkB,OAAO,MAAM,GAAA,CAAI,SAAS,CAAC,EAAG,CAAA,OAAO;YAC5D,YAAY,GAAA,CAAI,SAAS;QAC1B;QACA,KAAA,MAAW,CAAC,WAAW,KAAK,CAAA,IAAK,MAAO;YACvC,IAAI,YAAY,GAAA,CAAI,SAAS,EAAG,CAAA;YAChC,IAAI,CAAC,kBAAkB,OAAO,IAAA,CAAK,GAAA,CAAI,SAAS,CAAC,EAAG,CAAA,OAAO;QAC5D;QAEA,OAAO;IACR;IAEA,OAAO;QACN,OAAO,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK;IACtB;IAEA,SAAS;QACR,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO;IACxB;IAEA,UAAU;QACT,OAAO,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ;IACzB;IAEA,CAAC,OAAO,QAAQ,CAAA,GAAI;QACnB,OAAO,IAAA,CAAK,GAAA,CAAI,OAAO,QAAQ,CAAA,CAAE;IAClC;AACD;AAGO,MAAM,uBAAuB,uBAAuB;IAC1D,IAAO,IAAA,EAAoB,KAAA,EAAuB;QACjD,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,MAAM,KAAK;IACzB;IAEA,WAAc,IAAA,EAAoB,KAAA,EAAU;QAC3C,MAAM,gBAAgB,IAAA,CAAK,GAAA,CAAI,IAAI;QAGnC,IAAI,CAAC,eAAe;YACnB,IAAA,CAAK,GAAA,CAAI,MAAM;gBAAE,MAAM;gBAAU;YAAM,CAAC;YACxC;QACD;QAEA,OAAQ,cAAc,IAAA,EAAM;YAC3B,KAAK;gBAEJ;YACD,KAAK;gBACJ,IAAI,cAAc,KAAA,KAAU,OAAO;oBAElC,IAAA,CAAK,GAAA,CAAI,MAAM;wBAAE,MAAM;oBAAQ,CAAC;gBACjC;gBACA;YACD;gBACC,IAAA,iPAAA,EAAsB,eAAe,MAAM;QAC7C;IACD;AACD"}},
    {"offset": {"line": 627, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/assets.ts"],"sourcesContent":["import { fetch } from '@tldraw/utils'\nimport { version } from '../../version'\n\n/** @public */\nexport function dataUrlToFile(url: string, filename: string, mimeType: string) {\n\treturn fetch(url)\n\t\t.then(function (res) {\n\t\t\treturn res.arrayBuffer()\n\t\t})\n\t\t.then(function (buf) {\n\t\t\treturn new File([buf], filename, { type: mimeType })\n\t\t})\n}\n\n/** @internal */\nconst CDN_BASE_URL = 'https://cdn.tldraw.com'\n\n/** @public */\nexport function getDefaultCdnBaseUrl() {\n\treturn `${CDN_BASE_URL}/${version}`\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,aAAa;AACtB,SAAS,eAAe;;;AAGjB,SAAS,cAAc,GAAA,EAAa,QAAA,EAAkB,QAAA,EAAkB;IAC9E,WAAO,iOAAA,EAAM,GAAG,EACd,IAAA,CAAK,SAAU,GAAA,EAAK;QACpB,OAAO,IAAI,WAAA,CAAY;IACxB,CAAC,EACA,IAAA,CAAK,SAAU,GAAA,EAAK;QACpB,OAAO,IAAI,KAAK;YAAC,GAAG;SAAA,EAAG,UAAU;YAAE,MAAM;QAAS,CAAC;IACpD,CAAC;AACH;AAGA,MAAM,eAAe;AAGd,SAAS,uBAAuB;IACtC,OAAO,GAAG,YAAY,CAAA,CAAA,EAAI,6NAAO,EAAA;AAClC"}},
    {"offset": {"line": 659, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/deepLinks.ts"],"sourcesContent":["import { BoxModel, PageRecordType, TLPageId, TLShapeId, createShapeId } from '@tldraw/tlschema'\nimport { exhaustiveSwitchError } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\nimport { Box } from '../primitives/Box'\n\n/** @public */\nexport type TLDeepLink =\n\t| {\n\t\t\ttype: 'shapes'\n\t\t\tshapeIds: TLShapeId[]\n\t  }\n\t| { type: 'viewport'; bounds: BoxModel; pageId?: TLPageId }\n\t| { type: 'page'; pageId: TLPageId }\n\n/**\n * Converts a deep link descriptor to a url-safe string\n *\n * @example\n * ```ts\n * const url = `https://example.com?d=${createDeepLinkString({ type: 'shapes', shapeIds: ['shape:1', 'shape:2'] })}`\n * navigator.clipboard.writeText(url)\n * ```\n *\n * @param deepLink - the deep link descriptor\n * @returns a url-safe string\n *\n * @public\n */\nexport function createDeepLinkString(deepLink: TLDeepLink): string {\n\tswitch (deepLink.type) {\n\t\tcase 'shapes': {\n\t\t\tconst ids = deepLink.shapeIds.map((id) => encodeId(id.slice('shape:'.length)))\n\t\t\treturn `s${ids.join('.')}`\n\t\t}\n\t\tcase 'page': {\n\t\t\treturn 'p' + encodeId(PageRecordType.parseId(deepLink.pageId))\n\t\t}\n\t\tcase 'viewport': {\n\t\t\tconst { bounds, pageId } = deepLink\n\t\t\tlet res = `v${Math.round(bounds.x)}.${Math.round(bounds.y)}.${Math.round(bounds.w)}.${Math.round(bounds.h)}`\n\t\t\tif (pageId) {\n\t\t\t\tres += '.' + encodeId(PageRecordType.parseId(pageId))\n\t\t\t}\n\t\t\treturn res\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(deepLink)\n\t}\n}\n\n/**\n * Parses a string created by {@link createDeepLinkString} back into a deep link descriptor.\n *\n * @param deepLinkString - the deep link string\n * @returns a deep link descriptor\n *\n * @public\n */\nexport function parseDeepLinkString(deepLinkString: string): TLDeepLink {\n\tconst type = deepLinkString[0]\n\tswitch (type) {\n\t\tcase 's': {\n\t\t\tconst shapeIds = deepLinkString\n\t\t\t\t.slice(1)\n\t\t\t\t.split('.')\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.map((id) => createShapeId(decodeURIComponent(id)))\n\t\t\treturn { type: 'shapes', shapeIds }\n\t\t}\n\t\tcase 'p': {\n\t\t\tconst pageId = PageRecordType.createId(decodeURIComponent(deepLinkString.slice(1)))\n\t\t\treturn { type: 'page', pageId }\n\t\t}\n\t\tcase 'v': {\n\t\t\tconst [x, y, w, h, pageId] = deepLinkString.slice(1).split('.')\n\t\t\treturn {\n\t\t\t\ttype: 'viewport',\n\t\t\t\tbounds: new Box(Number(x), Number(y), Number(w), Number(h)),\n\t\t\t\tpageId: pageId ? PageRecordType.createId(decodeURIComponent(pageId)) : undefined,\n\t\t\t}\n\t\t}\n\t\tdefault:\n\t\t\tthrow Error('Invalid deep link string')\n\t}\n}\n\nfunction encodeId(str: string): string {\n\t// need to encode dots because they are used as separators\n\treturn encodeURIComponent(str).replace(/\\./g, '%2E')\n}\n\n/** @public */\nexport interface TLDeepLinkOptions {\n\t/**\n\t * The name of the url search param to use for the deep link.\n\t *\n\t * Defaults to `'d'`\n\t */\n\tparam?: string\n\t/**\n\t * The debounce time in ms for updating the url.\n\t */\n\tdebounceMs?: number\n\t/**\n\t * Should return the current url to augment with a deep link query parameter.\n\t * If you supply this function, you must also supply an `onChange` function.\n\t */\n\tgetUrl?(editor: Editor): string | URL\n\t/**\n\t * Should return the current deep link target.\n\t * Defaults to returning the current page and viewport position.\n\t */\n\tgetTarget?(editor: Editor): TLDeepLink\n\t/**\n\t * This is fired when the URL is updated.\n\t *\n\t * If not supplied, the default behavior is to update `window.location`.\n\t *\n\t * @param url - the updated URL\n\t */\n\tonChange?(url: URL, editor: Editor): void\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAmB,gBAAqC,qBAAqB;;AAC7E,SAAS,6BAA6B;AAEtC,SAAS,WAAW;;;;AAyBb,SAAS,qBAAqB,QAAA,EAA8B;IAClE,OAAQ,SAAS,IAAA,EAAM;QACtB,KAAK;YAAU;gBACd,MAAM,MAAM,SAAS,QAAA,CAAS,GAAA,CAAI,CAAC,KAAO,SAAS,GAAG,KAAA,CAAM,SAAS,MAAM,CAAC,CAAC;gBAC7E,OAAO,CAAA,CAAA,EAAI,IAAI,IAAA,CAAK,GAAG,CAAC,EAAA;YACzB;QACA,KAAK;YAAQ;gBACZ,OAAO,MAAM,SAAS,gPAAA,CAAe,OAAA,CAAQ,SAAS,MAAM,CAAC;YAC9D;QACA,KAAK;YAAY;gBAChB,MAAM,EAAE,MAAA,EAAQ,MAAA,CAAO,CAAA,GAAI;gBAC3B,IAAI,MAAM,CAAA,CAAA,EAAI,KAAK,KAAA,CAAM,OAAO,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,KAAA,CAAM,OAAO,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,KAAA,CAAM,OAAO,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,KAAA,CAAM,OAAO,CAAC,CAAC,EAAA;gBAC1G,IAAI,QAAQ;oBACX,OAAO,MAAM,SAAS,gPAAA,CAAe,OAAA,CAAQ,MAAM,CAAC;gBACrD;gBACA,OAAO;YACR;QACA;YACC,IAAA,iPAAA,EAAsB,QAAQ;IAChC;AACD;AAUO,SAAS,oBAAoB,cAAA,EAAoC;IACvE,MAAM,OAAO,cAAA,CAAe,CAAC,CAAA;IAC7B,OAAQ,MAAM;QACb,KAAK;YAAK;gBACT,MAAM,WAAW,eACf,KAAA,CAAM,CAAC,EACP,KAAA,CAAM,GAAG,EACT,MAAA,CAAO,OAAO,EACd,GAAA,CAAI,CAAC,SAAO,gPAAA,EAAc,mBAAmB,EAAE,CAAC,CAAC;gBACnD,OAAO;oBAAE,MAAM;oBAAU;gBAAS;YACnC;QACA,KAAK;YAAK;gBACT,MAAM,SAAS,gPAAA,CAAe,QAAA,CAAS,mBAAmB,eAAe,KAAA,CAAM,CAAC,CAAC,CAAC;gBAClF,OAAO;oBAAE,MAAM;oBAAQ;gBAAO;YAC/B;QACA,KAAK;YAAK;gBACT,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,MAAM,CAAA,GAAI,eAAe,KAAA,CAAM,CAAC,EAAE,KAAA,CAAM,GAAG;gBAC9D,OAAO;oBACN,MAAM;oBACN,QAAQ,IAAI,0OAAA,CAAI,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;oBAC1D,QAAQ,SAAS,gPAAA,CAAe,QAAA,CAAS,mBAAmB,MAAM,CAAC,IAAI,KAAA;gBACxE;YACD;QACA;YACC,MAAM,MAAM,0BAA0B;IACxC;AACD;AAEA,SAAS,SAAS,GAAA,EAAqB;IAEtC,OAAO,mBAAmB,GAAG,EAAE,OAAA,CAAQ,OAAO,KAAK;AACpD"}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/getIncrementedName.ts"],"sourcesContent":["/**\n * Get an incremented name (e.g. New page (2)) from a name (e.g. New page), based on an array of\n * existing names.\n *\n * @param name - The name to increment.\n * @param others - The array of existing names.\n * @public\n */\nexport function getIncrementedName(name: string, others: string[]) {\n\tlet result = name\n\tconst set = new Set(others)\n\n\twhile (set.has(result)) {\n\t\tresult = /^.*(\\d+)$/.exec(result)?.[1]\n\t\t\t? result.replace(/(\\d+)(?=\\D?)$/, (m) => {\n\t\t\t\t\treturn (+m + 1).toString()\n\t\t\t\t})\n\t\t\t: `${result} 1`\n\t}\n\n\treturn result\n}\n"],"names":[],"mappings":";;;;AAQO,SAAS,mBAAmB,IAAA,EAAc,MAAA,EAAkB;IAClE,IAAI,SAAS;IACb,MAAM,MAAM,IAAI,IAAI,MAAM;IAE1B,MAAO,IAAI,GAAA,CAAI,MAAM,EAAG;QACvB,SAAS,YAAY,IAAA,CAAK,MAAM,GAAA,CAAI,CAAC,CAAA,GAClC,OAAO,OAAA,CAAQ,iBAAiB,CAAC,MAAM;YACvC,OAAA,CAAQ,CAAC,IAAI,CAAA,EAAG,QAAA,CAAS;QAC1B,CAAC,IACA,GAAG,MAAM,CAAA,EAAA,CAAA;IACb;IAEA,OAAO;AACR"}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/reorderShapes.ts"],"sourcesContent":["import { TLParentId, TLShape, TLShapeId, TLShapePartial } from '@tldraw/tlschema'\nimport { IndexKey, compact, getIndicesBetween, sortByIndex } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\n\nexport function getReorderingShapesChanges(\n\teditor: Editor,\n\toperation: 'toBack' | 'toFront' | 'forward' | 'backward',\n\tids: TLShapeId[],\n\topts?: { considerAllShapes?: boolean }\n) {\n\tif (ids.length === 0) return []\n\n\t// From the ids that are moving, collect the parents, their children, and which of those children are moving\n\tconst parents = new Map<TLParentId, { moving: Set<TLShape>; children: TLShape[] }>()\n\n\tfor (const shape of compact(ids.map((id) => editor.getShape(id)))) {\n\t\tconst { parentId } = shape\n\t\tif (!parents.has(parentId)) {\n\t\t\tparents.set(parentId, {\n\t\t\t\tchildren: compact(\n\t\t\t\t\teditor.getSortedChildIdsForParent(parentId).map((id) => editor.getShape(id))\n\t\t\t\t),\n\t\t\t\tmoving: new Set(),\n\t\t\t})\n\t\t}\n\t\tparents.get(parentId)!.moving.add(shape)\n\t}\n\n\tconst changes: TLShapePartial[] = []\n\n\tswitch (operation) {\n\t\tcase 'toBack': {\n\t\t\tparents.forEach(({ moving, children }) => reorderToBack(moving, children, changes))\n\t\t\tbreak\n\t\t}\n\t\tcase 'toFront': {\n\t\t\tparents.forEach(({ moving, children }) => reorderToFront(moving, children, changes))\n\t\t\tbreak\n\t\t}\n\t\tcase 'forward': {\n\t\t\tparents.forEach(({ moving, children }) =>\n\t\t\t\treorderForward(editor, moving, children, changes, opts)\n\t\t\t)\n\t\t\tbreak\n\t\t}\n\t\tcase 'backward': {\n\t\t\tparents.forEach(({ moving, children }) =>\n\t\t\t\treorderBackward(editor, moving, children, changes, opts)\n\t\t\t)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn changes\n}\n\n/**\n * Reorders the moving shapes to the back of the parent's children.\n *\n * @param moving The set of shapes that are moving\n * @param children The parent's children\n * @param changes The changes array to push changes to\n */\nfunction reorderToBack(moving: Set<TLShape>, children: TLShape[], changes: TLShapePartial[]) {\n\tconst len = children.length\n\n\t// If all of the children are moving, there's nothing to do\n\tif (moving.size === len) return\n\n\tlet below: IndexKey | undefined\n\tlet above: IndexKey | undefined\n\n\t// Starting at the bottom of this parent's children...\n\tfor (let i = 0; i < len; i++) {\n\t\tconst shape = children[i]\n\n\t\tif (moving.has(shape)) {\n\t\t\t// If we've found a moving shape before we've found a non-moving shape,\n\t\t\t// then that shape is already at the back; we can remove it from the\n\t\t\t// moving set and mark it as the shape that will be below the moved shapes.\n\t\t\tbelow = shape.index\n\t\t\tmoving.delete(shape)\n\t\t} else {\n\t\t\t// The first non-moving shape we find will be above our moved shapes; we'll\n\t\t\t// put our moving shapes between it and the shape marked as below (if any).\n\t\t\tabove = shape.index\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (moving.size === 0) {\n\t\t// If our moving set is empty, there's nothing to do; all of our shapes were\n\t\t// already at the back of the parent's children.\n\t\treturn\n\t} else {\n\t\t// Sort the moving shapes by their current index, then apply the new indices\n\t\tconst indices = getIndicesBetween(below, above, moving.size)\n\t\tchanges.push(\n\t\t\t...Array.from(moving.values())\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.map((shape, i) => ({ ...shape, index: indices[i] }))\n\t\t)\n\t}\n}\n\n/**\n * Reorders the moving shapes to the front of the parent's children.\n *\n * @param moving The set of shapes that are moving\n * @param children The parent's children\n * @param changes The changes array to push changes to\n */\nfunction reorderToFront(moving: Set<TLShape>, children: TLShape[], changes: TLShapePartial[]) {\n\tconst len = children.length\n\n\t// If all of the children are moving, there's nothing to do\n\tif (moving.size === len) return\n\n\tlet below: IndexKey | undefined\n\tlet above: IndexKey | undefined\n\n\t// Starting at the top of this parent's children...\n\tfor (let i = len - 1; i > -1; i--) {\n\t\tconst shape = children[i]\n\n\t\tif (moving.has(shape)) {\n\t\t\t// If we've found a moving shape before we've found a non-moving shape,\n\t\t\t// then that shape is already at the front; we can remove it from the\n\t\t\t// moving set and mark it as the shape that will be above the moved shapes.\n\t\t\tabove = shape.index\n\t\t\tmoving.delete(shape)\n\t\t} else {\n\t\t\t// The first non-moving shape we find will be below our moved shapes; we'll\n\t\t\t// put our moving shapes between it and the shape marked as above (if any).\n\t\t\tbelow = shape.index\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (moving.size === 0) {\n\t\t// If our moving set is empty, there's nothing to do; all of our shapes were\n\t\t// already at the front of the parent's children.\n\t\treturn\n\t} else {\n\t\t// Sort the moving shapes by their current index, then apply the new indices\n\t\tconst indices = getIndicesBetween(below, above, moving.size)\n\t\tchanges.push(\n\t\t\t...Array.from(moving.values())\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.map((shape, i) => ({ ...shape, index: indices[i] }))\n\t\t)\n\t}\n}\n\nfunction getOverlapChecker(editor: Editor, moving: Set<TLShape>) {\n\tconst movingBounds = compact(\n\t\tArray.from(moving).map((shape) => {\n\t\t\tconst bounds = editor.getShapePageBounds(shape)\n\t\t\tif (!bounds) return null\n\t\t\treturn { shape, bounds }\n\t\t})\n\t)\n\tconst isOverlapping = (child: TLShape) => {\n\t\tconst bounds = editor.getShapePageBounds(child)\n\t\tif (!bounds) return false\n\t\treturn movingBounds.some((other) => {\n\t\t\treturn other.bounds.includes(bounds)\n\t\t})\n\t}\n\n\treturn isOverlapping\n}\n\n/**\n * Reorders the moving shapes forward in the parent's children.\n *\n * @param editor The editor\n * @param moving The set of shapes that are moving\n * @param children The parent's children\n * @param changes The changes array to push changes to\n * @param opts The options\n */\nfunction reorderForward(\n\teditor: Editor,\n\tmoving: Set<TLShape>,\n\tchildren: TLShape[],\n\tchanges: TLShapePartial[],\n\topts?: { considerAllShapes?: boolean }\n) {\n\tconst isOverlapping = getOverlapChecker(editor, moving)\n\n\tconst len = children.length\n\n\t// If all of the children are moving, there's nothing to do\n\tif (moving.size === len) return\n\n\tlet state = { name: 'skipping' } as\n\t\t| { name: 'skipping' }\n\t\t| { name: 'selecting'; selectIndex: number }\n\n\t// Starting at the bottom of this parent's children...\n\tfor (let i = 0; i < len; i++) {\n\t\tconst isMoving = moving.has(children[i])\n\n\t\tswitch (state.name) {\n\t\t\tcase 'skipping': {\n\t\t\t\tif (!isMoving) continue\n\t\t\t\t// If we find a moving shape while skipping, start selecting\n\t\t\t\tstate = { name: 'selecting', selectIndex: i }\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selecting': {\n\t\t\t\tif (isMoving) continue\n\t\t\t\tif (!opts?.considerAllShapes && !isOverlapping(children[i])) continue\n\t\t\t\t// if we find a non-moving and overlapping shape while selecting, move all selected\n\t\t\t\t// shapes in front of the not moving shape; and start skipping\n\t\t\t\tconst { selectIndex } = state\n\t\t\t\tgetIndicesBetween(children[i].index, children[i + 1]?.index, i - selectIndex).forEach(\n\t\t\t\t\t(index, k) => {\n\t\t\t\t\t\tconst child = children[selectIndex + k]\n\t\t\t\t\t\t// If the shape is not moving (therefore also not overlapping), skip it\n\t\t\t\t\t\tif (!moving.has(child)) return\n\t\t\t\t\t\tchanges.push({ ...child, index })\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\tstate = { name: 'skipping' }\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reorders the moving shapes backward in the parent's children.\n *\n * @param editor The editor\n * @param moving The set of shapes that are moving\n * @param children The parent's children\n * @param changes The changes array to push changes to\n * @param opts The options\n */\nfunction reorderBackward(\n\teditor: Editor,\n\tmoving: Set<TLShape>,\n\tchildren: TLShape[],\n\tchanges: TLShapePartial[],\n\topts?: { considerAllShapes?: boolean }\n) {\n\tconst isOverlapping = getOverlapChecker(editor, moving)\n\n\tconst len = children.length\n\n\tif (moving.size === len) return\n\n\tlet state = { name: 'skipping' } as\n\t\t| { name: 'skipping' }\n\t\t| { name: 'selecting'; selectIndex: number }\n\n\t// Starting at the top of this parent's children...\n\tfor (let i = len - 1; i > -1; i--) {\n\t\tconst isMoving = moving.has(children[i])\n\n\t\tswitch (state.name) {\n\t\t\tcase 'skipping': {\n\t\t\t\tif (!isMoving) continue\n\t\t\t\t// If we find a moving shape while skipping, start selecting\n\t\t\t\tstate = { name: 'selecting', selectIndex: i }\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selecting': {\n\t\t\t\tif (isMoving) continue\n\t\t\t\tif (!opts?.considerAllShapes && !isOverlapping(children[i])) continue\n\t\t\t\t// if we find a non-moving and overlapping shape while selecting, move all selected\n\t\t\t\t// shapes in behind of the not moving shape; and start skipping\n\t\t\t\tgetIndicesBetween(children[i - 1]?.index, children[i].index, state.selectIndex - i).forEach(\n\t\t\t\t\t(index, k) => {\n\t\t\t\t\t\tconst child = children[i + k + 1]\n\t\t\t\t\t\t// If the shape is not moving (therefore also not overlapping), skip it\n\t\t\t\t\t\tif (!moving.has(child)) return\n\t\t\t\t\t\tchanges.push({ ...child, index })\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\tstate = { name: 'skipping' }\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 958, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/rotation.ts"],"sourcesContent":["import { isShapeId, TLShape, TLShapeId, TLShapePartial } from '@tldraw/tlschema'\nimport { compact } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\nimport { Mat } from '../primitives/Mat'\nimport { canonicalizeRotation } from '../primitives/utils'\nimport { Vec, VecLike } from '../primitives/Vec'\n\n/** @internal */\nexport function getRotationSnapshot({\n\teditor,\n\tids,\n}: {\n\teditor: Editor\n\tids: TLShapeId[]\n}): TLRotationSnapshot | null {\n\tconst shapes = compact(ids.map((id) => editor.getShape(id)))\n\tconst rotation = editor.getShapesSharedRotation(ids)\n\tconst rotatedPageBounds = editor.getShapesRotatedPageBounds(ids)\n\n\t// todo: this assumes we're rotating the selected shapes\n\t// if we try to rotate shapes that aren't selected, this\n\t// will produce the wrong results\n\n\t// Return null if there are no selected shapes\n\tif (!rotatedPageBounds) {\n\t\treturn null\n\t}\n\n\tconst initialPageCenter = rotatedPageBounds.center\n\t\t.clone()\n\t\t.rotWith(rotatedPageBounds.point, rotation)\n\n\treturn {\n\t\tinitialPageCenter,\n\t\tinitialCursorAngle: initialPageCenter.angle(editor.inputs.getOriginPagePoint()),\n\t\tinitialShapesRotation: rotation,\n\t\tshapeSnapshots: shapes.map((shape) => ({\n\t\t\tshape,\n\t\t\tinitialPagePoint: editor.getShapePageTransform(shape.id)!.point(),\n\t\t})),\n\t}\n}\n\n/**\n * @internal\n **/\nexport interface TLRotationSnapshot {\n\tinitialPageCenter: Vec\n\tinitialCursorAngle: number\n\tinitialShapesRotation: number\n\tshapeSnapshots: {\n\t\tshape: TLShape\n\t\tinitialPagePoint: Vec\n\t}[]\n}\n\n/** @internal */\nexport function applyRotationToSnapshotShapes({\n\tdelta,\n\teditor,\n\tsnapshot,\n\tstage,\n\tcenterOverride,\n}: {\n\tdelta: number\n\tsnapshot: TLRotationSnapshot\n\teditor: Editor\n\tstage: 'start' | 'update' | 'end' | 'one-off'\n\tcenterOverride?: VecLike\n}) {\n\tconst { initialPageCenter, shapeSnapshots } = snapshot\n\n\teditor.updateShapes(\n\t\tshapeSnapshots.map(({ shape, initialPagePoint }) => {\n\t\t\t// We need to both rotate each shape individually and rotate the shapes\n\t\t\t// around the pivot point (the average center of all rotating shapes.)\n\n\t\t\tconst parentTransform = isShapeId(shape.parentId)\n\t\t\t\t? editor.getShapePageTransform(shape.parentId)!\n\t\t\t\t: Mat.Identity()\n\n\t\t\tconst newPagePoint = Vec.RotWith(initialPagePoint, centerOverride ?? initialPageCenter, delta)\n\n\t\t\tconst newLocalPoint = Mat.applyToPoint(\n\t\t\t\t// use the current parent transform in case it has moved/resized since the start\n\t\t\t\t// (e.g. if rotating a shape at the edge of a group)\n\t\t\t\tMat.Inverse(parentTransform),\n\t\t\t\tnewPagePoint\n\t\t\t)\n\t\t\tconst newRotation = canonicalizeRotation(shape.rotation + delta)\n\n\t\t\treturn {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx: newLocalPoint.x,\n\t\t\t\ty: newLocalPoint.y,\n\t\t\t\trotation: newRotation,\n\t\t\t}\n\t\t})\n\t)\n\n\t// Handle change\n\n\tconst changes: TLShapePartial[] = []\n\n\tshapeSnapshots.forEach(({ shape }) => {\n\t\tconst current = editor.getShape(shape.id)\n\t\tif (!current) return\n\t\tconst util = editor.getShapeUtil(shape)\n\n\t\tif (stage === 'start' || stage === 'one-off') {\n\t\t\tconst changeStart = util.onRotateStart?.(shape)\n\t\t\tif (changeStart) changes.push(changeStart)\n\t\t}\n\n\t\tconst changeUpdate = util.onRotate?.(shape, current)\n\t\tif (changeUpdate) changes.push(changeUpdate)\n\n\t\tif (stage === 'end' || stage === 'one-off') {\n\t\t\tconst changeEnd = util.onRotateEnd?.(shape, current)\n\t\t\tif (changeEnd) changes.push(changeEnd)\n\t\t}\n\t})\n\n\tif (changes.length > 0) {\n\t\teditor.updateShapes(changes)\n\t}\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,iBAAqD;;AAC9D,SAAS,eAAe;AAExB,SAAS,WAAW;AACpB,SAAS,4BAA4B;AACrC,SAAS,WAAoB;;;;;;AAGtB,SAAS,oBAAoB,EACnC,MAAA,EACA,GAAA,EACD,EAG8B;IAC7B,MAAM,aAAS,iOAAA,EAAQ,IAAI,GAAA,CAAI,CAAC,KAAO,OAAO,QAAA,CAAS,EAAE,CAAC,CAAC;IAC3D,MAAM,WAAW,OAAO,uBAAA,CAAwB,GAAG;IACnD,MAAM,oBAAoB,OAAO,0BAAA,CAA2B,GAAG;IAO/D,IAAI,CAAC,mBAAmB;QACvB,OAAO;IACR;IAEA,MAAM,oBAAoB,kBAAkB,MAAA,CAC1C,KAAA,CAAM,EACN,OAAA,CAAQ,kBAAkB,KAAA,EAAO,QAAQ;IAE3C,OAAO;QACN;QACA,oBAAoB,kBAAkB,KAAA,CAAM,OAAO,MAAA,CAAO,kBAAA,CAAmB,CAAC;QAC9E,uBAAuB;QACvB,gBAAgB,OAAO,GAAA,CAAI,CAAC,QAAA,CAAW;gBACtC;gBACA,kBAAkB,OAAO,qBAAA,CAAsB,MAAM,EAAE,EAAG,KAAA,CAAM;YACjE,CAAA,CAAE;IACH;AACD;AAgBO,SAAS,8BAA8B,EAC7C,KAAA,EACA,MAAA,EACA,QAAA,EACA,KAAA,EACA,cAAA,EACD,EAMG;IACF,MAAM,EAAE,iBAAA,EAAmB,cAAA,CAAe,CAAA,GAAI;IAE9C,OAAO,YAAA,CACN,eAAe,GAAA,CAAI,CAAC,EAAE,KAAA,EAAO,gBAAA,CAAiB,CAAA,KAAM;QAInD,MAAM,sBAAkB,4OAAA,EAAU,MAAM,QAAQ,IAC7C,OAAO,qBAAA,CAAsB,MAAM,QAAQ,IAC3C,0OAAA,CAAI,QAAA,CAAS;QAEhB,MAAM,eAAe,0OAAA,CAAI,OAAA,CAAQ,kBAAkB,kBAAkB,mBAAmB,KAAK;QAE7F,MAAM,gBAAgB,0OAAA,CAAI,YAAA,CAAA,gFAAA;QAAA,oDAAA;QAGzB,0OAAA,CAAI,OAAA,CAAQ,eAAe,GAC3B;QAED,MAAM,kBAAc,6PAAA,EAAqB,MAAM,QAAA,GAAW,KAAK;QAE/D,OAAO;YACN,IAAI,MAAM,EAAA;YACV,MAAM,MAAM,IAAA;YACZ,GAAG,cAAc,CAAA;YACjB,GAAG,cAAc,CAAA;YACjB,UAAU;QACX;IACD,CAAC;IAKF,MAAM,UAA4B,CAAC,CAAA;IAEnC,eAAe,OAAA,CAAQ,CAAC,EAAE,KAAA,CAAM,CAAA,KAAM;QACrC,MAAM,UAAU,OAAO,QAAA,CAAS,MAAM,EAAE;QACxC,IAAI,CAAC,QAAS,CAAA;QACd,MAAM,OAAO,OAAO,YAAA,CAAa,KAAK;QAEtC,IAAI,UAAU,WAAW,UAAU,WAAW;YAC7C,MAAM,cAAc,KAAK,aAAA,GAAgB,KAAK;YAC9C,IAAI,YAAa,CAAA,QAAQ,IAAA,CAAK,WAAW;QAC1C;QAEA,MAAM,eAAe,KAAK,QAAA,GAAW,OAAO,OAAO;QACnD,IAAI,aAAc,CAAA,QAAQ,IAAA,CAAK,YAAY;QAE3C,IAAI,UAAU,SAAS,UAAU,WAAW;YAC3C,MAAM,YAAY,KAAK,WAAA,GAAc,OAAO,OAAO;YACnD,IAAI,UAAW,CAAA,QAAQ,IAAA,CAAK,SAAS;QACtC;IACD,CAAC;IAED,IAAI,QAAQ,MAAA,GAAS,GAAG;QACvB,OAAO,YAAA,CAAa,OAAO;IAC5B;AACD"}},
    {"offset": {"line": 1037, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/sync/LocalIndexedDb.ts"],"sourcesContent":["import { RecordsDiff, SerializedSchema, SerializedStore } from '@tldraw/store'\nimport { TLRecord, TLStoreSchema } from '@tldraw/tlschema'\nimport { assert, getFromLocalStorage, noop, setInLocalStorage } from '@tldraw/utils'\nimport { IDBPDatabase, IDBPTransaction, deleteDB, openDB } from 'idb'\nimport { TLSessionStateSnapshot } from '../../config/TLSessionStateSnapshot'\n\n// DO NOT CHANGE THESE WITHOUT ADDING MIGRATION LOGIC. DOING SO WOULD WIPE ALL EXISTING DATA.\nconst STORE_PREFIX = 'TLDRAW_DOCUMENT_v2'\nconst LEGACY_ASSET_STORE_PREFIX = 'TLDRAW_ASSET_STORE_v1'\nconst dbNameIndexKey = 'TLDRAW_DB_NAME_INDEX_v2'\n\n/** @internal */\nexport const Table = {\n\tRecords: 'records',\n\tSchema: 'schema',\n\tSessionState: 'session_state',\n\tAssets: 'assets',\n} as const\n\n/** @internal */\nexport type StoreName = (typeof Table)[keyof typeof Table]\n\nasync function openLocalDb(persistenceKey: string) {\n\tconst storeId = STORE_PREFIX + persistenceKey\n\n\taddDbName(storeId)\n\n\treturn await openDB<StoreName>(storeId, 4, {\n\t\tupgrade(database) {\n\t\t\tif (!database.objectStoreNames.contains(Table.Records)) {\n\t\t\t\tdatabase.createObjectStore(Table.Records)\n\t\t\t}\n\t\t\tif (!database.objectStoreNames.contains(Table.Schema)) {\n\t\t\t\tdatabase.createObjectStore(Table.Schema)\n\t\t\t}\n\t\t\tif (!database.objectStoreNames.contains(Table.SessionState)) {\n\t\t\t\tdatabase.createObjectStore(Table.SessionState)\n\t\t\t}\n\t\t\tif (!database.objectStoreNames.contains(Table.Assets)) {\n\t\t\t\tdatabase.createObjectStore(Table.Assets)\n\t\t\t}\n\t\t},\n\t})\n}\n\nasync function migrateLegacyAssetDbIfNeeded(persistenceKey: string) {\n\tconst databases = window.indexedDB.databases\n\t\t? (await window.indexedDB.databases()).map((db) => db.name)\n\t\t: getAllIndexDbNames()\n\tconst oldStoreId = LEGACY_ASSET_STORE_PREFIX + persistenceKey\n\tconst existing = databases.find((dbName) => dbName === oldStoreId)\n\tif (!existing) return\n\n\tconst oldAssetDb = await openDB<StoreName>(oldStoreId, 1, {\n\t\tupgrade(database) {\n\t\t\tif (!database.objectStoreNames.contains('assets')) {\n\t\t\t\tdatabase.createObjectStore('assets')\n\t\t\t}\n\t\t},\n\t})\n\tif (!oldAssetDb.objectStoreNames.contains('assets')) return\n\n\tconst oldTx = oldAssetDb.transaction(['assets'], 'readonly')\n\tconst oldAssetStore = oldTx.objectStore('assets')\n\tconst oldAssetsKeys = await oldAssetStore.getAllKeys()\n\tconst oldAssets = await Promise.all(\n\t\toldAssetsKeys.map(async (key) => [key, await oldAssetStore.get(key)] as const)\n\t)\n\tawait oldTx.done\n\n\tconst newDb = await openLocalDb(persistenceKey)\n\tconst newTx = newDb.transaction([Table.Assets], 'readwrite')\n\tconst newAssetTable = newTx.objectStore(Table.Assets)\n\tfor (const [key, value] of oldAssets) {\n\t\tnewAssetTable.put(value, key)\n\t}\n\tawait newTx.done\n\n\toldAssetDb.close()\n\tnewDb.close()\n\n\tawait deleteDB(oldStoreId)\n}\n\ninterface LoadResult {\n\trecords: TLRecord[]\n\tschema?: SerializedSchema\n\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n}\n\ninterface SessionStateSnapshotRow {\n\tid: string\n\tsnapshot: TLSessionStateSnapshot\n\tupdatedAt: number\n}\n\n/** @internal */\nexport class LocalIndexedDb {\n\tprivate getDbPromise: Promise<IDBPDatabase<StoreName>>\n\tprivate isClosed = false\n\tprivate pendingTransactionSet = new Set<Promise<unknown>>()\n\n\t/** @internal */\n\tstatic connectedInstances = new Set<LocalIndexedDb>()\n\n\tconstructor(persistenceKey: string) {\n\t\tLocalIndexedDb.connectedInstances.add(this)\n\t\tthis.getDbPromise = (async () => {\n\t\t\tawait migrateLegacyAssetDbIfNeeded(persistenceKey)\n\t\t\treturn await openLocalDb(persistenceKey)\n\t\t})()\n\t}\n\n\tprivate getDb() {\n\t\treturn this.getDbPromise\n\t}\n\n\t/**\n\t * Wait for any pending transactions to be completed. Useful for tests.\n\t *\n\t * @internal\n\t */\n\tpending(): Promise<void> {\n\t\treturn Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(noop)\n\t}\n\n\tasync close() {\n\t\tif (this.isClosed) return\n\t\tthis.isClosed = true\n\t\tawait this.pending()\n\t\t;(await this.getDb()).close()\n\t\tLocalIndexedDb.connectedInstances.delete(this)\n\t}\n\n\tprivate tx<Names extends StoreName[], Mode extends IDBTransactionMode, T>(\n\t\tmode: Mode,\n\t\tnames: Names,\n\t\tcb: (tx: IDBPTransaction<StoreName, Names, Mode>) => Promise<T>\n\t): Promise<T> {\n\t\tconst txPromise = (async () => {\n\t\t\tassert(!this.isClosed, 'db is closed')\n\t\t\tconst db = await this.getDb()\n\t\t\tconst tx = db.transaction(names, mode)\n\t\t\t// need to add a catch here early to prevent unhandled promise rejection\n\t\t\t// during react-strict-mode where this tx.done promise can be rejected\n\t\t\t// before we have a chance to await on it\n\t\t\tconst done = tx.done.catch((e: unknown) => {\n\t\t\t\tif (!this.isClosed) {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t})\n\t\t\ttry {\n\t\t\t\treturn await cb(tx)\n\t\t\t} finally {\n\t\t\t\tif (!this.isClosed) {\n\t\t\t\t\tawait done\n\t\t\t\t} else {\n\t\t\t\t\ttx.abort()\n\t\t\t\t}\n\t\t\t}\n\t\t})()\n\t\tthis.pendingTransactionSet.add(txPromise)\n\t\ttxPromise.finally(() => this.pendingTransactionSet.delete(txPromise))\n\t\treturn txPromise\n\t}\n\n\tasync load({ sessionId }: { sessionId?: string } = {}) {\n\t\treturn await this.tx(\n\t\t\t'readonly',\n\t\t\t[Table.Records, Table.Schema, Table.SessionState],\n\t\t\tasync (tx) => {\n\t\t\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\t\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\t\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\t\t\t\tlet sessionStateSnapshot = sessionId\n\t\t\t\t\t? ((await sessionStateStore.get(sessionId)) as SessionStateSnapshotRow | undefined)\n\t\t\t\t\t\t\t?.snapshot\n\t\t\t\t\t: null\n\t\t\t\tif (!sessionStateSnapshot) {\n\t\t\t\t\t// get the most recent session state\n\t\t\t\t\tconst all = (await sessionStateStore.getAll()) as SessionStateSnapshotRow[]\n\t\t\t\t\tsessionStateSnapshot = all.sort((a, b) => a.updatedAt - b.updatedAt).pop()?.snapshot\n\t\t\t\t}\n\t\t\t\tconst result = {\n\t\t\t\t\trecords: await recordsStore.getAll(),\n\t\t\t\t\tschema: await schemaStore.get(Table.Schema),\n\t\t\t\t\tsessionStateSnapshot,\n\t\t\t\t} satisfies LoadResult\n\n\t\t\t\treturn result\n\t\t\t}\n\t\t)\n\t}\n\n\tasync storeChanges({\n\t\tschema,\n\t\tchanges,\n\t\tsessionId,\n\t\tsessionStateSnapshot,\n\t}: {\n\t\tschema: TLStoreSchema\n\t\tchanges: RecordsDiff<any>\n\t\tsessionId?: string | null\n\t\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n\t}) {\n\t\tawait this.tx('readwrite', [Table.Records, Table.Schema, Table.SessionState], async (tx) => {\n\t\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\n\t\t\tfor (const [id, record] of Object.entries(changes.added)) {\n\t\t\t\tawait recordsStore.put(record, id)\n\t\t\t}\n\n\t\t\tfor (const [_prev, updated] of Object.values(changes.updated)) {\n\t\t\t\tawait recordsStore.put(updated, updated.id)\n\t\t\t}\n\n\t\t\tfor (const id of Object.keys(changes.removed)) {\n\t\t\t\tawait recordsStore.delete(id)\n\t\t\t}\n\n\t\t\tschemaStore.put(schema.serialize(), Table.Schema)\n\t\t\tif (sessionStateSnapshot && sessionId) {\n\t\t\t\tsessionStateStore.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tsnapshot: sessionStateSnapshot,\n\t\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\t\tid: sessionId,\n\t\t\t\t\t} satisfies SessionStateSnapshotRow,\n\t\t\t\t\tsessionId\n\t\t\t\t)\n\t\t\t} else if (sessionStateSnapshot || sessionId) {\n\t\t\t\tconsole.error('sessionStateSnapshot and instanceId must be provided together')\n\t\t\t}\n\t\t})\n\t}\n\n\tasync storeSnapshot({\n\t\tschema,\n\t\tsnapshot,\n\t\tsessionId,\n\t\tsessionStateSnapshot,\n\t}: {\n\t\tschema: TLStoreSchema\n\t\tsnapshot: SerializedStore<any>\n\t\tsessionId?: string | null\n\t\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n\t}) {\n\t\tawait this.tx('readwrite', [Table.Records, Table.Schema, Table.SessionState], async (tx) => {\n\t\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\n\t\t\tawait recordsStore.clear()\n\n\t\t\tfor (const [id, record] of Object.entries(snapshot)) {\n\t\t\t\tawait recordsStore.put(record, id)\n\t\t\t}\n\n\t\t\tschemaStore.put(schema.serialize(), Table.Schema)\n\n\t\t\tif (sessionStateSnapshot && sessionId) {\n\t\t\t\tsessionStateStore.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tsnapshot: sessionStateSnapshot,\n\t\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\t\tid: sessionId,\n\t\t\t\t\t} satisfies SessionStateSnapshotRow,\n\t\t\t\t\tsessionId\n\t\t\t\t)\n\t\t\t} else if (sessionStateSnapshot || sessionId) {\n\t\t\t\tconsole.error('sessionStateSnapshot and instanceId must be provided together')\n\t\t\t}\n\t\t})\n\t}\n\n\tasync pruneSessions() {\n\t\tawait this.tx('readwrite', [Table.SessionState], async (tx) => {\n\t\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\t\t\tconst all = (await sessionStateStore.getAll()).sort((a, b) => a.updatedAt - b.updatedAt)\n\t\t\tif (all.length < 10) {\n\t\t\t\tawait tx.done\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst toDelete = all.slice(0, all.length - 10)\n\t\t\tfor (const { id } of toDelete) {\n\t\t\t\tawait sessionStateStore.delete(id)\n\t\t\t}\n\t\t})\n\t}\n\n\tasync getAsset(assetId: string): Promise<File | undefined> {\n\t\treturn await this.tx('readonly', [Table.Assets], async (tx) => {\n\t\t\tconst assetsStore = tx.objectStore(Table.Assets)\n\t\t\treturn await assetsStore.get(assetId)\n\t\t})\n\t}\n\n\tasync storeAsset(assetId: string, blob: File) {\n\t\tawait this.tx('readwrite', [Table.Assets], async (tx) => {\n\t\t\tconst assetsStore = tx.objectStore(Table.Assets)\n\t\t\tawait assetsStore.put(blob, assetId)\n\t\t})\n\t}\n\n\tasync removeAssets(assetId: string[]) {\n\t\tawait this.tx('readwrite', [Table.Assets], async (tx) => {\n\t\t\tconst assetsStore = tx.objectStore(Table.Assets)\n\t\t\tfor (const id of assetId) {\n\t\t\t\tawait assetsStore.delete(id)\n\t\t\t}\n\t\t})\n\t}\n}\n\n/** @internal */\nexport function getAllIndexDbNames(): string[] {\n\tconst result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || '[]') ?? []\n\tif (!Array.isArray(result)) {\n\t\treturn []\n\t}\n\treturn result\n}\n\nfunction addDbName(name: string) {\n\tconst all = new Set(getAllIndexDbNames())\n\tall.add(name)\n\tsetInLocalStorage(dbNameIndexKey, JSON.stringify([...all]))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1313, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/sync/alerts.ts"],"sourcesContent":["/** @internal */\nexport function showCantWriteToIndexDbAlert() {\n\twindow.alert(\n\t\t`Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.\n\nKeep seeing this message?\n\u2022 If you're using tldraw in a private or \"incognito\" window, try loading tldraw in a regular window or in a different browser.\n\u2022 If your hard disk is full, try clearing up some space and then reload the page.`\n\t)\n}\n\n/** @internal */\nexport function showCantReadFromIndexDbAlert() {\n\twindow.alert(\n\t\t`Oops! We could not access your browser's storage\u2014and the app won't work correctly without that. We now need to reload the page and try again.\n\nKeep seeing this message?\n\u2022 If you're using tldraw in a private or \"incognito\" window, try loading tldraw in a regular window or in a different browser.`\n\t)\n}\n"],"names":[],"mappings":";;;;;;AACO,SAAS,8BAA8B;IAC7C,OAAO,KAAA,CACN,CAAA;;;;sFAAA,CAAA;AAMF;AAGO,SAAS,+BAA+B;IAC9C,OAAO,KAAA,CACN,CAAA;;;mIAAA,CAAA;AAKF"}},
    {"offset": {"line": 1338, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/sync/TLLocalSyncClient.ts"],"sourcesContent":["import { Signal, transact } from '@tldraw/state'\nimport { RecordsDiff, SerializedSchema, UnknownRecord, squashRecordDiffs } from '@tldraw/store'\nimport { TLStore } from '@tldraw/tlschema'\nimport { assert } from '@tldraw/utils'\nimport {\n\tTAB_ID,\n\tTLSessionStateSnapshot,\n\tcreateSessionStateSnapshotSignal,\n\textractSessionStateFromLegacySnapshot,\n\tloadSessionStateSnapshotIntoStore,\n} from '../../config/TLSessionStateSnapshot'\nimport { LocalIndexedDb } from './LocalIndexedDb'\nimport { showCantReadFromIndexDbAlert, showCantWriteToIndexDbAlert } from './alerts'\n\n/** How should we debounce persists? */\nconst PERSIST_THROTTLE_MS = 350\n/** If we're in an error state, how long should we wait before retrying a write? */\nconst PERSIST_RETRY_THROTTLE_MS = 10_000\n\nconst UPDATE_INSTANCE_STATE = Symbol('UPDATE_INSTANCE_STATE')\n\n/**\n * IMPORTANT!!!\n *\n * This is just a quick-n-dirty temporary solution that will be replaced with the remote sync client\n * once it has the db integrated\n */\n\ninterface SyncMessage {\n\ttype: 'diff'\n\tstoreId: string\n\tchanges: RecordsDiff<UnknownRecord>\n\tschema: SerializedSchema\n}\n\n// Sent by new clients when they connect\n// If another client is on the channel with a newer schema version\n// It will\ninterface AnnounceMessage {\n\ttype: 'announce'\n\tschema: SerializedSchema\n}\n\ntype Message = SyncMessage | AnnounceMessage\n\ntype UnpackPromise<T> = T extends Promise<infer U> ? U : T\n\nconst msg = (msg: Message) => msg\n\n/** @internal */\nexport class BroadcastChannelMock {\n\tonmessage?: (e: MessageEvent) => void\n\tconstructor(_name: string) {\n\t\t// noop\n\t}\n\tpostMessage(_msg: Message) {\n\t\t// noop\n\t}\n\tclose() {\n\t\t// noop\n\t}\n}\n\nconst BC = typeof BroadcastChannel === 'undefined' ? BroadcastChannelMock : BroadcastChannel\n\n/** @internal */\nexport class TLLocalSyncClient {\n\tprivate disposables = new Set<() => void>()\n\tprivate diffQueue: Array<RecordsDiff<UnknownRecord> | typeof UPDATE_INSTANCE_STATE> = []\n\tprivate didDispose = false\n\tprivate shouldDoFullDBWrite = true\n\tprivate isReloading = false\n\treadonly persistenceKey: string\n\treadonly sessionId: string\n\treadonly serializedSchema: SerializedSchema\n\tprivate isDebugging = false\n\tprivate readonly documentTypes: ReadonlySet<string>\n\tprivate readonly $sessionStateSnapshot: Signal<TLSessionStateSnapshot | null>\n\t/** @internal */\n\treadonly db: LocalIndexedDb\n\n\tinitTime = Date.now()\n\tprivate debug(...args: any[]) {\n\t\tif (this.isDebugging) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(...args)\n\t\t}\n\t}\n\tconstructor(\n\t\tpublic readonly store: TLStore,\n\t\t{\n\t\t\tpersistenceKey,\n\t\t\tsessionId = TAB_ID,\n\t\t\tonLoad,\n\t\t\tonLoadError,\n\t\t}: {\n\t\t\tpersistenceKey: string\n\t\t\tsessionId?: string\n\t\t\tonLoad(self: TLLocalSyncClient): void\n\t\t\tonLoadError(error: Error): void\n\t\t},\n\t\tpublic readonly channel = new BC(`tldraw-tab-sync-${persistenceKey}`)\n\t) {\n\t\tif (typeof window !== 'undefined') {\n\t\t\t;(window as any).tlsync = this\n\t\t}\n\t\tthis.persistenceKey = persistenceKey\n\t\tthis.sessionId = sessionId\n\t\tthis.db = new LocalIndexedDb(persistenceKey)\n\t\tthis.disposables.add(() => this.db.close())\n\n\t\tthis.serializedSchema = this.store.schema.serialize()\n\t\tthis.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store)\n\n\t\tthis.disposables.add(\n\t\t\t// Set up a subscription to changes from the store: When\n\t\t\t// the store changes (and if the change was made by the user)\n\t\t\t// then immediately send the diff to other tabs via postMessage\n\t\t\t// and schedule a persist.\n\t\t\tstore.listen(\n\t\t\t\t({ changes }) => {\n\t\t\t\t\tthis.diffQueue.push(changes)\n\t\t\t\t\tthis.channel.postMessage(\n\t\t\t\t\t\tmsg({\n\t\t\t\t\t\t\ttype: 'diff',\n\t\t\t\t\t\t\tstoreId: this.store.id,\n\t\t\t\t\t\t\tchanges,\n\t\t\t\t\t\t\tschema: this.serializedSchema,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\tthis.schedulePersist()\n\t\t\t\t},\n\t\t\t\t{ source: 'user', scope: 'document' }\n\t\t\t)\n\t\t)\n\t\tthis.disposables.add(\n\t\t\tstore.listen(\n\t\t\t\t() => {\n\t\t\t\t\tthis.diffQueue.push(UPDATE_INSTANCE_STATE)\n\t\t\t\t\tthis.schedulePersist()\n\t\t\t\t},\n\t\t\t\t{ scope: 'session' }\n\t\t\t)\n\t\t)\n\n\t\tthis.connect(onLoad, onLoadError)\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values(this.store.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\t}\n\n\tprivate async connect(onLoad: (client: this) => void, onLoadError: (error: Error) => void) {\n\t\tthis.debug('connecting')\n\t\tlet data: UnpackPromise<ReturnType<LocalIndexedDb['load']>> | undefined\n\n\t\ttry {\n\t\t\tdata = await this.db.load({ sessionId: this.sessionId })\n\t\t} catch (error: any) {\n\t\t\tonLoadError(error)\n\t\t\tshowCantReadFromIndexDbAlert()\n\t\t\treturn\n\t\t}\n\n\t\tthis.debug('loaded data from store', data, 'didDispose', this.didDispose)\n\t\tif (this.didDispose) return\n\n\t\ttry {\n\t\t\tif (data) {\n\t\t\t\tconst documentSnapshot = Object.fromEntries(data.records.map((r) => [r.id, r]))\n\t\t\t\tconst sessionStateSnapshot =\n\t\t\t\t\tdata.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot)\n\t\t\t\tconst migrationResult = this.store.schema.migrateStoreSnapshot({\n\t\t\t\t\tstore: documentSnapshot,\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\tschema: data.schema ?? this.store.schema.serializeEarliestVersion(),\n\t\t\t\t})\n\n\t\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\t\tconsole.error('failed to migrate store', migrationResult)\n\t\t\t\t\tonLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst records = Object.values(migrationResult.value).filter((r) =>\n\t\t\t\t\tthis.documentTypes.has(r.typeName)\n\t\t\t\t)\n\t\t\t\tif (records.length > 0) {\n\t\t\t\t\t// 3. Merge the changes into the REAL STORE\n\t\t\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t\t\t// Calling put will validate the records!\n\t\t\t\t\t\tthis.store.put(records, 'initialize')\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (sessionStateSnapshot) {\n\t\t\t\t\tloadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot, {\n\t\t\t\t\t\tforceOverwrite: true,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.channel.onmessage = ({ data }) => {\n\t\t\t\tthis.debug('got message', data)\n\t\t\t\tconst msg = data as Message\n\t\t\t\t// if their schema is earlier than ours, we need to tell them so they can refresh\n\t\t\t\t// if their schema is later than ours, we need to refresh\n\t\t\t\tconst res = this.store.schema.getMigrationsSince(msg.schema)\n\n\t\t\t\tif (!res.ok) {\n\t\t\t\t\t// we are older, refresh\n\t\t\t\t\t// but add a safety check to make sure we don't get in an infinite loop\n\t\t\t\t\tconst timeSinceInit = Date.now() - this.initTime\n\t\t\t\t\tif (timeSinceInit < 5000) {\n\t\t\t\t\t\t// This tab was just reloaded, but is out of date compared to other tabs.\n\t\t\t\t\t\t// Not expecting this to ever happen. It should only happen if we roll back a release that incremented\n\t\t\t\t\t\t// the schema version (which we should never do)\n\t\t\t\t\t\t// Or maybe during development if you have multiple local tabs open running the app on prod mode and you\n\t\t\t\t\t\t// check out an older commit. Dev server should be fine.\n\t\t\t\t\t\tonLoadError(new Error('Schema mismatch, please close other tabs and reload the page'))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tthis.debug('reloading')\n\t\t\t\t\tthis.isReloading = true\n\t\t\t\t\twindow?.location?.reload?.()\n\t\t\t\t\treturn\n\t\t\t\t} else if (res.value.length > 0) {\n\t\t\t\t\t// they are older, tell them to refresh and not write any more data\n\t\t\t\t\tthis.debug('telling them to reload')\n\t\t\t\t\tthis.channel.postMessage({ type: 'announce', schema: this.serializedSchema })\n\t\t\t\t\t// schedule a full db write in case they wrote data anyway\n\t\t\t\t\tthis.shouldDoFullDBWrite = true\n\t\t\t\t\tthis.persistIfNeeded()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// otherwise, all good, same version :)\n\t\t\t\tif (msg.type === 'diff') {\n\t\t\t\t\tthis.debug('applying diff')\n\t\t\t\t\ttransact(() => {\n\t\t\t\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t\t\t\tthis.store.applyDiff(msg.changes as any)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.channel.postMessage({ type: 'announce', schema: this.serializedSchema })\n\t\t\tthis.disposables.add(() => {\n\t\t\t\tthis.channel.close()\n\t\t\t})\n\t\t\tonLoad(this)\n\t\t} catch (e: any) {\n\t\t\tthis.debug('error loading data from store', e)\n\t\t\tif (this.didDispose) return\n\t\t\tonLoadError(e)\n\t\t\treturn\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.debug('closing')\n\t\tthis.didDispose = true\n\t\tthis.disposables.forEach((d) => d())\n\t}\n\n\tprivate isPersisting = false\n\tprivate didLastWriteError = false\n\tprivate scheduledPersistTimeout: ReturnType<typeof setTimeout> | null = null\n\n\t/**\n\t * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too\n\t * often, and will retry if failed.\n\t *\n\t * @internal\n\t */\n\tprivate schedulePersist() {\n\t\tthis.debug('schedulePersist', this.scheduledPersistTimeout)\n\t\tif (this.scheduledPersistTimeout) return\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tthis.scheduledPersistTimeout = setTimeout(\n\t\t\t() => {\n\t\t\t\tthis.scheduledPersistTimeout = null\n\t\t\t\tthis.persistIfNeeded()\n\t\t\t},\n\t\t\tthis.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS\n\t\t)\n\t}\n\n\t/**\n\t * Persist to IndexedDB only under certain circumstances:\n\t *\n\t * - If we're not already persisting\n\t * - If we're not reloading the page\n\t * - And we have something to persist (a full db write scheduled or changes in the diff queue)\n\t *\n\t * @internal\n\t */\n\tprivate persistIfNeeded() {\n\t\tthis.debug('persistIfNeeded', {\n\t\t\tisPersisting: this.isPersisting,\n\t\t\tisReloading: this.isReloading,\n\t\t\tshouldDoFullDBWrite: this.shouldDoFullDBWrite,\n\t\t\tdiffQueueLength: this.diffQueue.length,\n\t\t\tstoreIsPossiblyCorrupt: this.store.isPossiblyCorrupted(),\n\t\t})\n\n\t\t// if we've scheduled a persist for the future, that's no longer needed\n\t\tif (this.scheduledPersistTimeout) {\n\t\t\tclearTimeout(this.scheduledPersistTimeout)\n\t\t\tthis.scheduledPersistTimeout = null\n\t\t}\n\n\t\t// if a persist is already in progress, we don't need to do anything -\n\t\t// if there are still outstanding changes once it's finished, it'll\n\t\t// schedule another persist\n\t\tif (this.isPersisting) return\n\n\t\t// if we're reloading the page, it's because there's a newer client\n\t\t// present so lets not overwrite their changes\n\t\tif (this.isReloading) return\n\n\t\t// if the store is possibly corrupted, we don't want to persist\n\t\tif (this.store.isPossiblyCorrupted()) return\n\n\t\t// if we're scheduled for a full write or if we have changes outstanding, let's persist them!\n\t\tif (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {\n\t\t\tthis.doPersist()\n\t\t}\n\t}\n\n\t/**\n\t * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after\n\t * a short delay.\n\t */\n\tprivate async doPersist() {\n\t\tassert(!this.isPersisting, 'persist already in progress')\n\t\tif (this.didDispose) return\n\t\tthis.isPersisting = true\n\n\t\tthis.debug('doPersist start')\n\n\t\t// instantly empty the diff queue, but keep our own copy of it. this way\n\t\t// diffs that come in during the persist will still get tracked\n\t\tconst diffQueue = this.diffQueue\n\t\tthis.diffQueue = []\n\n\t\ttry {\n\t\t\tif (this.shouldDoFullDBWrite) {\n\t\t\t\tthis.shouldDoFullDBWrite = false\n\t\t\t\tawait this.db.storeSnapshot({\n\t\t\t\t\tschema: this.store.schema,\n\t\t\t\t\tsnapshot: this.store.serialize(),\n\t\t\t\t\tsessionId: this.sessionId,\n\t\t\t\t\tsessionStateSnapshot: this.$sessionStateSnapshot.get(),\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst diffs = squashRecordDiffs(\n\t\t\t\t\tdiffQueue.filter((d): d is RecordsDiff<UnknownRecord> => d !== UPDATE_INSTANCE_STATE)\n\t\t\t\t)\n\t\t\t\tawait this.db.storeChanges({\n\t\t\t\t\tchanges: diffs,\n\t\t\t\t\tschema: this.store.schema,\n\t\t\t\t\tsessionId: this.sessionId,\n\t\t\t\t\tsessionStateSnapshot: this.$sessionStateSnapshot.get(),\n\t\t\t\t})\n\t\t\t}\n\t\t\tthis.didLastWriteError = false\n\t\t} catch (e) {\n\t\t\t// set this.shouldDoFullDBWrite because we clear the diffQueue no matter what,\n\t\t\t// so if this is just a temporary error, we will still persist all changes\n\t\t\tthis.shouldDoFullDBWrite = true\n\t\t\tthis.didLastWriteError = true\n\t\t\tconsole.error('failed to store changes in indexed db', e)\n\n\t\t\tshowCantWriteToIndexDbAlert()\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\t// adios\n\t\t\t\twindow.location.reload()\n\t\t\t}\n\t\t}\n\n\t\tthis.isPersisting = false\n\t\tthis.debug('doPersist end')\n\n\t\t// changes might have come in between when we started the persist and\n\t\t// now. we request another persist so any new changes can get written\n\t\tthis.schedulePersist()\n\t}\n}\n"],"names":["msg", "data"],"mappings":"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"}},
    {"offset": {"line": 1616, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/licensing.ts"],"sourcesContent":["/*\n  Convert a string into an ArrayBuffer\n  from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String\n*/\nexport function str2ab(str: string) {\n\tconst buf = new ArrayBuffer(str.length)\n\tconst bufView = new Uint8Array(buf)\n\tfor (let i = 0, strLen = str.length; i < strLen; i++) {\n\t\tbufView[i] = str.charCodeAt(i)\n\t}\n\treturn buf\n}\n\nexport function importPublicKey(pemContents: string) {\n\t// base64 decode the string to get the binary data\n\tconst binaryDerString = atob(pemContents)\n\t// convert from a binary string to an ArrayBuffer\n\tconst binaryDer = str2ab(binaryDerString)\n\n\treturn crypto.subtle.importKey(\n\t\t'spki',\n\t\tnew Uint8Array(binaryDer),\n\t\t{\n\t\t\tname: 'ECDSA',\n\t\t\tnamedCurve: 'P-256',\n\t\t},\n\t\ttrue,\n\t\t['verify']\n\t)\n}\n"],"names":[],"mappings":";;;;;;AAIO,SAAS,OAAO,GAAA,EAAa;IACnC,MAAM,MAAM,IAAI,YAAY,IAAI,MAAM;IACtC,MAAM,UAAU,IAAI,WAAW,GAAG;IAClC,IAAA,IAAS,IAAI,GAAG,SAAS,IAAI,MAAA,EAAQ,IAAI,QAAQ,IAAK;QACrD,OAAA,CAAQ,CAAC,CAAA,GAAI,IAAI,UAAA,CAAW,CAAC;IAC9B;IACA,OAAO;AACR;AAEO,SAAS,gBAAgB,WAAA,EAAqB;IAEpD,MAAM,kBAAkB,KAAK,WAAW;IAExC,MAAM,YAAY,OAAO,eAAe;IAExC,OAAO,OAAO,MAAA,CAAO,SAAA,CACpB,QACA,IAAI,WAAW,SAAS,GACxB;QACC,MAAM;QACN,YAAY;IACb,GACA,MACA;QAAC,QAAQ;KAAA;AAEX"}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/getSvgPathFromPoints.ts"],"sourcesContent":["import { VecLike } from '../primitives/Vec'\nimport { average, precise } from '../primitives/utils'\n\n/**\n * Turn an array of points into a path of quadradic curves.\n *\n * @param points - The points returned from perfect-freehand\n * @param closed - Whether the stroke is closed\n *\n * @public\n */\nexport function getSvgPathFromPoints(points: VecLike[], closed = true): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0]\n\tlet b = points[1]\n\n\tif (len === 2) {\n\t\t// If only two points, just draw a line\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i]\n\t\tb = points[i + 1]\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0], points[1])}Q${precise(points[1])}${average(\n\t\t\tpoints[1],\n\t\t\tpoints[2]\n\t\t)}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${\n\t\t\tpoints.length > 3 ? 'T' : ''\n\t\t}${result}L${precise(points[len - 1])}`\n\t}\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,SAAS,eAAe;;AAU1B,SAAS,qBAAqB,MAAA,EAAmB,SAAS,IAAA,EAAc;IAC9E,MAAM,MAAM,OAAO,MAAA;IAEnB,IAAI,MAAM,GAAG;QACZ,OAAO;IACR;IAEA,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA;IAChB,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA;IAEhB,IAAI,QAAQ,GAAG;QAEd,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,CAAC,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,CAAC,CAAC,EAAA;IACpC;IAEA,IAAI,SAAS;IAEb,IAAA,IAAS,IAAI,GAAG,MAAM,MAAM,GAAG,IAAI,KAAK,IAAK;QAC5C,IAAI,MAAA,CAAO,CAAC,CAAA;QACZ,IAAI,MAAA,CAAO,IAAI,CAAC,CAAA;QAChB,cAAU,gPAAA,EAAQ,GAAG,CAAC;IACvB;IAEA,IAAI,QAAQ;QAEX,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAC,CAAC,OAAG,gPAAA,EAChE,MAAA,CAAO,CAAC,CAAA,EACR,MAAA,CAAO,CAAC,CAAA,EACR,CAAA,EAAI,MAAM,OAAG,gPAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAC,OAAG,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,CAAA,CAAA;IAClF,OAAO;QAIN,OAAO,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAC,CAAC,OAAG,gPAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,EAAG,MAAA,CAAO,CAAC,CAAC,CAAC,GAClF,OAAO,MAAA,GAAS,IAAI,MAAM,EAC3B,GAAG,MAAM,CAAA,CAAA,MAAI,gPAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAC,CAAC,EAAA;IACtC;AACD"}},
    {"offset": {"line": 1680, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/normalizeWheel.ts"],"sourcesContent":["// Reasonable defaults\nconst MAX_ZOOM_STEP = 10\nconst IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(\n\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\ttypeof window === 'undefined' ? 'node' : window.navigator.platform\n)\n\n// Adapted from https://stackoverflow.com/a/13650579\n/** @internal */\nexport function normalizeWheel(event: WheelEvent | React.WheelEvent<HTMLElement>) {\n\tlet { deltaY, deltaX } = event\n\tlet deltaZ = 0\n\n\t// wheeling\n\tif (event.ctrlKey || event.altKey || event.metaKey) {\n\t\tdeltaZ = (Math.abs(deltaY) > MAX_ZOOM_STEP ? MAX_ZOOM_STEP * Math.sign(deltaY) : deltaY) / 100\n\t} else {\n\t\tif (event.shiftKey && !IS_DARWIN) {\n\t\t\tdeltaX = deltaY\n\t\t\tdeltaY = 0\n\t\t}\n\t}\n\n\treturn { x: -deltaX, y: -deltaY, z: -deltaZ }\n}\n"],"names":[],"mappings":";;;;AACA,MAAM,gBAAgB;AACtB,MAAM,YAAY,uBAAuB,IAAA,CAAA,4DAAA;AAExC,OAAO,WAAW,cAAc,SAAS,OAAO,SAAA,CAAU,QAAA;AAKpD,SAAS,eAAe,KAAA,EAAmD;IACjF,IAAI,EAAE,MAAA,EAAQ,MAAA,CAAO,CAAA,GAAI;IACzB,IAAI,SAAS;IAGb,IAAI,MAAM,OAAA,IAAW,MAAM,MAAA,IAAU,MAAM,OAAA,EAAS;QACnD,SAAA,CAAU,KAAK,GAAA,CAAI,MAAM,IAAI,gBAAgB,gBAAgB,KAAK,IAAA,CAAK,MAAM,IAAI,MAAA,IAAU;IAC5F,OAAO;QACN,IAAI,MAAM,QAAA,IAAY,CAAC,WAAW;YACjC,SAAS;YACT,SAAS;QACV;IACD;IAEA,OAAO;QAAE,GAAG,CAAC;QAAQ,GAAG,CAAC;QAAQ,GAAG,CAAC;IAAO;AAC7C"}},
    {"offset": {"line": 1710, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/collaboratorState.ts"],"sourcesContent":["import { TLInstancePresence } from '@tldraw/tlschema'\nimport { Editor } from '../editor/Editor'\n\n/** The activity state of a collaborator */\nexport type CollaboratorState = 'active' | 'idle' | 'inactive'\n\n/**\n * Get the activity state of a collaborator based on elapsed time since their last activity.\n *\n * @param editor - The editor instance\n * @param elapsed - Time in milliseconds since the collaborator's last activity\n * @returns The collaborator's activity state\n */\nexport function getCollaboratorStateFromElapsedTime(\n\teditor: Editor,\n\telapsed: number\n): CollaboratorState {\n\treturn elapsed > editor.options.collaboratorInactiveTimeoutMs\n\t\t? 'inactive'\n\t\t: elapsed > editor.options.collaboratorIdleTimeoutMs\n\t\t\t? 'idle'\n\t\t\t: 'active'\n}\n\n/**\n * Determine whether a collaborator should be shown based on their activity state\n * and the current instance state (following, highlighted users, etc.).\n *\n * @param editor - The editor instance\n * @param presence - The collaborator's presence data\n * @param state - The collaborator's activity state\n * @returns Whether the collaborator should be shown\n */\nexport function shouldShowCollaborator(\n\teditor: Editor,\n\tpresence: TLInstancePresence,\n\tstate: CollaboratorState\n): boolean {\n\tconst { followingUserId, highlightedUserIds } = editor.getInstanceState()\n\n\tswitch (state) {\n\t\tcase 'inactive':\n\t\t\t// If they're inactive, only show if we're following them or they're highlighted\n\t\t\treturn followingUserId === presence.userId || highlightedUserIds.includes(presence.userId)\n\t\tcase 'idle':\n\t\t\t// If they're idle and following us, hide them unless they have a chat message or are highlighted\n\t\t\tif (presence.followingUserId === editor.user.getId()) {\n\t\t\t\treturn !!(presence.chatMessage || highlightedUserIds.includes(presence.userId))\n\t\t\t}\n\t\t\treturn true\n\t\tcase 'active':\n\t\t\treturn true\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAaO,SAAS,oCACf,MAAA,EACA,OAAA,EACoB;IACpB,OAAO,UAAU,OAAO,OAAA,CAAQ,6BAAA,GAC7B,aACA,UAAU,OAAO,OAAA,CAAQ,yBAAA,GACxB,SACA;AACL;AAWO,SAAS,uBACf,MAAA,EACA,QAAA,EACA,KAAA,EACU;IACV,MAAM,EAAE,eAAA,EAAiB,kBAAA,CAAmB,CAAA,GAAI,OAAO,gBAAA,CAAiB;IAExE,OAAQ,OAAO;QACd,KAAK;YAEJ,OAAO,oBAAoB,SAAS,MAAA,IAAU,mBAAmB,QAAA,CAAS,SAAS,MAAM;QAC1F,KAAK;YAEJ,IAAI,SAAS,eAAA,KAAoB,OAAO,IAAA,CAAK,KAAA,CAAM,GAAG;gBACrD,OAAO,CAAC,CAAA,CAAE,SAAS,WAAA,IAAe,mBAAmB,QAAA,CAAS,SAAS,MAAM,CAAA;YAC9E;YACA,OAAO;QACR,KAAK;YACJ,OAAO;IACT;AACD"}},
    {"offset": {"line": 1739, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/uniq.ts"],"sourcesContent":["import { uniq as _uniq } from '@tldraw/utils'\n\n/** @public */\nexport function uniq<T>(\n\tarray:\n\t\t| {\n\t\t\t\treadonly length: number\n\t\t\t\treadonly [n: number]: T\n\t\t  }\n\t\t| null\n\t\t| undefined\n): T[] {\n\treturn _uniq(array)\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,QAAQ,aAAa;;AAGvB,SAAS,KACf,KAAA,EAOM;IACN,WAAO,uOAAA,EAAM,KAAK;AACnB"}},
    {"offset": {"line": 1755, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/EditorAtom.ts"],"sourcesContent":["import { atom, Atom } from '@tldraw/state'\nimport { WeakCache } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\n\n/**\n * An Atom that is scoped to the lifetime of an Editor.\n *\n * This is useful for storing UI state for tldraw applications. Keeping state scoped to an editor\n * instead of stored in a global atom can prevent issues with state being shared between editors\n * when navigating between pages, or when multiple editor instances are used on the same page.\n *\n * @public\n */\nexport class EditorAtom<T> {\n\tprivate states = new WeakCache<Editor, Atom<T>>()\n\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate getInitialState: (editor: Editor) => T\n\t) {}\n\n\tgetAtom(editor: Editor): Atom<T> {\n\t\treturn this.states.get(editor, () => atom(this.name, this.getInitialState(editor)))\n\t}\n\n\tget(editor: Editor): T {\n\t\treturn this.getAtom(editor).get()\n\t}\n\n\tupdate(editor: Editor, update: (state: T) => T): T {\n\t\treturn this.getAtom(editor).update(update)\n\t}\n\n\tset(editor: Editor, state: T): T {\n\t\treturn this.getAtom(editor).set(state)\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,YAAkB;;AAC3B,SAAS,iBAAiB;;;AAYnB,MAAM,WAAc;IAG1B,YACS,IAAA,EACA,eAAA,CACP;QAFO,IAAA,CAAA,IAAA,GAAA;QACA,IAAA,CAAA,eAAA,GAAA;IACN;IALK,SAAS,IAAI,mOAAA,CAA2B,EAAA;IAOhD,QAAQ,MAAA,EAAyB;QAChC,OAAO,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,QAAQ,QAAM,6NAAA,EAAK,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAC,CAAC;IACnF;IAEA,IAAI,MAAA,EAAmB;QACtB,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAM,EAAE,GAAA,CAAI;IACjC;IAEA,OAAO,MAAA,EAAgB,MAAA,EAA4B;QAClD,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAM,EAAE,MAAA,CAAO,MAAM;IAC1C;IAEA,IAAI,MAAA,EAAgB,KAAA,EAAa;QAChC,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAM,EAAE,GAAA,CAAI,KAAK;IACtC;AACD"}},
    {"offset": {"line": 1790, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/reparenting.ts"],"sourcesContent":["import { EMPTY_ARRAY } from '@tldraw/state'\nimport { TLGroupShape, TLParentId, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { IndexKey, compact, getIndexAbove, getIndexBetween } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\nimport { intersectPolygonPolygon } from '../primitives/intersect'\n\n/**\n * Reparents shapes that are no longer contained within their parent shapes.\n * todo: rename me to something more descriptive, like `reparentOccludedShapes` or `reparentAutoDroppedShapes`\n *\n * @param editor - The editor instance.\n * @param shapeIds - The IDs of the shapes to reparent.\n * @param opts - Optional options, including a callback to filter out certain parents, such as when removing a frame.\n *\n * @public\n */\nexport function kickoutOccludedShapes(\n\teditor: Editor,\n\tshapeIds: TLShapeId[],\n\topts?: { filter?(parent: TLShape): boolean }\n) {\n\tconst parentsToCheck = new Set<TLShape>()\n\n\tfor (const id of shapeIds) {\n\t\tconst shape = editor.getShape(id)\n\n\t\tif (!shape) continue\n\t\tparentsToCheck.add(shape)\n\n\t\tconst parent = editor.getShape(shape.parentId)\n\t\tif (!parent) continue\n\t\tparentsToCheck.add(parent)\n\t}\n\n\t// Check all of the parents and gather up parents who have lost children\n\tconst parentsToLostChildren = new Map<TLShape, TLShapeId[]>()\n\n\tfor (const parent of parentsToCheck) {\n\t\tconst childIds = editor.getSortedChildIdsForParent(parent)\n\t\tif (opts?.filter && !opts.filter(parent)) {\n\t\t\t// If the shape is filtered out, we kick out all of its children\n\t\t\tparentsToLostChildren.set(parent, childIds)\n\t\t} else {\n\t\t\tconst overlappingChildren = getOverlappingShapes(editor, parent.id, childIds)\n\t\t\tif (overlappingChildren.length < childIds.length) {\n\t\t\t\tparentsToLostChildren.set(\n\t\t\t\t\tparent,\n\t\t\t\t\tchildIds.filter((id) => !overlappingChildren.includes(id))\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get all of the shapes on the current page, sorted by their index\n\tconst sortedShapeIds = editor.getCurrentPageShapesSorted().map((s) => s.id)\n\n\tconst parentsToNewChildren: Record<\n\t\tTLParentId,\n\t\t{ parentId: TLParentId; shapeIds: TLShapeId[]; index?: IndexKey }\n\t> = {}\n\n\tfor (const [prevParent, lostChildrenIds] of parentsToLostChildren) {\n\t\tconst lostChildren = compact(lostChildrenIds.map((id) => editor.getShape(id)))\n\n\t\t// Don't fall \"up\" into frames in front of the shape\n\t\t// if (pageShapes.indexOf(shape) < frameSortPosition) continue shapeCheck\n\n\t\t// Otherwise, we have no next dropping shape under the cursor, so go find\n\t\t// all the frames on the page where the moving shapes will fall into\n\t\tconst { reparenting, remainingShapesToReparent } = getDroppedShapesToNewParents(\n\t\t\teditor,\n\t\t\tlostChildren,\n\t\t\t(shape, maybeNewParent) => {\n\t\t\t\t// If we're filtering out a potential parent, don't reparent shapes to the filtered out shape\n\t\t\t\tif (opts?.filter && !opts.filter(maybeNewParent)) return false\n\t\t\t\treturn (\n\t\t\t\t\tmaybeNewParent.id !== prevParent.id &&\n\t\t\t\t\tsortedShapeIds.indexOf(maybeNewParent.id) < sortedShapeIds.indexOf(shape.id)\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treparenting.forEach((childrenToReparent, newParentId) => {\n\t\t\tif (childrenToReparent.length === 0) return\n\t\t\tif (!parentsToNewChildren[newParentId]) {\n\t\t\t\tparentsToNewChildren[newParentId] = {\n\t\t\t\t\tparentId: newParentId,\n\t\t\t\t\tshapeIds: [],\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentsToNewChildren[newParentId].shapeIds.push(...childrenToReparent.map((s) => s.id))\n\t\t})\n\n\t\t// Reparent the rest to the page (or containing group)\n\t\tif (remainingShapesToReparent.size > 0) {\n\t\t\t// The remaining shapes are going to be reparented to the old parent's containing group, if there was one, or else to the page\n\t\t\tconst newParentId =\n\t\t\t\teditor.findShapeAncestor(prevParent, (s) => editor.isShapeOfType(s, 'group'))?.id ??\n\t\t\t\teditor.getCurrentPageId()\n\n\t\t\tremainingShapesToReparent.forEach((shape) => {\n\t\t\t\tif (!parentsToNewChildren[newParentId]) {\n\t\t\t\t\tlet insertIndexKey: IndexKey | undefined\n\n\t\t\t\t\tconst oldParentSiblingIds = editor.getSortedChildIdsForParent(newParentId)\n\t\t\t\t\tconst oldParentIndex = oldParentSiblingIds.indexOf(prevParent.id)\n\t\t\t\t\tif (oldParentIndex > -1) {\n\t\t\t\t\t\t// If the old parent is a direct child of the new parent, then we'll add them above the old parent but below the next sibling.\n\t\t\t\t\t\tconst siblingsIndexAbove = oldParentSiblingIds[oldParentIndex + 1]\n\t\t\t\t\t\tconst indexKeyAbove = siblingsIndexAbove\n\t\t\t\t\t\t\t? editor.getShape(siblingsIndexAbove)!.index\n\t\t\t\t\t\t\t: getIndexAbove(prevParent.index)\n\t\t\t\t\t\tinsertIndexKey = getIndexBetween(prevParent.index, indexKeyAbove)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old parent is not a direct child of the new parent, then we'll add them to the \"top\" of the new parent's children.\n\t\t\t\t\t\t// This is done automatically if we leave the index undefined, so let's do that.\n\t\t\t\t\t}\n\n\t\t\t\t\tparentsToNewChildren[newParentId] = {\n\t\t\t\t\t\tparentId: newParentId,\n\t\t\t\t\t\tshapeIds: [],\n\t\t\t\t\t\tindex: insertIndexKey,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tparentsToNewChildren[newParentId].shapeIds.push(shape.id)\n\t\t\t})\n\t\t}\n\t}\n\n\teditor.run(() => {\n\t\tObject.values(parentsToNewChildren).forEach(({ parentId, shapeIds, index }) => {\n\t\t\tif (shapeIds.length === 0) return\n\t\t\t// Before we reparent, sort the new shape ids by their place in the original absolute order on the page\n\t\t\tshapeIds.sort((a, b) => (sortedShapeIds.indexOf(a) < sortedShapeIds.indexOf(b) ? -1 : 1))\n\t\t\teditor.reparentShapes(shapeIds, parentId, index)\n\t\t})\n\t})\n}\n\n/**\n * Get the shapes that overlap with a given shape.\n *\n * @param editor - The editor instance.\n * @param shape - The shapes or shape IDs to check against.\n * @param otherShapes - The shapes or shape IDs to check for overlap.\n * @returns An array of shapes or shape IDs that overlap with the given shape.\n */\nfunction getOverlappingShapes<T extends TLShape[] | TLShapeId[]>(\n\teditor: Editor,\n\tshape: T[number],\n\totherShapes: T\n) {\n\tif (otherShapes.length === 0) {\n\t\treturn EMPTY_ARRAY\n\t}\n\n\tconst parentPageBounds = editor.getShapePageBounds(shape)\n\tif (!parentPageBounds) return EMPTY_ARRAY\n\n\tconst parentGeometry = editor.getShapeGeometry(shape)\n\tconst parentPageTransform = editor.getShapePageTransform(shape)\n\tconst parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices)\n\n\tconst _shape = editor.getShape(shape)\n\tif (!_shape) return EMPTY_ARRAY\n\n\tconst pageTransform = editor.getShapePageTransform(shape)\n\tconst clipPath = editor.getShapeUtil(_shape.type).getClipPath?.(_shape)\n\n\tconst parentPageMaskVertices = clipPath ? pageTransform.applyToPoints(clipPath) : undefined\n\tconst parentPagePolygon = parentPageMaskVertices\n\t\t? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners)\n\t\t: parentPageCorners\n\n\tif (!parentPagePolygon) return EMPTY_ARRAY\n\n\treturn otherShapes.filter((childId) => {\n\t\tconst shapePageBounds = editor.getShapePageBounds(childId)\n\t\tif (!shapePageBounds || !parentPageBounds.includes(shapePageBounds)) return false\n\n\t\tconst parentPolygonInShapeShape = editor\n\t\t\t.getShapePageTransform(childId)\n\t\t\t.clone()\n\t\t\t.invert()\n\t\t\t.applyToPoints(parentPagePolygon)\n\n\t\tconst geometry = editor.getShapeGeometry(childId)\n\n\t\treturn geometry.overlapsPolygon(parentPolygonInShapeShape)\n\t})\n}\n\n/**\n * Get the shapes that will be reparented to new parents when the shapes are dropped.\n *\n * @param editor - The editor instance.\n * @param shapes - The shapes to check.\n * @param cb - A callback to filter out certain shapes.\n * @returns An object with the shapes that will be reparented to new parents and the shapes that will be reparented to the page or their ancestral group.\n *\n * @public\n */\nexport function getDroppedShapesToNewParents(\n\teditor: Editor,\n\tshapes: Set<TLShape> | TLShape[],\n\tcb?: (shape: TLShape, parent: TLShape) => boolean\n) {\n\tconst shapesToActuallyCheck = new Set<TLShape>(shapes)\n\tconst movingGroups = new Set<TLGroupShape>()\n\n\tfor (const shape of shapes) {\n\t\tconst parent = editor.getShapeParent(shape)\n\t\tif (parent && editor.isShapeOfType(parent, 'group')) {\n\t\t\tif (!movingGroups.has(parent)) {\n\t\t\t\tmovingGroups.add(parent)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If all of a group's children are moving, then move the group instead\n\tfor (const movingGroup of movingGroups) {\n\t\tconst children = compact(\n\t\t\teditor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))\n\t\t)\n\t\tfor (const child of children) {\n\t\t\tshapesToActuallyCheck.delete(child)\n\t\t}\n\t\tshapesToActuallyCheck.add(movingGroup)\n\t}\n\n\t// this could be cached and passed in\n\tconst shapeGroupIds = new Map<TLShapeId, TLShapeId | undefined>()\n\n\tconst reparenting = new Map<TLShapeId, TLShape[]>()\n\n\tconst remainingShapesToReparent = new Set(shapesToActuallyCheck)\n\n\tconst potentialParentShapes = editor\n\t\t.getCurrentPageShapesSorted()\n\t\t// filter out any shapes that aren't frames or that are included among the provided shapes\n\t\t.filter(\n\t\t\t(s) =>\n\t\t\t\teditor.getShapeUtil(s).canReceiveNewChildrenOfType?.(s, s.type) &&\n\t\t\t\t!remainingShapesToReparent.has(s)\n\t\t)\n\n\tparentCheck: for (let i = potentialParentShapes.length - 1; i >= 0; i--) {\n\t\tconst parentShape = potentialParentShapes[i]\n\t\tconst parentShapeContainingGroupId = editor.findShapeAncestor(parentShape, (s) =>\n\t\t\teditor.isShapeOfType(s, 'group')\n\t\t)?.id\n\n\t\tconst parentGeometry = editor.getShapeGeometry(parentShape)\n\t\tconst parentPageTransform = editor.getShapePageTransform(parentShape)\n\t\tconst parentPageMaskVertices = editor.getShapeMask(parentShape)\n\t\tconst parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices)\n\t\tconst parentPagePolygon = parentPageMaskVertices\n\t\t\t? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners)\n\t\t\t: parentPageCorners\n\n\t\tif (!parentPagePolygon) continue parentCheck\n\n\t\tconst childrenToReparent = []\n\n\t\t// For each of the dropping shapes...\n\t\tshapeCheck: for (const shape of remainingShapesToReparent) {\n\t\t\t// Don't reparent a frame to itself\n\t\t\tif (parentShape.id === shape.id) continue shapeCheck\n\n\t\t\t// Use the callback to filter out certain shapes\n\t\t\tif (cb && !cb(shape, parentShape)) continue shapeCheck\n\n\t\t\tif (!shapeGroupIds.has(shape.id)) {\n\t\t\t\tshapeGroupIds.set(\n\t\t\t\t\tshape.id,\n\t\t\t\t\teditor.findShapeAncestor(shape, (s) => editor.isShapeOfType(s, 'group'))?.id\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst shapeGroupId = shapeGroupIds.get(shape.id)\n\n\t\t\t// Are the shape and the parent part of different groups?\n\t\t\tif (shapeGroupId !== parentShapeContainingGroupId) continue shapeCheck\n\n\t\t\t// Is the shape is actually the ancestor of the parent?\n\t\t\tif (editor.findShapeAncestor(parentShape, (s) => shape.id === s.id)) continue shapeCheck\n\n\t\t\t// Convert the parent polygon to the shape's space\n\t\t\tconst parentPolygonInShapeSpace = editor\n\t\t\t\t.getShapePageTransform(shape)\n\t\t\t\t.clone()\n\t\t\t\t.invert()\n\t\t\t\t.applyToPoints(parentPagePolygon)\n\n\t\t\t// If the shape overlaps the parent polygon, reparent it to that parent\n\t\t\tif (editor.getShapeGeometry(shape).overlapsPolygon(parentPolygonInShapeSpace)) {\n\t\t\t\t// Use the util to check if the shape can be reparented to the parent\n\t\t\t\tif (\n\t\t\t\t\t!editor.getShapeUtil(parentShape).canReceiveNewChildrenOfType?.(parentShape, shape.type)\n\t\t\t\t)\n\t\t\t\t\tcontinue shapeCheck\n\n\t\t\t\tif (shape.parentId !== parentShape.id) {\n\t\t\t\t\tchildrenToReparent.push(shape)\n\t\t\t\t}\n\t\t\t\tremainingShapesToReparent.delete(shape)\n\t\t\t\tcontinue shapeCheck\n\t\t\t}\n\t\t}\n\n\t\tif (childrenToReparent.length) {\n\t\t\treparenting.set(parentShape.id, childrenToReparent)\n\t\t}\n\t}\n\n\treturn {\n\t\t// these are the shapes that will be reparented to new parents\n\t\treparenting,\n\t\t// these are the shapes that will be reparented to the page or their ancestral group\n\t\tremainingShapesToReparent,\n\t}\n}\n"],"names":["shapeIds"],"mappings":"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"}},
    {"offset": {"line": 1967, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/richText.ts"],"sourcesContent":["import { getSchema, JSONContent, Editor as TTEditor } from '@tiptap/core'\nimport { Node, Schema } from '@tiptap/pm/model'\nimport { EditorProviderProps } from '@tiptap/react'\nimport { TLRichText } from '@tldraw/tlschema'\nimport { assert, WeakCache } from '@tldraw/utils'\nimport { Editor } from '../editor/Editor'\nimport { TLFontFace } from '../editor/managers/FontManager/FontManager'\n\n/**\n * This is the TipTap editor! Docs are {@link https://tiptap.dev/docs}.\n *\n * @public\n */\nexport type TiptapEditor = TTEditor\n\n/**\n * A TipTap node. See {@link https://tiptap.dev/docs}.\n * @public\n */\nexport type TiptapNode = Node\n\n/** @public */\nexport interface TLTextOptions {\n\ttipTapConfig?: EditorProviderProps\n\taddFontsFromNode?: RichTextFontVisitor\n}\n\n/** @public */\nexport interface RichTextFontVisitorState {\n\treadonly family: string\n\treadonly weight: string\n\treadonly style: string\n}\n\n/** @public */\nexport type RichTextFontVisitor = (\n\tnode: TiptapNode,\n\tstate: RichTextFontVisitorState,\n\taddFont: (font: TLFontFace) => void\n) => RichTextFontVisitorState\n\nconst schemaCache = new WeakCache<EditorProviderProps, Schema>()\nexport function getTipTapSchema(tipTapConfig: EditorProviderProps) {\n\treturn schemaCache.get(tipTapConfig, () => getSchema(tipTapConfig.extensions ?? []))\n}\n\n/** @public */\nexport function getFontsFromRichText(\n\teditor: Editor,\n\trichText: TLRichText,\n\tinitialState: RichTextFontVisitorState\n) {\n\tconst { tipTapConfig, addFontsFromNode } = editor.getTextOptions()\n\tassert(tipTapConfig, 'textOptions.tipTapConfig must be set to use rich text')\n\tassert(addFontsFromNode, 'textOptions.addFontsFromNode must be set to use rich text')\n\n\tconst schema = getTipTapSchema(tipTapConfig)\n\n\tconst rootNode = Node.fromJSON(schema, richText as JSONContent)\n\n\tconst fonts = new Set<TLFontFace>()\n\n\tfunction addFont(font: TLFontFace) {\n\t\tfonts.add(font)\n\t}\n\n\tfunction visit(node: TiptapNode, state: RichTextFontVisitorState) {\n\t\tstate = addFontsFromNode!(node, state, addFont)\n\n\t\tfor (const child of node.children) {\n\t\t\tvisit(child, state)\n\t\t}\n\t}\n\n\tvisit(rootNode, initialState)\n\n\treturn Array.from(fonts)\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,iBAAkD;;AAC3D,SAAS,YAAoB;;;AAG7B,SAAS,QAAQ,iBAAiB;;;;AAqClC,MAAM,cAAc,IAAI,mOAAA,CAAuC;AACxD,SAAS,gBAAgB,YAAA,EAAmC;IAClE,OAAO,YAAY,GAAA,CAAI,cAAc,QAAM,mNAAA,EAAU,aAAa,UAAA,IAAc,CAAC,CAAC,CAAC;AACpF;AAGO,SAAS,qBACf,MAAA,EACA,QAAA,EACA,YAAA,EACC;IACD,MAAM,EAAE,YAAA,EAAc,gBAAA,CAAiB,CAAA,GAAI,OAAO,cAAA,CAAe;IACjE,IAAA,kOAAA,EAAO,cAAc,uDAAuD;IAC5E,IAAA,kOAAA,EAAO,kBAAkB,2DAA2D;IAEpF,MAAM,SAAS,gBAAgB,YAAY;IAE3C,MAAM,WAAW,kNAAA,CAAK,QAAA,CAAS,QAAQ,QAAuB;IAE9D,MAAM,QAAQ,aAAA,GAAA,IAAI,IAAgB;IAElC,SAAS,QAAQ,IAAA,EAAkB;QAClC,MAAM,GAAA,CAAI,IAAI;IACf;IAEA,SAAS,MAAM,IAAA,EAAkB,KAAA,EAAiC;QACjE,QAAQ,iBAAkB,MAAM,OAAO,OAAO;QAE9C,KAAA,MAAW,SAAS,KAAK,QAAA,CAAU;YAClC,MAAM,OAAO,KAAK;QACnB;IACD;IAEA,MAAM,UAAU,YAAY;IAE5B,OAAO,MAAM,IAAA,CAAK,KAAK;AACxB"}},
    {"offset": {"line": 2011, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/sync/hardReset.ts"],"sourcesContent":["import { clearLocalStorage, clearSessionStorage } from '@tldraw/utils'\nimport { deleteDB } from 'idb'\nimport { LocalIndexedDb, getAllIndexDbNames } from './LocalIndexedDb'\n\n/**\n * Clear the database of all data associated with tldraw.\n *\n * @public */\nexport async function hardReset({ shouldReload = true } = {}) {\n\tclearSessionStorage()\n\n\tfor (const instance of LocalIndexedDb.connectedInstances) {\n\t\tawait instance.close()\n\t}\n\tawait Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)))\n\n\tclearLocalStorage()\n\tif (shouldReload) {\n\t\twindow.location.reload()\n\t}\n}\n\nif (typeof window !== 'undefined') {\n\tif (process.env.NODE_ENV === 'development') {\n\t\t;(window as any).hardReset = hardReset\n\t}\n\t// window.__tldraw__hardReset is used to inject the logic into the tldraw library\n\t;(window as any).__tldraw__hardReset = hardReset\n}\n"],"names":[],"mappings":";;;;AAuBK,QAAQ,IAAI,aAAa;AAvB9B,SAAS,mBAAmB,2BAA2B;;AACvD,SAAS,gBAAgB;AACzB,SAAS,gBAAgB,0BAA0B;;;;AAMnD,eAAsB,UAAU,EAAE,eAAe,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA,EAAG;IAC7D,IAAA,+OAAA,CAAoB;IAEpB,KAAA,MAAW,YAAY,mQAAA,CAAe,kBAAA,CAAoB;QACzD,MAAM,SAAS,KAAA,CAAM;IACtB;IACA,MAAM,QAAQ,GAAA,KAAI,uQAAA,CAAmB,GAAE,GAAA,CAAI,CAAC,SAAO,sNAAA,EAAS,EAAE,CAAC,CAAC;IAEhE,IAAA,6OAAA,CAAkB;IAClB,IAAI,cAAc;QACjB,OAAO,QAAA,CAAS,MAAA,CAAO;IACxB;AACD;AAEA,IAAI,OAAO,WAAW,aAAa;IAClC,wCAA4C;;QACzC,OAAe,SAAA,GAAY;IAC9B;;IAEE,OAAe,mBAAA,GAAsB;AACxC"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///Users/nazy/ADK_WORKSPACE/TutorMekimi/tutorme-app/node_modules/%40tldraw/editor/src/lib/utils/window-open.ts"],"sourcesContent":["import { runtime } from './runtime'\n\n/**\n * Open a new window with the given URL and target. Prefer this to the window.open function, as it\n * will work more reliably in embedded scenarios, such as our VS Code extension. See the runtime\n * object in tldraw/editor for more details.\n *\n * @param url - The URL to open.\n * @param target - The target window to open the URL in.\n * @param allowReferrer - Whether to allow the referrer to be sent to the new window.\n * @returns The new window object.\n * @public\n */\nexport function openWindow(url: string, target = '_blank', allowReferrer?: boolean) {\n\treturn runtime.openWindow(url, target, allowReferrer)\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,eAAe;;AAajB,SAAS,WAAW,GAAA,EAAa,SAAS,QAAA,EAAU,aAAA,EAAyB;IACnF,OAAO,6OAAA,CAAQ,UAAA,CAAW,KAAK,QAAQ,aAAa;AACrD"}}]
}